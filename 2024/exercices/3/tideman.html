<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Fran√ßais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en Fran√ßais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        M√©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de Donn√©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        Cybers√©curit√©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">Honn√™tet√© Acad√©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions Fr√©quemment Pos√©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">√âquipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>Tideman</h1>
<h2>Probl√®me √† r√©soudre</h2>
<p>Vous connaissez d√©j√† les √©lections √† la pluralit√©, qui suivent un algorithme tr√®s simple pour d√©terminer le vainqueur d'une √©lection : chaque √©lecteur dispose d'une voix, et le candidat qui obtient le plus de voix gagne.</p>
<p>Mais le vote √† la pluralit√© pr√©sente quelques inconv√©nients. Que se passe-t-il, par exemple, lors d'une √©lection avec trois candidats, et que les bulletins de vote ci-dessous sont exprim√©s ?</p>
<p><img alt="Cinq bulletins de vote, √©galit√© entre Alice et Bob" src="https://cs50.harvard.edu/x/2024/psets/3/fptp_ballot_1.png" /></p>
<p>Un vote √† la pluralit√© d√©clarerait ici une √©galit√© entre Alice et Bob, puisque chacun obtient deux voix. Mais est-ce le bon r√©sultat ?</p>
<p>Il existe un autre type de syst√®me de vote appel√© syst√®me de vote par choix hi√©rarchis√©. Dans un syst√®me √† choix hi√©rarchis√©, les √©lecteurs peuvent voter pour plus d'un candidat. Au lieu de voter uniquement pour leur premier choix, ils peuvent classer les candidats par ordre de pr√©f√©rence. Les bulletins de vote qui en r√©sultent pourraient donc ressembler √† ceux ci-dessous.</p>
<p><img alt="Cinq bulletins de vote, avec des pr√©f√©rences class√©es" src="https://cs50.harvard.edu/x/2024/psets/3/ranked_ballot_1.png" /></p>
<p>Ici, chaque √©lecteur, en plus de sp√©cifier son candidat de premi√®re pr√©f√©rence, a √©galement indiqu√© ses deuxi√®me et troisi√®me choix. Et maintenant, ce qui √©tait auparavant une √©lection √† √©galit√© pourrait avoir un vainqueur. La course √©tait √† l'origine √† √©galit√© entre Alice et Bob. Mais l'√©lecteur qui a choisi Charlie a pr√©f√©r√© Alice √† Bob, donc Alice pourrait ici √™tre d√©clar√©e gagnante.</p>
<p>Le vote par choix hi√©rarchis√© peut √©galement r√©soudre un autre inconv√©nient potentiel du vote √† la pluralit√©. Examinez les bulletins de vote suivants.</p>
<p><img alt="Neuf bulletins de vote, avec des pr√©f√©rences class√©es" src="https://cs50.harvard.edu/x/2024/psets/3/condorcet_1.png" /></p>
<p>Qui devrait gagner cette √©lection ? Dans un vote √† la pluralit√© o√π chaque √©lecteur choisit uniquement sa premi√®re pr√©f√©rence, Charlie remporte cette √©lection avec quatre voix contre seulement trois pour Bob et deux pour Alice. (Notez que, si vous connaissez le syst√®me de vote √† √©limination instantan√©e, Charlie gagne √©galement ici sous ce syst√®me). Alice pourrait cependant raisonnablement faire valoir qu'elle devrait √™tre la gagnante de l'√©lection au lieu de Charlie : apr√®s tout, parmi les neuf √©lecteurs, une majorit√© (cinq d'entre eux) pr√©f√©rait Alice √† Charlie, donc la plupart des gens seraient plus heureux avec Alice comme gagnante plut√¥t que Charlie.</p>
<p>Alice est, dans cette √©lection, la soi-disant ¬´ gagnante Condorcet ¬ª de l'√©lection : la personne qui aurait remport√© n'importe quel affrontement direct contre un autre candidat. Si l'√©lection n'avait √©t√© qu'entre Alice et Bob, ou seulement entre Alice et Charlie, Alice aurait gagn√©.</p>
<p>La m√©thode de vote Tideman (√©galement connue sous le nom de ¬´ paires class√©es ¬ª) est une m√©thode de vote par choix hi√©rarchis√© qui garantit de produire le vainqueur Condorcet de l'√©lection s'il en existe un. Dans un fichier appel√© <code>tideman.c</code> dans un dossier appel√© <code>tideman</code>, cr√©ez un programme pour simuler une √©lection selon la m√©thode de vote Tideman.</p>
<h2>D√©mo</h2>
<script async="" data-autoplay="1" data-cols="100" data-loop="1" data-rows="12" id="asciicast-FWidrKAwqxtepXlN1T0l5hNnJ" src="https://asciinema.org/a/FWidrKAwqxtepXlN1T0l5hNnJ.js"></script>

<h2>Code de distribution</h2>
<p>Connectez-vous √† <a href="https://cs50.dev/">cs50.dev</a>, cliquez sur la fen√™tre de votre terminal et ex√©cutez <code>cd</code> par lui-m√™me. Vous devriez constater que l'invite de votre fen√™tre de terminal ressemble √† ce qui suit :</p>
<pre><code>  $
</code></pre>
<p>Ensuite, ex√©cutez</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/3/tideman.zip
</code></pre>
<p>afin de t√©l√©charger un ZIP appel√© <code>tideman.zip</code> dans votre espace de code.</p>
<p>Ensuite, ex√©cutez</p>
<pre><code>  unzip tideman.zip
</code></pre>
<p>pour cr√©er un dossier appel√© <code>tideman</code>. Vous n'avez plus besoin du fichier ZIP, vous pouvez donc ex√©cuter</p>
<pre><code>  rm tideman.zip
</code></pre>
<p>et r√©pondre par ¬´ y ¬ª suivi d'Entr√©e √† l'invite pour supprimer le fichier ZIP que vous avez t√©l√©charg√©.</p>
<p>Tapez maintenant</p>
<pre><code>  cd tideman
</code></pre>
<p>suivi de la touche Entr√©e pour vous d√©placer (c'est-√†-dire ouvrir) dans ce r√©pertoire. Votre invite devrait maintenant ressembler √† ce qui suit.</p>
<pre><code>  tideman/ $
</code></pre>
<p>Si tout s'est bien pass√©, vous devez ex√©cuter</p>
<pre><code>  ls
</code></pre>
<p>et voir un fichier nomm√© <code>tideman.c</code>. L'ex√©cution de <code>code tideman.c</code> devrait ouvrir le fichier dans lequel vous taperez votre code pour cet ensemble de probl√®mes. Sinon, revenez sur vos pas et voyez si vous pouvez d√©terminer o√π vous vous √™tes tromp√©¬†!</p>
<h2>Contexte</h2>
<p>En r√®gle g√©n√©rale, la m√©thode de Tideman fonctionne en construisant un ¬´ graphe ¬ª de candidats, o√π une fl√®che (c'est-√†-dire un bord) du candidat A au candidat B indique que le candidat A gagne contre le candidat B dans un match en t√™te-√†-t√™te. Dans ce cas, le graphique de l'√©lection ci-dessus ressemblerait √† celui ci-dessous.</p>
<p><img alt="Neuf bulletins de vote, avec des pr√©f√©rences class√©es" src="https://cs50.harvard.edu/x/2024/psets/3/condorcet_graph_1.png" /></p>
<p>La fl√®che d'Alice √† Bob signifie que plus d'√©lecteurs pr√©f√®rent Alice √† Bob (5 pr√©f√®rent Alice, 4 pr√©f√®rent Bob). De m√™me, les autres fl√®ches signifient que plus d'√©lecteurs pr√©f√®rent Alice √† Charlie, et plus d'√©lecteurs pr√©f√®rent Charlie √† Bob.</p>
<p>En regardant ce graphique, la m√©thode Tideman dit que le vainqueur de l'√©lection devrait √™tre la ¬´ source ¬ª du graphique (c'est-√†-dire le candidat qui n'a aucune fl√®che pointant vers lui). Dans ce cas, la source est Alice ‚Äî Alice est la seule √† n'avoir aucune fl√®che pointant vers elle, ce qui signifie que personne n'est pr√©f√©r√© √† Alice en t√™te-√†-t√™te. Alice est donc d√©clar√©e vainqueur de l'√©lection.</p>
<p>Il est cependant possible que lorsque les fl√®ches sont trac√©es, il n'y ait pas de vainqueur de Condorcet. Examinez les bulletins de vote ci-dessous.</p>
<p><img alt="Neuf bulletins de vote, avec des pr√©f√©rences class√©es" src="https://cs50.harvard.edu/x/2024/psets/3/no_condorcet_1.png" /></p>
<p>Entre Alice et Bob, Alice est pr√©f√©r√©e √† Bob par une marge de 7-2. Entre Bob et Charlie, Bob est pr√©f√©r√© √† Charlie par une marge de 5-4. Mais entre Charlie et Alice, Charlie est pr√©f√©r√© √† Alice par une marge de 6-3. Si nous tra√ßons le graphique, il n'y a pas de source ! Nous avons un cycle de candidats, o√π Alice bat Bob qui bat Charlie qui bat Alice (un peu comme un jeu de pierre-papier-ciseaux). Dans ce cas, il semble qu'il n'y ait aucun moyen de choisir un gagnant.</p>
<p>Pour g√©rer cela, l'algorithme de Tideman doit veiller √† √©viter de cr√©er des cycles dans le graphe des candidats. Comment s'y prend-il¬†? L'algorithme verrouille d'abord les bords les plus forts, car ce sont sans doute les plus importants. En particulier, l'algorithme de Tideman sp√©cifie que les bords de confrontation doivent √™tre ¬´ verrouill√©s ¬ª dans le graphique un par un, en fonction de la ¬´ force ¬ª de la victoire (plus il y a de personnes qui pr√©f√®rent un candidat √† son adversaire, plus la victoire est forte). Tant que le bord peut √™tre verrouill√© dans le graphique sans cr√©er de cycle, le bord est ajout√©¬†; sinon, le bord est ignor√©.</p>
<p>Comment cela fonctionnerait-il dans le cas des votes ci-dessus¬†? Eh bien, la plus grande marge de victoire pour une paire est Alice battant Bob, puisque 7 √©lecteurs pr√©f√®rent Alice √† Bob (aucun autre affrontement n'a un gagnant pr√©f√©r√© par plus de 7 √©lecteurs). Ainsi, la fl√®che Alice-Bob est d'abord verrouill√©e dans le graphique. La deuxi√®me plus grande marge de victoire est la victoire de Charlie sur Alice par 6-3, donc cette fl√®che est verrouill√©e ensuite.</p>
<p>Vient ensuite la victoire de Bob sur Charlie par 5-4. Mais remarquez¬†: si nous devions ajouter une fl√®che de Bob √† Charlie maintenant, nous cr√©erions un cycle¬†! Puisque le graphe ne peut pas autoriser de cycles, nous devons ignorer ce bord, et ne pas l'ajouter du tout au graphe. S'il y avait plus de fl√®ches √† consid√©rer, nous les examinerions ensuite, mais c'√©tait la derni√®re fl√®che, donc le graphe est complet.</p>
<p>Ce processus √©tape par √©tape est illustr√© ci-dessous, avec le graphique final √† droite.</p>
<p><img alt="Neuf bulletins de vote, avec des pr√©f√©rences class√©es" src="https://cs50.harvard.edu/x/2024/psets/3/lockin.png" /></p>
<p>D'apr√®s le graphe r√©sultant, Charlie est la source (aucune fl√®che ne pointe vers Charlie), donc Charlie est d√©clar√© vainqueur de cette √©lection.</p>
<p>En termes plus formels, la m√©thode de vote de Tideman comprend trois parties¬†:</p>
<ul>
<li><strong>Compte</strong>¬†: Une fois que tous les √©lecteurs ont indiqu√© toutes leurs pr√©f√©rences, d√©terminez, pour chaque paire de candidats, quel est le candidat pr√©f√©r√© et par quelle marge il est pr√©f√©r√©.</li>
<li><strong>Trier</strong>¬†: Triez les paires de candidats par ordre d√©croissant de force de victoire, o√π la force de victoire est d√©finie comme le nombre d'√©lecteurs qui pr√©f√®rent le candidat pr√©f√©r√©.</li>
<li><strong>Verrouiller</strong>¬†: En commen√ßant par la paire la plus forte, parcourez les paires de candidats dans l'ordre et ¬´ verrouillez ¬ª chaque paire dans le graphe des candidats, tant que le verrouillage de cette paire ne cr√©e pas de cycle dans le graphe.</li>
</ul>
<p>Une fois le graphe termin√©, la source du graphe (celle qui n'a aucun bord pointant vers elle) est le gagnant¬†!</p>
<h2>Comprendre</h2>
<p>Jetons un ≈ìil √† <code>tideman.c</code>.</p>
<p>Premi√®rement, remarquez le tableau bidimensionnel <code>preferences</code>. L'entier <code>preferences[i][j]</code> repr√©sentera le nombre d'√©lecteurs qui pr√©f√®rent le candidat <code>i</code> par rapport au candidat <code>j</code>.</p>
<p>Le fichier d√©finit √©galement un autre tableau bidimensionnel, appel√© <code>locked</code>, qui repr√©sentera le graphe de candidats. <code>locked</code> est un tableau bool√©en, donc <code>locked[i][j]</code> √©tant <code>vrai</code> repr√©sente l'existence d'une ar√™te pointant du candidat <code>i</code> vers le candidat <code>j</code>; <code>faux</code> signifie qu'il n'y a pas d'ar√™te. (Si vous √™tes curieux, cette repr√©sentation d'un graphe est appel√©e une ¬´ matrice d'adjacence ¬ª).</p>
<p>Vient ensuite un <code>struct</code> appel√© <code>pair</code>, utilis√© pour repr√©senter une paire de candidats¬†: chaque paire inclut l'index du candidat <code>gagnant</code> et l'index du candidat <code>perdant</code>.</p>
<p>Les candidats eux-m√™mes sont stock√©s dans le tableau <code>candidates</code>, qui est un tableau de <code>string</code> repr√©sentant les noms de chacun des candidats. Il existe √©galement un tableau de <code>pairs</code>, qui repr√©sentera toutes les paires de candidats (pour lesquelles l'un est pr√©f√©r√© √† l'autre) dans l'√©lection.</p>
<p>Le programme a √©galement deux variables globales¬†: <code>pair_count</code> et <code>candidate_count</code>, repr√©sentant respectivement le nombre de paires et le nombre de candidats dans les tableaux <code>pairs</code> et <code>candidates</code>.</p>
<p>Passons maintenant √† <code>main</code>. Notez qu'apr√®s avoir d√©termin√© le nombre de candidats, le programme boucle sur le graphe <code>locked</code> et d√©finit initialement toutes les valeurs √† <code>faux</code>, ce qui signifie que notre graphe initial ne contiendra aucune ar√™te.</p>
<p>Ensuite, le programme boucle sur tous les √©lecteurs et collecte leurs pr√©f√©rences dans un tableau appel√© <code>ranks</code> (via un appel √† <code>vote</code>), o√π <code>ranks[i]</code> est l'index du candidat qui a la pr√©f√©rence <code>i</code> pour l'√©lecteur. Ces rangs sont transmis √† la fonction <code>record_preference</code>, dont le r√¥le est de prendre ces rangs et de mettre √† jour la variable globale <code>preferences</code>.</p>
<p>Une fois tous les votes enregistr√©s, les paires de candidats sont ajout√©es au tableau <code>pairs</code> via un appel √† <code>add_pairs</code>, tri√©es via un appel √† <code>sort_pairs</code>, et verrouill√©es dans le graphe via un appel √† <code>lock_pairs</code>. Enfin, <code>print_winner</code> est appel√© pour imprimer le nom du gagnant de l'√©lection¬†!</p>
<p>Plus bas dans le fichier, vous verrez que les fonctions <code>vote</code>, <code>record_preference</code>, <code>add_pairs</code>,<code>sort_pairs</code>, <code>lock_pairs</code> et <code>print_winner</code> sont laiss√©es vides. √Ä vous de jouer¬†!</p>
<h2>Sp√©cification</h2>
<p>Compl√©tez l'impl√©mentation de <code>tideman.c</code> de mani√®re √† simuler une √©lection de Tideman.</p>
<ul>
<li>Compl√©tez la fonction <code>vote</code>.<ul>
<li>La fonction prend comme arguments <code>rang</code>, <code>nom</code> et <code>rangs</code>. Si <code>nom</code> correspond au nom d'un candidat valide, vous devez mettre √† jour le tableau <code>rangs</code> pour indiquer que l'√©lecteur a le candidat comme pr√©f√©rence <code>rang</code> (o√π <code>0</code> est la premi√®re pr√©f√©rence, <code>1</code> est la deuxi√®me pr√©f√©rence, etc.)</li>
<li>Rappelez-vous que <code>rangs[i]</code> repr√©sente ici la <code>i</code>√®me pr√©f√©rence de l'utilisateur.</li>
<li>La fonction doit renvoyer <code>vrai</code> si le rang a √©t√© enregistr√© avec succ√®s, et <code>faux</code> sinon (si, par exemple, <code>nom</code> n'est pas le nom de l'un des candidats).</li>
<li>Vous pouvez supposer qu'aucun candidat n'aura le m√™me nom.</li>
</ul>
</li>
<li>Compl√©tez la fonction <code>record_preferences</code>.<ul>
<li>La fonction est appel√©e une fois pour chaque √©lecteur, et prend comme argument le tableau <code>rangs</code>, (rappelez-vous que <code>rangs[i]</code> est la <code>i</code>√®me pr√©f√©rence de l'√©lecteur, o√π <code>ranks[0]</code> est la premi√®re pr√©f√©rence).</li>
<li>La fonction doit mettre √† jour le tableau global <code>preferences</code> pour ajouter les pr√©f√©rences de l'√©lecteur actuel. Rappelez-vous que <code>preferences[i][j]</code> doit repr√©senter le nombre d'√©lecteurs qui pr√©f√®rent le candidat <code>i</code> par rapport au candidat <code>j</code>.</li>
<li>Vous pouvez supposer que chaque √©lecteur classera chacun des candidats.</li>
</ul>
</li>
<li>Compl√©tez la fonction <code>add_pairs</code>.<ul>
<li>La fonction doit ajouter toutes les paires de candidats o√π un candidat est pr√©f√©r√© au tableau <code>pairs</code>. Une paire de candidats qui sont √† √©galit√© (l'un n'est pas pr√©f√©r√© √† l'autre) ne doit pas √™tre ajout√©e au tableau.</li>
<li>La fonction doit mettre √† jour la variable globale <code>pair_count</code> pour qu'elle soit √©gale au nombre de paires de candidats. (Les paires doivent donc toutes √™tre stock√©es entre <code>pairs[0]</code> et <code>pairs[pair_count - 1]</code>, inclus).</li>
</ul>
</li>
<li>Compl√©tez la fonction <code>sort_pairs</code>.<ul>
<li>La fonction doit trier le tableau <code>pairs</code> par ordre d√©croissant de force de victoire, o√π la force de victoire est d√©finie comme le nombre d'√©lecteurs qui pr√©f√®rent le candidat pr√©f√©r√©. Si plusieurs paires ont la m√™me force de victoire, vous pouvez supposer que l'ordre n'a pas d'importance.</li>
</ul>
</li>
<li>Compl√©tez la fonction <code>lock_pairs</code>.<ul>
<li>La fonction doit cr√©er le graphe <code>locked</code>, en ajoutant toutes les ar√™tes par ordre d√©croissant de force de victoire tant que l'ar√™te ne cr√©erait pas de cycle.</li>
</ul>
</li>
<li>Compl√©tez la fonction <code>print_winner</code>.<ul>
<li>La fonction doit imprimer le nom du candidat qui est la source du graphe. Vous pouvez supposer qu'il n'y aura pas plus d'une source.</li>
</ul>
</li>
</ul>
<p>Vous ne devez rien modifier d'autre dans <code>tideman.c</code> que les impl√©mentations des fonctions <code>vote</code>, <code>record_preferences</code>, <code>add_pairs</code>, <code>sort_pairs</code>, <code>lock_pairs</code> et <code>print_winner</code> (et l'inclusion de fichiers d'en-t√™te suppl√©mentaires, si vous le souhaitez). Vous √™tes autoris√© √† ajouter des fonctions suppl√©mentaires √† <code>tideman.c</code>, √† condition de ne pas modifier les d√©clarations des fonctions existantes.</p>
<h2>Proc√©dure pas √† pas</h2>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/kb83NwyYI68?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<h2>Comment tester</h2>
<p>Assurez-vous de tester votre code pour vous assurer qu'il g√®re¬†:</p>
<ul>
<li>Une √©lection avec n'importe quel nombre de candidats (jusqu'√† <code>MAX</code> de <code>9</code>)</li>
<li>Voter pour un candidat par son nom</li>
<li>Votes invalides pour les candidats qui ne sont pas sur le bulletin de vote</li>
<li>Impression du gagnant de l'√©lection</li>
</ul>
<h3>Justesse</h3>
<pre><code>  check50 cs50/problems/2024/x/tideman
</code></pre>
<h3>Style</h3>
<pre><code>  style50 tideman.c
</code></pre>
<h2>Comment soumettre</h2>
<pre><code>  submit50 cs50/problems/2024/x/tideman
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>