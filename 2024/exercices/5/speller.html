<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en FranÃ§ais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en FranÃ§ais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch ğŸ˜º
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        MÃ©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de DonnÃ©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        CybersÃ©curitÃ©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">HonnÃªtetÃ© AcadÃ©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions FrÃ©quemment PosÃ©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Ã‰quipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>Correcteur orthographique</h1>
<h2>ProblÃ¨me Ã  rÃ©soudre</h2>
<p>Dans ce problÃ¨me, vous implÃ©menterez un programme qui vÃ©rifie l'orthographe d'un fichier, comme ci-dessous, en utilisant une table de hachage.</p>
<h2>DÃ©monstration</h2>
<script async="" data-autoplay="1" data-cols="100" data-loop="1" data-rows="12" id="asciicast-o01nuZNSBSH2khVokTs2GEPtP" src="https://asciinema.org/a/o01nuZNSBSH2khVokTs2GEPtP.js"></script>

<h2>Code de distribution</h2>
<p>Dans ce problÃ¨me, vous allez Ã©tendre les fonctionnalitÃ©s du code fourni par lâ€™Ã©quipe de CS50.</p>
<p>Connectez-vous Ã  <a href="https://cs50.dev/">cs50.dev</a>, cliquez sur votre fenÃªtre de terminal et exÃ©cutez <code>cd</code> par lui-mÃªme. L'invite de votre fenÃªtre de terminal devrait ressembler Ã  ce qui suitÂ :</p>
<pre><code>  $
</code></pre>
<p>ExÃ©cutez ensuiteÂ :</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/5/speller.zip
</code></pre>
<p>pour tÃ©lÃ©charger un ZIP appelÃ© <code>speller.zip</code> dans votre espace de code.</p>
<p>Ensuite, exÃ©cutezÂ :</p>
<pre><code>  unzip speller.zip
</code></pre>
<p>pour crÃ©er un dossier appelÃ© <code>speller</code>. Vous nâ€™avez plus besoin du fichier ZIP, vous pouvez donc exÃ©cuterÂ :</p>
<pre><code>  rm speller.zip
</code></pre>
<p>et rÃ©pondre parÂ Â«Â yÂ Â» suivi de la touche EntrÃ©e Ã  lâ€™invite pour supprimer le fichier ZIP que vous avez tÃ©lÃ©chargÃ©.</p>
<p>Tapez maintenantÂ :</p>
<pre><code>  cd speller
</code></pre>
<p>suivi de la touche EntrÃ©e pour vous dÃ©placer dans (câ€™est-Ã -dire ouvrir) ce rÃ©pertoire. Votre invite devrait dÃ©sormais ressembler Ã  ce qui suitÂ :</p>
<pre><code>  speller/ $
</code></pre>
<p>ExÃ©cutez <code>ls</code> par lui-mÃªme, et vous devriez voir quelques fichiers et dossiersÂ :</p>
<pre><code>  dictionaries/  dictionary.c  dictionary.h  keys/  Makefile  speller.c  speller50  texts/
</code></pre>
<p>Si vous rencontrez des problÃ¨mes, suivez Ã  nouveau ces mÃªmes Ã©tapes et essayez de dÃ©terminer oÃ¹ vous vous Ãªtes trompÃ©Â !</p>
<h2>Contexte</h2>
<div class="alert alert-danger" data-alert="danger" role="alert"><p><strong>Ã‰tant donnÃ© les nombreux fichiers dans ce programme, il est important de lire cette section dans son intÃ©gralitÃ© avant de commencer. Vous saurez alors quoi faire et comment le faireÂ !</strong></p></div>

<p>ThÃ©oriquement, sur une entrÃ©e de taille <em>n</em>, un algorithme avec un temps d'exÃ©cution de <em>n</em> est Â«Â asymptotiquement Ã©quivalentÂ Â», en termes de <em>O</em>, Ã  un algorithme avec un temps d'exÃ©cution de <em>2n</em>. En effet, lorsque lâ€™on dÃ©crit le temps dâ€™exÃ©cution dâ€™un algorithme, on se concentre gÃ©nÃ©ralement sur le terme dominant (câ€™est-Ã -dire le plus impactant) (ici <em>n</em>, puisque <em>n</em> pourrait Ãªtre bien plus grand que 2). Dans le monde rÃ©el, cependant, le fait est que <em>2n</em> semble deux fois plus lent que <em>n</em>.</p>
<p>Le dÃ©fi qui vous attend est dâ€™implÃ©menter le correcteur orthographique le plus rapide possibleÂ ! Par Â«Â plus rapideÂ Â», nous parlons toutefois du temps dâ€™horloge rÃ©el, et non asymptotique.</p>
<p>Dans <code>speller.c</code>, nous avons mis au point un programme conÃ§u pour vÃ©rifier lâ€™orthographe dâ€™un fichier aprÃ¨s avoir chargÃ© un dictionnaire de mots du disque vers la mÃ©moire. Ce dictionnaire, quant Ã  lui, est implÃ©mentÃ© dans un fichier appelÃ© <code>dictionary.c</code>. (Il pourrait simplement Ãªtre implÃ©mentÃ© dans <code>speller.c</code>, mais au fur et Ã  mesure que les programmes deviennent plus complexes, il est souvent pratique de les diviser en plusieurs fichiers.) Les prototypes des fonctions qui sâ€™y trouvent sont quant Ã  eux dÃ©finis non pas dans <code>dictionary.c</code> lui-mÃªme, mais dans <code>dictionary.h</code> Ã  la place. De cette faÃ§on, <code>speller.c</code> et <code>dictionary.c</code> peuvent tous deux <code>#include</code> le fichier. Malheureusement, nous nâ€™avons pas tout Ã  fait rÃ©ussi Ã  implÃ©menter la partie chargement. Ni la partie vÃ©rification. Les deux (et un peu plus) nous vous les laissonsÂ ! Mais dâ€™abord, une visite guidÃ©e.</p>
<h3>ComprÃ©hension</h3>
<h4><code>dictionary.h</code></h4>
<p>Ouvrez <code>dictionary.h</code>, et vous verrez une nouvelle syntaxe, y compris quelques lignes qui mentionnent <code>DICTIONARY_H</code>. Pas besoin de sâ€™inquiÃ©ter Ã  ce sujet, mais si vous Ãªtes curieux, ces lignes garantissent simplement que, mÃªme si <code>dictionary.c</code> et <code>speller.c</code> (que vous verrez dans un instant) <code>#include</code> ce fichier, <code>clang</code> ne le compilera quâ€™une seule fois.</p>
<p>Remarquez ensuite que lâ€™on utilise <code>#include</code> sur un fichier appelÃ© <code>stdbool.h</code>. Câ€™est le fichier dans lequel <code>bool</code> lui-mÃªme est dÃ©fini. Vous nâ€™en aviez pas eu besoin auparavant, car la bibliothÃ¨que CS50 avait lâ€™habitude de lâ€™inclure pour vous.</p>
<p>Remarquez Ã©galement notre utilisation de <code>#define</code>, une Â«Â directive de prÃ©processeurÂ Â» qui dÃ©finit une Â«Â constanteÂ Â» appelÃ©e <code>LENGTH</code> qui a une valeur de <code>45</code>. Câ€™est une constante dans le sens oÃ¹ vous ne pouvez pas (accidentellement) la modifier dans votre propre code. En fait, <code>clang</code> remplacera toute mention de <code>LENGTH</code> dans votre propre code par, littÃ©ralement, <code>45</code>. En dâ€™autres termes, ce nâ€™est pas une variable, juste une astuce de recherche et de remplacement.</p>
<p>Enfin, remarquez les prototypes de cinq fonctionsÂ : <code>check</code>, <code>hash</code>, <code>load</code>, <code>size</code> et <code>unload</code>. Notez que trois d'entre elles prennent un pointeur comme argument, selon le <code>*</code>Â :</p>
<pre><code>  bool check(const char *word);
  unsigned int hash(const char *word);
  bool load(const char *dictionary);
</code></pre>
<p>Rappelez-vous que <code>char *</code> est ce que nous appelions <code>string</code>. Ces trois prototypes sont donc essentiellementÂ :</p>
<pre><code>  bool check(const string word);
  unsigned int hash(const string word);
  bool load(const string dictionary);
</code></pre>
<p>Et <code>const</code>, en attendant, dit simplement que ces chaÃ®nes, lorsqu'elles sont transmises en tant qu'arguments, doivent rester constantesÂ ; vous ne pourrez pas les modifier, accidentellement ou autrementÂ !</p>
<h4><code>dictionary.c</code></h4>
<p>Ouvrez maintenant <code>dictionary.c</code>. Notez que, en haut du fichier, nous avons dÃ©fini une <code>struct</code> appelÃ©e <code>node</code> qui reprÃ©sente un nÅ“ud dans une table de hachage. Et nous avons dÃ©clarÃ© un tableau de pointeurs global, <code>table</code>, qui reprÃ©sentera (bientÃ´t) la table de hachage que vous utiliserez pour suivre les mots dans le dictionnaire. Le tableau contient <code>N</code> pointeurs de nÅ“uds, et nous avons dÃ©fini <code>N</code> Ã©gal Ã  <code>26</code> pour le moment, pour correspondre Ã  la fonction <code>hash</code> par dÃ©faut comme dÃ©crit ci-dessous. Vous voudrez probablement lâ€™augmenter en fonction de votre propre implÃ©mentation de <code>hash</code>.</p>
<p>Ensuite, notez que nous avons implÃ©mentÃ© <code>load</code>, <code>check</code>, <code>size</code> et <code>unload</code>, mais Ã  peine, juste assez pour que le code se compile. Notez Ã©galement que nous avons implÃ©mentÃ© <code>hash</code> avec un exemple d'algorithme basÃ© sur la premiÃ¨re lettre du mot. Votre travail, en fin de compte, est de rÃ©implÃ©menter ces fonctions aussi intelligemment que possible afin que ce correcteur orthographique fonctionne comme annoncÃ©. Et viteÂ !</p>
<h4><code>speller.c</code></h4>
<p>D'accord, ouvrez maintenant <code>speller.c</code> et prenez le temps d'examiner le code et les commentaires qui s'y trouvent. Vous n'aurez rien Ã  changer dans ce fichier, et vous n'avez pas besoin d'en comprendre l'intÃ©gralitÃ©, mais essayez nÃ©anmoins d'avoir une idÃ©e de sa fonctionnalitÃ©. Notez que, grÃ¢ce Ã  une fonction appelÃ©e <code>getrusage</code>, nous allons "comparer" (c'est-Ã -dire chronomÃ©trer l'exÃ©cution de) vos implÃ©mentations de <code>check</code>, <code>load</code>, <code>size</code> et <code>unload</code>. Notez Ã©galement comment nous transmettons Ã  <code>check</code> mot par mot le contenu d'un fichier Ã  vÃ©rifier. En fin de compte, nous rapportons chaque faute d'orthographe dans ce fichier ainsi qu'un certain nombre de statistiques.</p>
<p>Notez, accessoirement, que nous avons dÃ©fini l'utilisation de <code>speller</code> comme suitÂ :</p>
<p><code>UsageÂ : spellerÂ [dictionnaire]Â texte</code></p>
<p>oÃ¹ <code>dictionnaire</code> est supposÃ© Ãªtre un fichier contenant une liste de mots en minuscules, un par ligne, et <code>texte</code> est un fichier Ã  vÃ©rifier. Comme le suggÃ¨rent les crochets, la fourniture du <code>dictionnaire</code> est facultativeÂ ; si cet argument est omis, <code>speller</code> utilisera par dÃ©faut <code>dictionaries/large</code>. En d'autres termes, l'exÃ©cution de</p>
<p><code>./spellerÂ texte</code></p>
<p>Ã©quivaut Ã  exÃ©cuter</p>
<p><code>./spellerÂ dictionaries/largeÂ texte</code></p>
<p>oÃ¹ <code>texte</code> est le fichier que vous souhaitez vÃ©rifier. Autant dire que le premier est plus facile Ã  taperÂ ! (Bien sÃ»r, <code>speller</code> ne pourra charger aucun dictionnaire tant que vous n'aurez pas implÃ©mentÃ© <code>load</code> dans `dictionary.cÂ ! Jusque-lÃ , vous verrez Â«Â Impossible de chargerÂ Â».)</p>
<p>Dans le dictionnaire par dÃ©faut, notez bien, il y a 143Â 091 mots, qui doivent tous Ãªtre chargÃ©s en mÃ©moireÂ ! En fait, jetez un coup d'Å“il Ã  ce fichier pour avoir une idÃ©e de sa structure et de sa taille. Notez que chaque mot dans ce fichier apparaÃ®t en minuscules (mÃªme, pour simplifier, les noms propres et les acronymes). De haut en bas, le fichier est triÃ© lexicographiquement, avec un seul mot par ligne (chacun se terminant par <code>\n</code>). Aucun mot ne dÃ©passe 45 caractÃ¨res et aucun mot n'apparaÃ®t plus d'une fois. Pendant le dÃ©veloppement, vous pouvez trouver utile de fournir Ã  <code>speller</code> un <code>dictionnaire</code> contenant beaucoup moins de mots, de peur d'avoir du mal Ã  dÃ©boguer une structure autrement Ã©norme en mÃ©moire. Dans <code>dictionaries/small</code> se trouve un tel dictionnaire. Pour l'utiliser, exÃ©cutez</p>
<p><code>./spellerÂ dictionaries/smallÂ texte</code></p>
<p>oÃ¹ <code>texte</code> est le fichier que vous souhaitez vÃ©rifier. Ne passez pas Ã  autre chose tant que vous n'Ãªtes pas sÃ»r de comprendre comment fonctionne <code>speller</code> en lui-mÃªmeÂ !</p>
<p>Il y a de fortes chances que vous n'ayez pas passÃ© assez de temps Ã  examiner <code>speller.c</code>. Revenez en arriÃ¨re et relisez-leÂ !</p>
<h4><code>texts/</code></h4>
<p>Afin que vous puissiez tester votre implÃ©mentation de <code>speller</code>, nous vous avons Ã©galement fourni un grand nombre de textes, parmi lesquels le scÃ©nario de <em>La La Land</em>, le texte de l'Affordable Care Act, trois millions d'octets de TolstoÃ¯, des extraits de <em>The Federalist Papers</em> et de Shakespeare, et plus encore. Afin que vous sachiez Ã  quoi vous attendre, ouvrez et parcourez chacun de ces fichiers, qui se trouvent tous dans un rÃ©pertoire appelÃ© <code>texts</code> dans votre rÃ©pertoire <code>pset5</code>.</p>
<p>Maintenant, comme vous devez le savoir aprÃ¨s avoir lu attentivement <code>speller.c</code>, la sortie de <code>speller</code>, si elle est exÃ©cutÃ©e avec, disonsÂ :</p>
<p><code>./spellerÂ texts/lalaland.txt</code></p>
<p>ressemblera Ã©ventuellement Ã  ce qui suit.</p>
<p>Voici quelques exemples de la sortie que vous verrez. Pour information, nous avons extrait quelques exemples de Â«Â fautesÂ Â». Et pour ne pas gÃ¢cher le plaisir, nous avons omis nos propres statistiques pour l'instant.</p>
<p>```
FAUTES D'ORTHOGRAPHEÂ :</p>
<p>[...]
AHHHHHHHHHHHHHHHHHHHHHHHHHHHT
[...]
Shangri
[...]
fianc
[...]
Sebastian's
[...]
```</p>
<p><code>MOTS MAL Ã‰PELÃ‰SÂ :
MOTS DANS LE DICTIONNAIREÂ :
MOTS DANS LE TEXTEÂ :
TEMPS EN chargementÂ :
TEMPS EN vÃ©rificationÂ :
TEMPS EN tailleÂ :
TEMPS EN dÃ©chargementÂ :
TEMPS EN TOTALÂ :</code></p>
<p><code>TEMPS EN chargement</code> reprÃ©sente le nombre de secondes que <code>speller</code> passe Ã  exÃ©cuter votre implÃ©mentation de <code>load</code>. <code>TEMPS EN vÃ©rification</code> reprÃ©sente le nombre de secondes que <code>speller</code> passe, au total, Ã  exÃ©cuter votre implÃ©mentation de <code>check</code>. <code>TEMPS EN taille</code> reprÃ©sente le nombre de secondes que <code>speller</code> passe Ã  exÃ©cuter votre implÃ©mentation de <code>size</code>. <code>TEMPS EN dÃ©chargement</code> reprÃ©sente le nombre de secondes que <code>speller</code> passe Ã  exÃ©cuter votre implÃ©mentation de <code>unload</code>. <code>TEMPS EN TOTAL</code> est la somme de ces quatre mesures.</p>
<p><strong>Notez que ces durÃ©es peuvent varier quelque peu entre les exÃ©cutions de <code>speller</code>, en fonction de ce que fait d'autre votre espace de code, mÃªme si vous ne modifiez pas votre code.</strong></p>
<p>Incidemment, pour Ãªtre clair, par Â«Â mal orthographiÃ©Â Â», nous entendons simplement qu'un mot n'est pas dans le <code>dictionnaire</code> fourni.</p>
<h4><code>Makefile</code></h4>
<p>Enfin, rappelez-vous que <code>make</code> automatise la compilation de votre code afin que vous n'ayez pas Ã  exÃ©cuter <code>clang</code> manuellement avec un tas de commutateurs. Cependant, Ã  mesure que vos programmes grandissent, <code>make</code> ne pourra plus dÃ©duire du contexte comment compiler votre codeÂ ; vous devrez commencer Ã  indiquer Ã  <code>make</code> comment compiler votre programme, en particulier lorsqu'il s'agit de fichiers source multiples (c'est-Ã -dire <code>.c</code>), comme c'est le cas pour ce problÃ¨me. Nous utiliserons donc un <code>Makefile</code>, un fichier de configuration qui indique Ã  <code>make</code> exactement ce qu'il doit faire. Ouvrez <code>Makefile</code> et vous devriez voir quatre lignesÂ :</p>
<ol>
<li>La premiÃ¨re ligne indique Ã  <code>make</code> d'exÃ©cuter les lignes suivantes chaque fois que vous exÃ©cutez vous-mÃªme <code>make speller</code> (ou simplement <code>make</code>).</li>
<li>La deuxiÃ¨me ligne indique Ã  <code>make</code> comment compiler <code>speller.c</code> en code machine (c'est-Ã -dire <code>speller.o</code>).</li>
<li>La troisiÃ¨me ligne indique Ã  <code>make</code> comment compiler <code>dictionary.c</code> en code machine (c'est-Ã -dire <code>dictionary.o</code>).</li>
<li>La quatriÃ¨me ligne indique Ã  <code>make</code> de lier <code>speller.o</code> et <code>dictionary.o</code> dans un fichier appelÃ© <code>speller</code>.</li>
</ol>
<p><strong>Assurez-vous de compiler <code>speller</code> en exÃ©cutant <code>make speller</code> (ou simplement <code>make</code>). L'exÃ©cution de <code>make dictionary</code> ne fonctionnera pasÂ !</strong></p>
<h2>SpÃ©cifications</h2>
<p>Bon, le dÃ©fi qui vous est dÃ©sormais proposÃ© est d'implÃ©menter, dans l'ordre, <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> et <code>unload</code> aussi efficacement que possible en utilisant une table de hachage, de telle sorte que <code>TIME IN load</code>, <code>TIME IN check</code>, <code>TIME IN size</code> et <code>TIME IN unload</code> soient tous minimisÃ©s. Ã€ vrai dire, la notion mÃªme de minimisation n'est pas Ã©vidente, dans la mesure oÃ¹ ces indicateurs varieront sans doute en fonction des valeurs de <code>dictionary</code> et <code>text</code> fournies Ã  <code>speller</code>. Mais c'est lÃ  que rÃ©side le dÃ©fi, voire le plaisir, de ce problÃ¨me. Ce problÃ¨me est votre chance de concevoir. Bien que nous vous invitions Ã  minimiser l'espace, votre pire ennemi reste le temps. Mais avant de vous lancer, voici quelques spÃ©cifications de notre part.</p>
<ul>
<li>Vous n'Ãªtes pas autorisÃ© Ã  modifier <code>speller.c</code> ou <code>Makefile</code>.</li>
<li>Vous Ãªtes autorisÃ© Ã  modifier <code>dictionary.c</code> (et devez d'ailleurs le faire pour complÃ©ter les implÃ©mentations de <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> et <code>unload</code>), mais vous n'Ãªtes pas autorisÃ© Ã  modifier les dÃ©clarations (c'est-Ã -dire les prototypes) de <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> ou <code>unload</code>. Vous pouvez cependant ajouter de nouvelles fonctions et variables (locales ou globales) Ã  <code>dictionary.c</code>.</li>
<li>Vous pouvez modifier la valeur de <code>N</code> dans <code>dictionary.c</code> pour que votre table de hachage puisse avoir plus de compartiments.</li>
<li>Vous pouvez modifier <code>dictionary.h</code>, mais vous n'Ãªtes pas autorisÃ© Ã  modifier les dÃ©clarations de <code>load</code>, <code>hash</code>, <code>size</code>, <code>check</code> ou <code>unload</code>.</li>
<li>Votre implÃ©mentation de <code>check</code> doit Ãªtre insensible Ã  la casse. En d'autres termes, si <code>foo</code> se trouve dans le dictionnaire, alors <code>check</code> doit renvoyer Â« vrai Â» pour n'importe quelle capitalisation de ce terme ; aucun des termes <code>foo</code>, <code>foO</code>, <code>fOo</code>, <code>fOO</code>, <code>fOO</code>, <code>Foo</code>, <code>FoO</code>, <code>FOo</code> et <code>FOO</code> ne doit Ãªtre considÃ©rÃ© comme mal orthographiÃ©.</li>
<li>La capitalisation mise Ã  part, votre implÃ©mentation de <code>check</code> ne doit renvoyer Â« vrai Â» que pour les mots rÃ©ellement prÃ©sents dans <code>dictionary</code>. MÃ©fiez-vous du hard-coding de mots courants (par exemple, Â« the Â»), de peur que nous transmettions Ã  votre implÃ©mentation un <code>dictionary</code> dÃ©pourvu de ces mÃªmes mots. De plus, les seuls possessifs autorisÃ©s sont ceux qui se trouvent rÃ©ellement dans <code>dictionary</code>. En d'autres termes, mÃªme si <code>foo</code> se trouve dans <code>dictionary</code>, <code>check</code> doit renvoyer Â« faux Â» pour <code>foo's</code> si <code>foo's</code> ne se trouve pas Ã©galement dans <code>dictionary</code>.</li>
<li>Vous pouvez supposer que tout <code>dictionary</code> transmis Ã  votre programme sera structurÃ© exactement comme le nÃ´tre, triÃ© alphabÃ©tiquement de haut en bas avec un mot par ligne, chacun se terminant par <code>\n</code>. Vous pouvez Ã©galement supposer que <code>dictionary</code> contiendra au moins un mot, qu'aucun mot ne dÃ©passera <code>LENGTH</code> (une constante dÃ©finie dans <code>dictionary.h</code>) caractÃ¨res, qu'aucun mot n'apparaÃ®tra plus d'une fois, que chaque mot ne contiendra que des caractÃ¨res alphabÃ©tiques minuscules et Ã©ventuellement des apostrophes, et qu'aucun mot ne commencera par une apostrophe.</li>
<li>Vous pouvez supposer que <code>check</code> ne recevra que des mots qui contiennent des caractÃ¨res alphabÃ©tiques (minuscules ou majuscules) et Ã©ventuellement des apostrophes.</li>
<li>Votre correcteur orthographique ne peut prendre que <code>text</code> et, Ã©ventuellement, <code>dictionary</code> comme entrÃ©e. Bien que vous puissiez Ãªtre tentÃ© (en particulier si vous Ãªtes parmi les plus Ã  l'aise) de Â« prÃ©traiter Â» notre dictionnaire par dÃ©faut afin d'en dÃ©duire une Â« fonction de hachage idÃ©ale Â», vous ne pouvez pas enregistrer la sortie d'un tel prÃ©traitement sur le disque afin de la recharger en mÃ©moire lors des exÃ©cutions ultÃ©rieures de votre correcteur orthographique dans le but d'obtenir un avantage.</li>
<li>Votre correcteur orthographique ne doit pas laisser de fuite de mÃ©moire. Assurez-vous de vÃ©rifier l'absence de fuite avec <code>valgrind</code>.</li>
<li><strong>La fonction de hachage que vous Ã©crivez doit Ãªtre en fin de compte la vÃ´tre, et non une fonction que vous recherchez en ligne.</strong></li>
</ul>
<p>PrÃªt Ã  vous lancer ?</p>
<ul>
<li>ImplÃ©mentez <code>load</code>.</li>
<li>ImplÃ©mentez <code>hash</code>.</li>
<li>ImplÃ©mentez <code>size</code>.</li>
<li>ImplÃ©mentez <code>check</code>.</li>
<li>ImplÃ©mentez <code>unload</code>.</li>
</ul>
<h2>Astuces</h2>
<h3>ImplÃ©menter <code>load</code></h3>
<p>ComplÃ©tez la fonction <code>load</code>. <code>load</code> doit charger le dictionnaire en mÃ©moire (en particulier, dans une table de hachage !). <code>load</code> doit renvoyer Â« vrai Â» en cas de succÃ¨s et Â« faux Â» dans le cas contraire.</p>
<p>ConsidÃ©rez que ce problÃ¨me est simplement composÃ© de problÃ¨mes plus petits :</p>
<ol>
<li>Ouvrir le fichier dictionnaire</li>
<li>Lire chaque mot dans le fichier
    1.  Ajouter chaque mot Ã  la table de hachage</li>
<li>Fermer le fichier dictionnaire</li>
</ol>
<p>Ã‰crivez un peu de pseudo-code pour vous rappeler de faire exactement Ã§a :</p>
<pre><code>  bool load(const char *dictionary)
  {
      // Ouvrir le fichier dictionnaire

      // Lire chaque mot dans le fichier

          // Ajouter chaque mot Ã  la table de hachage

      // Fermer le fichier dictionnaire
  }
</code></pre>
<p>RÃ©flÃ©chissez d'abord Ã  la faÃ§on d'ouvrir le fichier dictionnaire. <a href="https://manual.cs50.io/3/fopen"><code>fopen</code></a> est un choix naturel. Vous pouvez utiliser le mode <code>r</code>, Ã©tant donnÃ© que vous n'avez besoin que de <em>lire</em> des mots dans le fichier dictionnaire (pas de les <em>Ã©crire</em> ou de les <em>ajouter</em>).</p>
<pre><code>  bool load(const char *dictionary)
  {
      // Ouvrir le fichier dictionnaire
      FILE *source = fopen(dictionary, "r");

      // Lire chaque mot dans le fichier

          // Ajouter chaque mot Ã  la table de hachage

      // Fermer le fichier dictionnaire
  }
</code></pre>
<p>Avant de poursuivre, vous devez Ã©crire du code pour vÃ©rifier si le fichier s'est ouvert correctement. C'est Ã  vous de dÃ©cider ! Il est Ã©galement prÃ©fÃ©rable de s'assurer de fermer tous les fichiers que vous ouvrez, c'est donc le bon moment pour Ã©crire le code pour fermer le fichier dictionnaire :</p>
<pre><code>  bool load(const char *dictionary)
  {
      // Ouvrir le fichier dictionnaire
      FILE *source = fopen(dictionary, "r");

      // Lire chaque mot dans le fichier

          // Ajouter chaque mot Ã  la table de hachage

      // Fermer le fichier dictionnaire
      fclose(source);
  }
</code></pre>
<p>Il reste Ã  lire chaque mot dans le fichier et Ã  ajouter chaque mot Ã  la table de hachage. Renvoyez Â« vrai Â» lorsque l'opÃ©ration entiÃ¨re est rÃ©ussie et Â« faux Â» si elle Ã©choue un jour. Envisagez de suivre la procÃ©dure pas Ã  pas de ce problÃ¨me et continuez Ã  dÃ©composer les sous-problÃ¨mes en problÃ¨mes encore plus petits. Par exemple, ajouter chaque mot Ã  la table de hachage peut simplement consister Ã  implÃ©menter quelques Ã©tapes encore plus petites :</p>
<ol>
<li>CrÃ©er un espace pour un nouveau nÅ“ud de table de hachage</li>
<li>Copier le mot dans le nouveau nÅ“ud</li>
<li>Hacher le mot pour obtenir sa valeur de hachage</li>
<li>InsÃ©rer le nouveau nÅ“ud dans la table de hachage (en utilisant l'index spÃ©cifiÃ© par sa valeur de hachage)</li>
</ol>
<p>Bien entendu, il existe plusieurs faÃ§ons d'aborder ce problÃ¨me, chacune prÃ©sentant ses propres compromis de conception. Pour cette raison, le reste du code dÃ©pend de vous !</p>
<h3>ImplÃ©menter <code>hash</code></h3>
<p>ComplÃ©tez la fonction <code>hash</code>. <code>hash</code> doit prendre une chaÃ®ne de caractÃ¨res, <code>word</code>, en entrÃ©e et renvoyer un <code>int</code> Â« non signÃ© Â» positif.</p>
<p>La fonction de hachage qui vous est fournie renvoie un <code>int</code> compris entre 0 et 25, inclus, basÃ© sur le premier caractÃ¨re de <code>word</code>. Cependant, il existe de nombreuses faÃ§ons d'implÃ©menter une fonction de hachage au-delÃ  de l'utilisation du premier caractÃ¨re (ou des <em>caractÃ¨res</em>) d'un mot. Envisagez une fonction de hachage qui utilise une somme de valeurs ASCII ou la longueur d'un mot. Une bonne fonction de hachage rÃ©duit les Â« collisions Â» et a une distribution (principalement !) uniforme dans les Â« compartiments Â» de la table de hachage.</p>
<h3>ImplÃ©menter <code>size</code></h3>
<p>ComplÃ©tez la fonction <code>size</code>. <code>size</code> doit retourner le nombre de mots chargÃ©s dans le dictionnaire. Envisagez deux approches pour rÃ©soudre ce problÃ¨me :</p>
<ul>
<li>Comptez chaque mot lorsque vous le chargez dans le dictionnaire. Renvoyez ce dÃ©compte lorsque <code>size</code> est appelÃ©e.</li>
<li>Chaque fois que <code>size</code> est appelÃ©e, parcourez les mots de la table de hachage pour les compter. Renvoyez ce dÃ©compte.</li>
</ul>
<p>Laquelle vous semble la plus efficaceÂ ? Quelle que soit votre prÃ©fÃ©rence, nous vous laissons choisir le code.</p>
<h3>ImplÃ©menter <code>check</code></h3>
<p>ComplÃ©tez la fonction <code>check</code>. <code>check</code> doit renvoyer <code>true</code> si un mot se trouve dans le dictionnaire, et <code>false</code> dans le cas contraire.</p>
<p>ConsidÃ©rez que ce problÃ¨me est Ã©galement composÃ© de problÃ¨mes plus petits. Si vous avez implÃ©mentÃ© une table de hachage, trouver un mot ne nÃ©cessite que quelques Ã©tapesÂ :</p>
<ol>
<li>Hachez le mot pour obtenir sa valeur de hachage</li>
<li>Recherchez le mot dans la table de hachage Ã  lâ€™emplacement spÃ©cifiÃ© par sa valeur de hachage
    1.  Renvoyez <code>true</code> si le mot est trouvÃ©</li>
<li>Renvoyez <code>false</code> si aucun mot nâ€™est trouvÃ©</li>
</ol>
<p>Pour comparer des chaÃ®nes de caractÃ¨res de faÃ§on insensible Ã  la casse, vous trouverez peut-Ãªtre <a href="https://man.cs50.io/3/strcasecmp"><code>strcasecmp</code></a> (dÃ©clarÃ©e dans <code>strings.h</code>) utileÂ ! Vous voudrez probablement aussi vous assurer que votre fonction de hachage est insensible Ã  la casse, de sorte que <code>foo</code> et <code>FOO</code> aient la mÃªme valeur de hachage.</p>
<h3>ImplÃ©menter <code>unload</code></h3>
<p>ComplÃ©tez la fonction <code>unload</code>. Assurez-vous de <code>free</code> dans <code>unload</code> toute mÃ©moire que vous avez allouÃ©e dans <code>load</code>Â !</p>
<p>N'oubliez pas que <code>valgrind</code> est votre nouvel ami. Sachez que <code>valgrind</code> surveille les fuites pendant lâ€™exÃ©cution de votre programme, alors assurez-vous de fournir des arguments de ligne de commande si vous souhaitez que <code>valgrind</code> analyse <code>speller</code> lorsque vous utilisez un <code>dictionnaire</code> et/ou un texte en particulier, comme dans lâ€™exemple ci-dessous. Il est prÃ©fÃ©rable dâ€™utiliser un petit texte, sinon lâ€™exÃ©cution de <code>valgrind</code> pourrait prendre un certain temps.</p>
<pre><code>  valgrind ./speller texts/cat.txt
</code></pre>
<p>Si vous exÃ©cutez <code>valgrind</code> sans spÃ©cifier de <code>texte</code> pour <code>speller</code>, les implÃ©mentations de <code>load</code> et <code>unload</code> ne seront pas appelÃ©es (et donc analysÃ©es).</p>
<p>Si vous nâ€™Ãªtes pas sÃ»r de comment interprÃ©ter la sortie de <code>valgrind</code>, demandez simplement de lâ€™aide Ã  <code>help50</code>Â :</p>
<pre><code>  help50 valgrind ./speller texts/cat.txt
</code></pre>
<h2>ProcÃ©dure pas Ã  pas</h2>
<div class="alert alert-danger" data-alert="danger" role="alert"><p><strong>Notez quâ€™il y a 6Â vidÃ©os dans cette playlist.</strong></p></div>

<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/_z57x5PGF4w?modestbranding=0&amp;rel=0&amp;showinfo=1&amp;list=PLhQjrBD2T382T4b6jjwX_qbU23E_Unwcz"></iframe></div>

<h2>Comment tester</h2>
<p>Comment vÃ©rifier si votre programme affiche les bons mots mal orthographiÃ©sÂ ? Eh bien, vous pouvez consulter lesÂ Â«Â clÃ©s de rÃ©ponseÂ Â» qui se trouvent dans le rÃ©pertoire <code>keys</code> de votre rÃ©pertoire <code>speller</code>. Par exemple, dans <code>keys/lalaland.txt</code> se trouvent tous les mots que votre programme <em>devrait</em> penser mal orthographiÃ©s.</p>
<p>Vous pouvez donc exÃ©cuter votre programme sur un texte dans une fenÃªtre, comme ci-dessous.</p>
<pre><code>  ./speller texts/lalaland.txt
</code></pre>
<p>Et vous pouvez ensuite exÃ©cuter la solution de lâ€™Ã©quipe dans une autre fenÃªtre, comme ci-dessous.</p>
<pre><code>  ./speller50 texts/lalaland.txt
</code></pre>
<p>Et vous pouvez ensuite comparer visuellement les fenÃªtres cÃ´te Ã  cÃ´te. Cela peut cependant vite devenir fastidieux. Vous pouvez donc plutÃ´t Â«Â redirigerÂ Â» la sortie de votre programme vers un fichier, comme ci-dessous.</p>
<pre><code>  ./speller texts/lalaland.txt &gt; student.txt
  ./speller50 texts/lalaland.txt &gt; staff.txt
</code></pre>
<p>Vous pouvez ensuite comparer les deux fichiers cÃ´te Ã  cÃ´te dans la mÃªme fenÃªtre avec un programme comme <code>diff</code>, comme ci-dessous.</p>
<pre><code>  diff -y student.txt staff.txt
</code></pre>
<p>Vous pouvez Ã©galement, pour gagner du temps, comparer la sortie de votre programme (en supposant que vous lâ€™ayez redirigÃ©e vers, par exemple, <code>student.txt</code>) avec lâ€™une des clÃ©s de rÃ©ponseÂ sans exÃ©cuter la solution de lâ€™Ã©quipe, comme ci-dessous.</p>
<pre><code>  diff -y student.txt keys/lalaland.txt
</code></pre>
<p>Si la sortie de votre programme correspond Ã  celle de lâ€™Ã©quipe, <code>diff</code> affichera deux colonnes qui devraient Ãªtre identiques, Ã  lâ€™exception peut-Ãªtre des temps dâ€™exÃ©cution en bas. Si les colonnes diffÃ¨rent, vous verrez un <code>&gt;</code> ou <code>|</code> Ã  lâ€™endroit de la diffÃ©rence. Par exemple, si vous voyez</p>
<pre><code>  MISSPELLED WORDS                                                MISSPELLED WORDS

  TECHNO                                                          TECHNO
  L                                                               L
                                                                &gt; Thelonious
  Prius                                                           Prius
                                                                &gt; MIA
  L                                                               L
</code></pre>
<p>cela signifie que votre programme (dont la sortie est Ã  gauche) ne pense pas que <code>Thelonious</code> ou <code>MIA</code> est mal orthographiÃ©, alors que la sortie de lâ€™Ã©quipe (Ã  droite) le pense, comme en tÃ©moigne lâ€™absence de <code>Thelonious</code> dans la colonne de gauche et la prÃ©sence de <code>Thelonious</code> dans la colonne de droite.</p>
<p>Enfin, assurez-vous de tester avec les grands et les petits dictionnaires par dÃ©faut. Faites attention Ã  ne pas supposer que si votre solution fonctionne avec le grand dictionnaire, elle fonctionnera aussi avec le petit. Voici comment essayer le petit dictionnaireÂ :</p>
<pre><code>  ./speller dictionaries/small texts/cat.txt
</code></pre>
<h3>Exactitude</h3>
<pre><code>  check50 cs50/problems/2024/x/speller
</code></pre>
<h3>Style</h3>
<pre><code>  style50 dictionary.c
</code></pre>
<h2>Solution de lâ€™Ã©quipe</h2>
<p>Comment Ã©valuer Ã  quel point votre code est rapide (et correct)Â ? Eh bien, comme toujours, nâ€™hÃ©sitez pas Ã  utiliser la solution de lâ€™Ã©quipe, comme ci-dessous, et comparez ses chiffres aux vÃ´tres.</p>
<pre><code>  ./speller50 texts/lalaland.txt
</code></pre>
<h2>Comment soumettre</h2>
<pre><code>  submit50 cs50/problems/2024/x/speller
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>