<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Fran√ßais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en Fran√ßais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        M√©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de Donn√©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        Cybers√©curit√©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">Honn√™tet√© Acad√©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions Fr√©quemment Pos√©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">√âquipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>H√©ritage</h1>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/xfZhb6lmxjk?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<h2>Probl√®me √† r√©soudre</h2>
<p>Le groupe sanguin d'une personne est d√©termin√© par deux all√®les (c'est-√†-dire diff√©rentes formes d'un g√®ne). Les trois all√®les possibles sont A, B et O, dont chaque personne poss√®de deux (√©ventuellement le m√™me, √©ventuellement diff√©rent). Chaque parent d'un enfant transmet al√©atoirement l'un de ses deux all√®les de groupe sanguin √† son enfant. Les combinaisons possibles de groupes sanguins sont donc : OO, OA, OB, AO, AA, AB, BO, BA et BB.</p>
<p>Par exemple, si un parent a le groupe sanguin AO et l'autre parent a le groupe sanguin BB, alors les groupes sanguins possibles de l'enfant seraient AB et OB, selon l'all√®le re√ßu de chaque parent. De m√™me, si un parent a le groupe sanguin AO et l'autre OB, alors les groupes sanguins possibles de l'enfant seraient AO, OB, AB et OO.</p>
<p>Dans un fichier appel√© <code>inheritance.c</code> dans un dossier appel√© <code>inheritance</code>, simulez l'h√©ritage des groupes sanguins pour chaque membre d'une famille.</p>
<h2>D√©mo</h2>
<script async="" data-autoplay="1" data-cols="100" data-loop="1" data-rows="12" id="asciicast-J9DnbdokgIAjWUbzC2CBqP22N" src="https://asciinema.org/a/J9DnbdokgIAjWUbzC2CBqP22N.js"></script>

<h2>Code de distribution</h2>
<p>Pour ce probl√®me, vous √©tendez les fonctionnalit√©s du code fourni par le personnel de CS50.</p>
<p>Connectez-vous sur <a href="https://cs50.dev/">cs50.dev</a>, cliquez sur votre fen√™tre de terminal et ex√©cutez <code>cd</code> tout seul. Vous devriez constater que l'invite de votre fen√™tre de terminal ressemble √† celle-ci :</p>
<pre><code>  $
</code></pre>
<p>Ex√©cutez ensuite</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/5/inheritance.zip
</code></pre>
<p>afin de t√©l√©charger un ZIP appel√© <code>inheritance.zip</code> dans votre espace de codes.</p>
<p>Ensuite, ex√©cutez</p>
<pre><code>  unzip inheritance.zip
</code></pre>
<p>pour cr√©er un dossier appel√© <code>inheritance</code>. Vous n'avez plus besoin du fichier ZIP, vous pouvez donc ex√©cuter</p>
<pre><code>  rm inheritance.zip
</code></pre>
<p>et r√©pondez par ¬´ y ¬ª suivi de Entr√©e √† l'invite pour supprimer le fichier ZIP que vous avez t√©l√©charg√©.</p>
<p>Tapez maintenant</p>
<pre><code>  cd inheritance
</code></pre>
<p>suivi de Entr√©e pour vous d√©placer dans (c'est-√†-dire ouvrir) ce r√©pertoire. Votre invite devrait maintenant ressembler √† celle-ci.</p>
<pre><code>  inheritance/ $
</code></pre>
<p>Ex√©cutez <code>ls</code> tout seul, et vous devriez voir et voir un fichier nomm√© <code>inheritance.c</code>.</p>
<p>Si vous rencontrez des probl√®mes, suivez √† nouveau ces m√™mes √©tapes et essayez de d√©terminer o√π vous vous √™tes tromp√© !</p>
<h2>D√©tails de mise en ≈ìuvre</h2>
<p>Terminez l'impl√©mentation de <code>inheritance.c</code>, de sorte qu'il cr√©e une famille d'une taille de g√©n√©ration sp√©cifi√©e et attribue des all√®les de groupe sanguin √† chaque membre de la famille. L'all√®le le plus ancien se voit attribuer des all√®les de mani√®re al√©atoire.</p>
<ul>
<li>La fonction <code>create_family</code> prend un entier (<code>generations</code>) en entr√©e et doit allouer (comme via <code>malloc</code>) une <code>person</code> pour chaque membre de la famille de ce nombre de g√©n√©rations, renvoyant un pointeur vers la <code>person</code> dans la plus jeune g√©n√©ration.<ul>
<li>Par exemple, <code>create_family(3)</code> doit renvoyer un pointeur vers une personne ayant deux parents, chaque parent ayant √©galement deux parents.</li>
<li>Chaque <code>person</code> doit se voir attribuer des <code>all√®les</code>. La g√©n√©ration la plus ancienne doit avoir des all√®les choisis au hasard (comme en appelant la fonction <code>random_allele</code>), et les g√©n√©rations plus jeunes doivent h√©riter d'un all√®le (choisi au hasard) de chaque parent.</li>
<li>Chaque <code>person</code> doit se voir attribuer des <code>parents</code>. La g√©n√©ration la plus ancienne doit avoir les deux <code>parents</code> d√©finis sur <code>NULL</code>, et les g√©n√©rations plus jeunes doivent avoir des <code>parents</code> comme tableau de deux pointeurs, chacun pointant vers une structure <code>person</code> diff√©rente.</li>
</ul>
</li>
</ul>
<h2>Conseils</h2>
<h3>Comprendre le code dans <code>inheritance.c</code></h3>
<p>Jetez un ≈ìil au code de distribution dans <code>inheritance.c</code>.</p>
<p>Remarquez la d√©finition d'un type appel√© <code>person</code>. Chaque personne poss√®de un tableau de deux <code>parents</code>, chacun √©tant un pointeur vers une autre structure <code>person</code>. Chaque personne poss√®de √©galement un tableau de deux <code>all√®les</code>, chacun √©tant un <code>char</code> (soit <code>'A'</code>, <code>'B'</code>, soit <code>'O'</code>).</p>
<pre><code>  // Chaque personne a deux parents et deux all√®les
  typedef struct person
  {
      struct person *parents[2];
      char alleles[2];
  }
  person;
</code></pre>
<p>Maintenant, jetez un ≈ìil √† la fonction <code>main</code>. La fonction commence par ¬´ amorcer ¬ª (c'est-√†-dire fournir une entr√©e initiale √†) un g√©n√©rateur de nombres al√©atoires, que nous utiliserons plus tard pour g√©n√©rer des all√®les al√©atoires.</p>
<pre><code>  // Initialiser le g√©n√©rateur de nombres al√©atoires
  srand(time(0));
</code></pre>
<p>La fonction <code>main</code> appelle ensuite la fonction <code>create_family</code> pour simuler la cr√©ation de structures <code>person</code> pour une famille de 3 g√©n√©rations (c'est-√†-dire une personne, ses parents et ses grands-parents).</p>
<pre><code>  // Cr√©er une nouvelle famille avec trois g√©n√©rations
  person *p = create_family(GENERATIONS);
</code></pre>
<p>Nous appelons ensuite <code>print_family</code> pour imprimer chacun de ces membres de la famille et leurs groupes sanguins.</p>
<pre><code>  // Imprimer l'arbre g√©n√©alogique des groupes sanguins
  print_family(p, 0);
</code></pre>
<p>Enfin, la fonction appelle <code>free_family</code> pour <code>lib√©rer</code> toute m√©moire pr√©c√©demment allou√©e avec <code>malloc</code>.</p>
<pre><code>  // Lib√©rer la m√©moire
  free_family(p);
</code></pre>
<p>Les fonctions <code>create_family</code> et <code>free_family</code> sont √† vous d'√©crire!</p>
<h3>Compl√©ter la fonction <code>create_family</code></h3>
<p>La fonction <code>create_family</code> doit renvoyer un pointeur vers une <code>personne</code> qui a h√©rit√© son groupe sanguin du nombre de <code>g√©n√©rations</code> donn√© en entr√©e.</p>
<ul>
<li>Notez d'abord que ce probl√®me offre une bonne opportunit√© de r√©cursivit√©.<ul>
<li>Pour d√©terminer le groupe sanguin de la personne actuelle, vous devez d'abord d√©terminer les groupes sanguins de ses parents.</li>
<li>Pour d√©terminer les groupes sanguins de ces parents, vous devez d'abord d√©terminer les groupes sanguins de leurs parents. Et ainsi de suite jusqu'√† ce que vous atteigniez la derni√®re g√©n√©ration que vous souhaitez simuler.</li>
</ul>
</li>
</ul>
<p>Pour r√©soudre ce probl√®me, vous trouverez plusieurs TODO dans le code de distribution.</p>
<p>Tout d'abord, vous devez allouer de la m√©moire pour une nouvelle personne. Rappelez-vous que vous pouvez utiliser <code>malloc</code> pour allouer de la m√©moire et <code>sizeof(person)</code> pour obtenir le nombre d'octets √† allouer.</p>
<pre><code>  // Allouer de la m√©moire pour une nouvelle personne
  person *new_person = malloc(sizeof(person));
</code></pre>
<p>Ensuite, vous devez v√©rifier s'il reste des g√©n√©rations √† cr√©er, c'est-√†-dire si <code>g√©n√©rations &gt; 1</code>.</p>
<p>Si <code>g√©n√©rations &gt; 1</code>, alors il y a encore des g√©n√©rations qui doivent √™tre allou√©es. Nous avons d√©j√† cr√©√© deux nouveaux parents, <code>parent0</code> et <code>parent1</code>, en appelant r√©cursivement <code>create_family</code>. Votre fonction <code>create_family</code> doit ensuite d√©finir les pointeurs parents de la nouvelle personne que vous avez cr√©√©e. Enfin, attribuez les deux <code>all√®les</code> √† la nouvelle personne en choisissant al√©atoirement un all√®le de chaque parent.</p>
<ul>
<li>N'oubliez pas que pour acc√©der √† une variable via un pointeur, vous pouvez utiliser la notation fl√©ch√©e. Par exemple, si <code>p</code> est un pointeur vers une personne, alors un pointeur vers le premier parent de cette personne peut √™tre acc√©d√© par <code>p-&gt;parents[0]</code>.</li>
<li>
<p>Vous pouvez trouver la fonction <code>rand()</code> utile pour attribuer al√©atoirement des all√®les. Cette fonction renvoie un entier compris entre <code>0</code> et <code>RAND_MAX</code>, ou <code>32767</code>. En particulier, pour g√©n√©rer un nombre pseudo-al√©atoire qui vaut soit <code>0</code> soit <code>1</code>, vous pouvez utiliser l'expression <code>rand() % 2</code>.</p>
<p>// Cr√©er deux nouveaux parents pour la personne actuelle en appelant r√©cursivement create_family
person <em>parent0 = create_family(g√©n√©rations - 1);
person </em>parent1 = create_family(g√©n√©rations - 1);</p>
<p>// D√©finir des pointeurs parents pour la personne actuelle
new_person-&gt;parents[0] = parent0;
new_person-&gt;parents[1] = parent1;</p>
<p>// Attribuer al√©atoirement les all√®les de la personne actuelle en fonction des all√®les de ses parents
new_person-&gt;all√®les[0] = parent0-&gt;all√®les[rand() % 2];
new_person-&gt;all√®les[1] = parent1-&gt;all√®les[rand() % 2];</p>
</li>
</ul>
<p>Supposons qu'il n'y ait plus de g√©n√©rations √† simuler. C'est-√†-dire que <code>g√©n√©rations == 1</code>. Si c'est le cas, il n'y aura pas de donn√©es parents pour cette personne. Les deux parents de votre nouvelle personne doivent √™tre d√©finis sur <code>NULL</code> et chaque <code>all√®le</code> doit √™tre g√©n√©r√© al√©atoirement.</p>
<pre><code>  // D√©finir des pointeurs parents sur NULL
  new_person-&gt;parents[0] = NULL;
  new_person-&gt;parents[1] = NULL;

  // Attribuer al√©atoirement des all√®les
  new_person-&gt;all√®les[0] = random_allele();
  new_person-&gt;all√®les[1] = random_allele();
</code></pre>
<p>Enfin, votre fonction doit renvoyer un pointeur vers la <code>personne</code> qui a √©t√© allou√©e.</p>
<pre><code>  // Retourner une personne nouvellement cr√©√©e
  return new_person;
</code></pre>
<h3>Compl√©ter la fonction <code>free_family</code></h3>
<p>La fonction <code>free_family</code> doit accepter en entr√©e un pointeur vers une <code>personne</code>, lib√©rer de la m√©moire pour cette personne, puis lib√©rer r√©cursivement de la m√©moire pour tous ses anc√™tres.</p>
<ul>
<li>Puisqu'il s'agit d'une fonction r√©cursive, vous devez d'abord g√©rer le cas de base. Si l'entr√©e de la fonction est <code>NULL</code>, alors il n'y a rien √† lib√©rer, votre fonction peut donc renvoyer imm√©diatement.</li>
<li>Sinon, vous devez <code>free</code> r√©cursivement les deux parents de la personne avant de <code>free</code> l'enfant.</li>
</ul>
<p>Ce qui suit est un indice, mais voici comment faire !</p>
<pre><code>  // Lib√©rer `p` et tous les anc√™tres de `p`.
  void free_family(person *p)
  {
      // G√©rer le cas de base
      if (p == NULL)
      {
          return;
      }

      // Lib√©rer les parents r√©cursivement
      free_family(p-&gt;parents[0]);
      free_family(p-&gt;parents[1]);

      // Lib√©rer l'enfant
      free(p);
  }
</code></pre>
<h3>Proc√©dure pas √† pas</h3>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/9p7ddI3ozTY?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<details><summary>Vous ne savez pas comment r√©soudre ?</summary><div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/H7LULatPwcQ?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div></details>

<h2>Comment tester</h2>
<p>Lors de l'ex√©cution de <code>./inheritance</code>, votre programme doit respecter les r√®gles d√©crites dans le contexte. L'enfant doit avoir deux all√®les, un de chaque parent. Les parents doivent chacun avoir deux all√®les, un de chacun de leurs parents.</p>
<p>Par exemple, dans l'exemple ci-dessous, l'enfant de g√©n√©ration 0 a re√ßu un all√®le O des deux parents de g√©n√©ration 1. Le premier parent a re√ßu un A du premier grand-parent et un O du deuxi√®me grand-parent. De m√™me, le deuxi√®me parent a re√ßu un O et un B de ses grands-parents.</p>
<pre><code>  $ ./inheritance
  Enfant (g√©n√©ration 0)¬†: groupe sanguin OO
      Parent (g√©n√©ration 1)¬†: groupe sanguin AO
          Grand-parent (g√©n√©ration 2)¬†: groupe sanguin OA
          Grand-parent (g√©n√©ration 2)¬†: groupe sanguin BO
      Parent (g√©n√©ration 1)¬†: groupe sanguin OB
          Grand-parent (g√©n√©ration 2)¬†: groupe sanguin AO
          Grand-parent (g√©n√©ration 2)¬†: groupe sanguin BO
</code></pre>
<h3>Justesse</h3>
<pre><code>  check50 cs50/problems/2024/x/inheritance
</code></pre>
<h3>Style</h3>
<pre><code>  style50 inheritance.c
</code></pre>
<h2>Comment soumettre</h2>
<pre><code>  submit50 cs50/problems/2024/x/inheritance
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>