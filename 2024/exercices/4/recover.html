<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en FranÃ§ais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en FranÃ§ais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch ğŸ˜º
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        MÃ©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de DonnÃ©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        CybersÃ©curitÃ©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">HonnÃªtetÃ© AcadÃ©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions FrÃ©quemment PosÃ©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Ã‰quipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>RÃ©cupÃ©rer</h1>
<p><img alt="Image rÃ©cupÃ©rÃ©e" src="https://cs50.harvard.edu/x/2024/psets/4/recover/recovered_image.png" /></p>
<h2>ProblÃ¨me Ã  rÃ©soudre</h2>
<p>En prÃ©vision de ce problÃ¨me, nous avons passÃ© ces derniers jours Ã  prendre des photos sur le campus, qui ont toutes Ã©tÃ© sauvegardÃ©es sur un appareil photo numÃ©rique au format JPEG sur une carte mÃ©moire. Malheureusement, nous les avons toutes supprimÃ©es par erreur ! Heureusement, dans le monde de l'informatique, Â« supprimÃ© Â» tend Ã  ne pas vraiment signifier Â« supprimÃ© Â», mais plutÃ´t Â« oubliÃ© Â». MÃªme si l'appareil photo insiste sur le fait que la carte est maintenant vide, nous sommes presque sÃ»rs que ce n'est pas tout Ã  fait vrai. En effet, nous espÃ©rons (ou plutÃ´t, nous attendons !) que vous puissiez Ã©crire un programme qui rÃ©cupÃ¨re les photos pour nous !</p>
<p>Dans un fichier appelÃ© <code>recover.c</code> dans un dossier appelÃ© <code>recover</code>, Ã©crivez un programme pour rÃ©cupÃ©rer les JPEG d'une carte mÃ©moire.</p>
<h2>Code de distribution</h2>
<p>Pour ce problÃ¨me, vous Ã©tendrez la fonctionnalitÃ© du code qui vous a Ã©tÃ© fourni par le personnel de CS50.</p>
<p>Connectez-vous Ã  <a href="https://cs50.dev/">cs50.dev</a>, cliquez sur votre fenÃªtre de terminal et exÃ©cutez <code>cd</code> par lui-mÃªme. Vous devriez constater que l'invite de votre fenÃªtre de terminal ressemble Ã  ceci :</p>
<pre><code>  $
</code></pre>
<p>ExÃ©cutez ensuite</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/4/recover.zip
</code></pre>
<p>afin de tÃ©lÃ©charger un fichier ZIP appelÃ© <code>recover.zip</code> dans votre espace de codes.</p>
<p>Puis exÃ©cutez</p>
<pre><code>  unzip recover.zip
</code></pre>
<p>pour crÃ©er un dossier appelÃ© <code>recover</code>. Vous n'avez plus besoin du fichier ZIP, vous pouvez donc exÃ©cuter</p>
<pre><code>  rm recover.zip
</code></pre>
<p>et rÃ©pondre par Â« y Â» suivi de EntrÃ©e Ã  l'invite pour supprimer le fichier ZIP que vous avez tÃ©lÃ©chargÃ©.</p>
<p>Tapez maintenant</p>
<pre><code>  cd recover
</code></pre>
<p>suivi de EntrÃ©e pour vous dÃ©placer dans (c'est-Ã -dire ouvrir) ce rÃ©pertoire. Votre invite devrait maintenant ressembler Ã  ceci :</p>
<pre><code>  recover/ $
</code></pre>
<p>ExÃ©cutez <code>ls</code> par lui-mÃªme, et vous devriez voir deux fichiers : <code>recover.c</code> et <code>card.raw</code>.</p>
<h2>Contexte</h2>
<p>MÃªme si les JPEG sont plus complexes que les BMP, ils ont des Â« signatures Â», des motifs d'octets qui peuvent les distinguer des autres formats de fichiers. Plus prÃ©cisÃ©ment, les trois premiers octets des JPEG sont</p>
<pre><code>  0xff 0xd8 0xff
</code></pre>
<p>du premier octet au troisiÃ¨me octet, de gauche Ã  droite. Le quatriÃ¨me octet, quant Ã  lui, est soit <code>0xe0</code>, <code>0xe1</code>, <code>0xe2</code>, <code>0xe3</code>, <code>0xe4</code>, <code>0xe5</code>, <code>0xe6</code>, <code>0xe7</code>, <code>0xe8</code>, <code>0xe9</code>, <code>0xea</code>, <code>0xeb</code>, <code>0xec</code>, <code>0xed</code>, <code>0xee</code>, ou <code>0xef</code>. En d'autres termes, les quatre premiers bits du quatriÃ¨me octet sont <code>1110</code>.</p>
<p>Il est probable que si vous trouvez ce motif de quatre octets sur un support connu pour stocker des photos (par exemple, ma carte mÃ©moire), ils dÃ©limitent le dÃ©but d'un JPEG. Pour Ãªtre juste, vous pouvez rencontrer ces motifs sur certains disques purement par hasard, donc la rÃ©cupÃ©ration de donnÃ©es n'est pas une science exacte.</p>
<p>Heureusement, les appareils photo numÃ©riques ont tendance Ã  stocker les photos de maniÃ¨re contiguÃ« sur les cartes mÃ©moire, de sorte que chaque photo est stockÃ©e immÃ©diatement aprÃ¨s la photo prise prÃ©cÃ©demment. En consÃ©quence, le dÃ©but d'un JPEG dÃ©limite gÃ©nÃ©ralement la fin d'un autre. Cependant, les appareils photo numÃ©riques initialisent souvent les cartes avec un systÃ¨me de fichiers FAT dont la Â« taille de bloc Â» est de 512 octets (B). Cela implique que ces appareils photo n'Ã©crivent sur ces cartes qu'en unitÃ©s de 512 B. Une photo de 1 Mo (c'est-Ã -dire 1 048 576 B) occupe donc 1 048 576 Ã· 512 = 2Â 048 Â« blocs Â» sur une carte mÃ©moire. Mais il en est de mÃªme pour une photo qui est, disons, un octet plus petite (c'est-Ã -dire 1 048 575 B) ! L'espace gaspillÃ© sur le disque est appelÃ© Â« espace libre Â». Les enquÃªteurs en criminalistique examinent souvent l'espace libre pour y trouver des restes de donnÃ©es suspectes.</p>
<p>Ces dÃ©tails impliquent que vous, l'enquÃªteur, pouvez probablement Ã©crire un programme qui parcourt une copie de ma carte mÃ©moire, Ã  la recherche des signatures des JPEG. Chaque fois que vous trouvez une signature, vous pouvez ouvrir un nouveau fichier en Ã©criture et commencer Ã  le remplir avec des octets provenant de ma carte mÃ©moire, en ne fermant ce fichier qu'une fois que vous avez rencontrÃ© une autre signature. De plus, plutÃ´t que de lire les octets de ma carte mÃ©moire un par un, vous pouvez en lire 512 Ã  la fois dans une mÃ©moire tampon, pour des raisons d'efficacitÃ©. GrÃ¢ce Ã  FAT, vous pouvez avoir confiance que les signatures des JPEG seront Â« alignÃ©es sur les blocs Â». Autrement dit, vous n'avez besoin de rechercher ces signatures que dans les quatre premiers octets d'un bloc.</p>
<p>Bien sÃ»r, il faut se rendre compte que les JPEG peuvent s'Ã©tendre sur des blocs contigus. Sinon, aucun JPEG ne pourrait Ãªtre plus grand que 512 B. Mais le dernier octet d'un JPEG peut ne pas tomber Ã  la toute fin d'un bloc. Rappelez-vous la possibilitÃ© d'espace libre. Mais ne vous inquiÃ©tez pas. Comme cette carte mÃ©moire Ã©tait toute neuve lorsque j'ai commencÃ© Ã  prendre des photos, il y a de fortes chances qu'elle ait Ã©tÃ© Â« remise Ã  zÃ©ro Â» (c'est-Ã -dire remplie de 0) par le fabricant, dans ce cas, tout espace libre sera rempli de 0. Ce n'est pas grave si ces 0 de fin se retrouvent dans les JPEG que vous rÃ©cupÃ©rez ; ils devraient toujours Ãªtre visibles.</p>
<p>Maintenant, je n'ai qu'une seule carte mÃ©moire, mais vous Ãªtes nombreux ! C'est pourquoi je suis allÃ© de l'avant et j'ai crÃ©Ã© une Â« image lÃ©gale Â» de la carte, en stockant son contenu, octet par octet, dans un fichier appelÃ© <code>card.raw</code>. Pour que vous ne perdiez pas de temps Ã  parcourir des millions de 0 inutilement, je n'ai imagÃ© que les premiers mÃ©gaoctets de la carte mÃ©moire. Mais vous devriez finalement constater que l'image contient 50 JPEG.</p>
<h2>SpÃ©cification</h2>
<p>ImplÃ©mentez un programme appelÃ© <code>recover</code> qui rÃ©cupÃ¨re les JPEG Ã  partir d'une image lÃ©gale.</p>
<ul>
<li>ImplÃ©mentez votre programme dans un fichier appelÃ© <code>recover.c</code> dans un rÃ©pertoire appelÃ© <code>recover</code>.</li>
<li>Votre programme doit accepter exactement un argument de ligne de commande, le nom d'une image lÃ©gale Ã  partir de laquelle rÃ©cupÃ©rer les JPEG.</li>
<li>Si votre programme n'est pas exÃ©cutÃ© avec exactement un argument de ligne de commande, il doit rappeler Ã  l'utilisateur l'utilisation correcte, et <code>main</code> doit renvoyer <code>1</code>.</li>
<li>Si l'image lÃ©gale ne peut pas Ãªtre ouverte en lecture, votre programme doit en informer l'utilisateur et <code>main</code> doit renvoyer <code>1</code>.</li>
<li>Les fichiers que vous gÃ©nÃ©rez doivent chacun Ãªtre nommÃ©s <code>###.jpg</code>, oÃ¹ <code>###</code> est un nombre dÃ©cimal Ã  trois chiffres, commenÃ§ant par <code>000</code> pour la premiÃ¨re image et en augmentant ainsi.</li>
<li>Votre programme, s'il utilise <code>malloc</code>, ne doit pas fuir de mÃ©moire.</li>
</ul>
<h2>Astuces</h2>
<h3>Ã‰crivez un peu de pseudo-code avant d'Ã©crire plus de code</h3>
<p>Si vous ne savez pas comment rÃ©soudre le problÃ¨me gÃ©nÃ©ral, dÃ©composez-le en problÃ¨mes plus petits que vous pouvez probablement rÃ©soudre en premier. Par exemple, ce problÃ¨me n'est en rÃ©alitÃ© qu'une poignÃ©e de problÃ¨mes :</p>
<ol>
<li>Accepter un seul argument de ligne de commandeÂ : le nom d'une carte mÃ©moire</li>
<li>Ouvrir la carte mÃ©moire</li>
<li>Tant qu'il reste des donnÃ©es Ã  lire sur la carte mÃ©moire<pre><code>1. CrÃ©er des JPEG Ã  partir des donnÃ©es
</code></pre>
</li>
</ol>
<p>Ã‰crivons un peu de pseudo-code comme commentaires pour vous rappeler de faire exactement celaÂ :</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(int argc, char *argv[])
  {
      // Accepter un seul argument de ligne de commande

      // Ouvrir la carte mÃ©moire

      // Tant qu'il reste des donnÃ©es Ã  lire sur la carte mÃ©moire

          // CrÃ©er des JPEG Ã  partir des donnÃ©es
  }
</code></pre>
<h3>Convertir le pseudo-code en code</h3>
<p>Tout dâ€™abord, rÃ©flÃ©chissez Ã  la maniÃ¨re dâ€™accepter un seul argument de ligne de commande. Si lâ€™utilisateur utilise le programme de faÃ§on incorrecte, vous devez lui indiquer la bonne faÃ§on de lâ€™utiliser.</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(int argc, char *argv[])
  {
      // Accepter un seul argument de ligne de commande
      if (argc != 2)
      {
          printf("Usage: ./recover FILE\n");
          return 1;
      }

      // Ouvrir la carte mÃ©moire

      // Tant quâ€™il y a des donnÃ©es Ã  lire sur la carte mÃ©moire

          // CrÃ©er des fichiers JPEG Ã  partir des donnÃ©es
  }
</code></pre>
<p>Maintenant que vous avez vÃ©rifiÃ© que lâ€™utilisation est correcte, vous pouvez ouvrir la carte mÃ©moire. Nâ€™oubliez pas que vous pouvez ouvrir <code>card.raw</code> par programmation avec <code>fopen</code>, comme ci-dessous.</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(int argc, char *argv[])
  {
      // Accepter un seul argument de ligne de commande
      if (argc != 2)
      {
          printf("Usage: ./recover FILE\n");
          return 1;
      }

      // Ouvrir la carte mÃ©moire
      FILE *card = fopen(argv[1], "r");

      // Tant quâ€™il y a des donnÃ©es Ã  lire sur la carte mÃ©moire

          // CrÃ©er des fichiers JPEG Ã  partir des donnÃ©es
  }
</code></pre>
<p>Vous devez bien sÃ»r vÃ©rifier que le fichier a Ã©tÃ© ouvert correctement ! Si ce nâ€™est pas le cas, informez-en lâ€™utilisateur et quittez le programme : nous vous laissons cette partie.</p>
<p>Ensuite, votre programme doit lire les donnÃ©es de la carte que vous avez ouverte, jusquâ€™Ã  ce quâ€™il nâ€™y ait plus de donnÃ©es Ã  lire. En cours de route, votre programme doit rÃ©cupÃ©rer chacun des fichiers JPEG de <code>card.raw</code>, en stockant chacun dâ€™eux sous forme de fichier distinct dans votre rÃ©pertoire de travail actuel.</p>
<p>RÃ©flÃ©chissez dâ€™abord Ã  la maniÃ¨re de lire <code>card.raw</code> en profondeur. Rappelez-vous que, pour lire des donnÃ©es Ã  partir dâ€™un fichier, vous devez stocker temporairement ces donnÃ©es dans un Â« tampon Â». Et rappelez-vous Ã©galement que <code>card.raw</code> stocke les donnÃ©es dans des blocs de 512 octets. Par consÃ©quent, vous voudrez probablement crÃ©er un tampon de 512 octets pour stocker des blocs de donnÃ©es au fur et Ã  mesure que vous les lisez de maniÃ¨re sÃ©quentielle. Une faÃ§on de procÃ©der est dâ€™utiliser le type <code>uint8_t</code> de <code>stdint.h</code>, qui stocke exactement 8 bits (1 octet). Le type est appelÃ© <code>uint8_t</code> puisquâ€™il stocke un entier non signÃ©/positif/non nÃ©gatif qui nÃ©cessite 8 bits dâ€™espace (câ€™est-Ã -dire un octet).</p>
<pre><code>  #include &lt;stdint.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(int argc, char *argv[])
  {
      // Accepter un seul argument de ligne de commande
      if (argc != 2)
      {
          printf("Usage: ./recover FILE\n");
          return 1;
      }

      // Ouvrir la carte mÃ©moire
      FILE *card = fopen(argv[1], "r");

      // CrÃ©er un tampon pour un bloc de donnÃ©es
      uint8_t buffer[512];

      // Tant quâ€™il y a des donnÃ©es Ã  lire sur la carte mÃ©moire

          // CrÃ©er des fichiers JPEG Ã  partir des donnÃ©es
  }
</code></pre>
<p>Cependant, ce nâ€™est probablement pas la meilleure idÃ©e dâ€™utiliser 512 comme un <a href="../../../shorts/magic_numbers/">Â« nombre magique Â»</a> ici. Il y a des chances que vous puissiez encore amÃ©liorer cette conception !</p>
<p>Maintenant, rÃ©flÃ©chissez Ã  la maniÃ¨re de lire les donnÃ©es de la carte mÃ©moire. Selon sa <a href="https://man.cs50.io/3/fread">page de manuel</a>, <code>fread</code> renvoie le nombre dâ€™octets quâ€™il a lus, auquel cas il devrait renvoyer soit <code>512</code> soit <code>0</code>, Ã©tant donnÃ© que <code>card.raw</code> contient un certain nombre de blocs de 512 octets. Afin de lire chaque bloc de <code>card.raw</code>, aprÃ¨s lâ€™avoir ouvert avec <code>fopen</code>, il devrait suffire dâ€™utiliser une boucle comme celle-ci.</p>
<pre><code>  #include &lt;stdint.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(int argc, char *argv[])
  {
      // Accepter un seul argument de ligne de commande
      if (argc != 2)
      {
          printf("Usage: ./recover FILE\n");
          return 1;
      }

      // Ouvrir la carte mÃ©moire
      FILE *card = fopen(argv[1], "r");

      // CrÃ©er un tampon pour un bloc de donnÃ©es
      uint8_t buffer[512];

      // Tant quâ€™il y a des donnÃ©es Ã  lire sur la carte mÃ©moire
      while (fread(buffer, 1, 512, card) == 512)
      {
          // CrÃ©er des fichiers JPEG Ã  partir des donnÃ©es

      }
  }
</code></pre>
<p>De cette faÃ§on, dÃ¨s que <code>fread</code> renvoie <code>0</code> (qui est en fait <code>false</code>), votre boucle se termine.</p>
<p>Enfin, câ€™est Ã  vous de dÃ©terminer comment crÃ©er par programmation des fichiers JPEG au fur et Ã  mesure que vous continuez Ã  lire <code>card.raw</code>. Pour cela, vous trouverez peut-Ãªtre utile la <a href="#procÃ©dure pas Ã  pas">procÃ©dure pas Ã  pas</a> ci-dessous.</p>
<p>Nâ€™oubliez pas que votre programme doit numÃ©roter les fichiers quâ€™il gÃ©nÃ¨re en les nommant chacun <code>###.jpg</code>, oÃ¹ <code>###</code> est un nombre dÃ©cimal Ã  trois chiffres Ã  partir de <code>000</code>. Liez-vous dâ€™amitiÃ© avec <a href="https://man.cs50.io/3/sprintf"><code>sprintf</code></a> et notez que <code>sprintf</code> stocke une chaÃ®ne formatÃ©e Ã  un emplacement en mÃ©moire. Ã‰tant donnÃ© le format <code>###.jpg</code> prescrit pour le nom de fichier dâ€™un fichier JPEG, combien dâ€™octets devez-vous allouer pour cette chaÃ®ne ? (Nâ€™oubliez pas le caractÃ¨re NUL !)</p>
<p>Pour vÃ©rifier si les fichiers JPEG que votre programme renvoie sont corrects, double-cliquez simplement dessus et jetez un Å“il ! Si chaque photo apparaÃ®t intacte, votre opÃ©ration a probablement rÃ©ussi !</p>
<p>Et bien sÃ»r, nâ€™oubliez pas de <code>fclose</code> chaque fichier que vous avez ouvert avec <code>fopen</code> !</p>
<h3>Gardez votre rÃ©pertoire de travail propre</h3>
<p>Il y a de fortes chances que les fichiers JPEG que la premiÃ¨re Ã©bauche de votre code renvoie ne soient pas corrects. (Si vous les ouvrez et ne voyez rien, ils ne sont probablement pas corrects !) ExÃ©cutez la commande ci-dessous pour supprimer tous les fichiers JPEG dans votre rÃ©pertoire de travail actuel.</p>
<pre><code>  rm *.jpg
</code></pre>
<p>Si vous prÃ©fÃ©rez ne pas Ãªtre invitÃ© Ã  confirmer chaque suppression, exÃ©cutez plutÃ´t la commande ci-dessous.</p>
<pre><code>  rm -f *.jpg
</code></pre>
<p>Soyez simplement prudent avec ce commutateur <code>-f</code>, car il Â« force Â» la suppression sans vous le demander.</p>
<h2>ProcÃ©dure pas Ã  pas</h2>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/ooL0r_8N9ms?modestbranding=0&amp;rel=0&amp;showinfo=0"></iframe></div>

<h2>Comment tester</h2>
<h3>ExÃ©cuter le programme</h3>
<pre><code>  ./recover card.raw
</code></pre>
<h3>Correctness</h3>
<pre><code>  check50 cs50/problems/2024/x/recover
</code></pre>
<h3>Style</h3>
<pre><code>  style50 recover.c
</code></pre>
<h2>Comment soumettre</h2>
<pre><code>  submit50 cs50/problems/2024/x/recover
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>