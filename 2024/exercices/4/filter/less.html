<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en FranÃ§ais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en FranÃ§ais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch ğŸ˜º
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        MÃ©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de DonnÃ©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        CybersÃ©curitÃ©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">HonnÃªtetÃ© AcadÃ©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions FrÃ©quemment PosÃ©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Ã‰quipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>Filtre</h2>
<p><img alt="Harvard Yard en niveaux de gris" src="https://cs50.harvard.edu/x/2024/psets/4/filter/less/yard-grayscale.bmp" /></p>
<h2>ProblÃ¨me Ã  rÃ©soudre</h2>
<p>Le moyen peut-Ãªtre le plus simple de reprÃ©senter une image consiste Ã  utiliser une grille de pixels (c'est-Ã -dire de points), chacun pouvant Ãªtre d'une couleur diffÃ©rente. Pour les images en noir et blanc, nous avons donc besoin d'un bit par pixel, car 0 peut reprÃ©senter le noir et 1 peut reprÃ©senter le blanc, comme ci-dessous.</p>
<p><img alt="un bitmap simple" src="https://cs50.harvard.edu/x/2024/psets/4/filter/less/bitmap.png" /></p>
<p>En ce sens, une image n'est donc qu'un bitmap (c'est-Ã -dire une carte de bits). Pour les images plus colorÃ©es, il vous suffit de plus de bits par pixel. Un format de fichier (comme <a href="https://en.wikipedia.org/wiki/BMP_file_format">BMP</a>, <a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a>, ou <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics">PNG</a>) qui prend en charge la Â« couleur 24 bits Â» utilise 24 bits par pixel. (BMP prend en fait en charge les couleurs 1, 4, 8, 16, 24 et 32 bits.)</p>
<p>Un BMP 24 bits utilise 8 bits pour indiquer la quantitÃ© de rouge dans la couleur d'un pixel, 8 bits pour indiquer la quantitÃ© de vert dans la couleur d'un pixel et 8 bits pour indiquer la quantitÃ© de bleu dans la couleur d'un pixel. Si vous avez dÃ©jÃ  entendu parler de la couleur RVB, eh bien, voilÃ  : rouge, vert, bleu.</p>
<p>Si les valeurs R, V et B d'un pixel dans un BMP sont, par exemple, <code>0xff</code>, <code>0x00</code> et <code>0x00</code> en hexadÃ©cimal, ce pixel est purement rouge, car <code>0xff</code> (autrement dit <code>255</code> en dÃ©cimal) implique Â« beaucoup de rouge Â», tandis que <code>0x00</code> et <code>0x00</code> impliquent Â« pas de vert Â» et Â« pas de bleu Â», respectivement. Dans ce problÃ¨me, vous manipulerez ces valeurs R, V et B de pixels individuels, crÃ©ant finalement vos propres filtres d'image.</p>
<p>Dans un fichier appelÃ© <code>helpers.c</code> dans un dossier appelÃ© <code>filter-less</code>, Ã©crivez un programme pour appliquer des filtres aux BMP.</p>
<h2>DÃ©monstration</h2>
<script async="" data-autoplay="1" data-cols="100" data-loop="1" data-rows="12" id="asciicast-QnLel70SPmbW9nswXTb9Yu9ZD" src="https://asciinema.org/a/QnLel70SPmbW9nswXTb9Yu9ZD.js"></script>

<h2>Code de distribution</h2>
<p>Pour ce problÃ¨me, vous Ã©tendrez les fonctionnalitÃ©s du code qui vous a Ã©tÃ© fourni par l'Ã©quipe de CS50.</p>
<p>Connectez-vous Ã  <a href="https://cs50.dev/">cs50.dev</a>, cliquez sur votre fenÃªtre de terminal et exÃ©cutez <code>cd</code> seul. Vous devriez constater que l'invite de votre fenÃªtre de terminal ressemble Ã  ce qui suitÂ :</p>
<pre><code>  $
</code></pre>
<p>Ensuite, exÃ©cutez</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/4/filter-less.zip
</code></pre>
<p>afin de tÃ©lÃ©charger un ZIP appelÃ© <code>filter-less.zip</code> dans votre espace de code.</p>
<p>Ensuite, exÃ©cutez</p>
<pre><code>  unzip filter-less.zip
</code></pre>
<p>afin de crÃ©er un dossier appelÃ© <code>filter-less</code>. Vous n'avez plus besoin du fichier ZIP, vous pouvez exÃ©cuter</p>
<pre><code>  rm filter-less.zip
</code></pre>
<p>et rÃ©pondre par Â«Â yÂ Â» suivi d'EntrÃ©e Ã  l'invite de suppression du fichier ZIP que vous avez tÃ©lÃ©chargÃ©.</p>
<p>Maintenant, tapez</p>
<pre><code>  cd filter-less
</code></pre>
<p>suivi d'EntrÃ©e pour vous dÃ©placer (c'est-Ã -dire ouvrir) ce rÃ©pertoire. Votre invite devrait maintenant ressembler Ã  ce qui suit.</p>
<pre><code>  filter-less/ $
</code></pre>
<p>ExÃ©cutez <code>ls</code> seul, et vous devriez voir quelques fichiersÂ : <code>bmp.h</code>, <code>filter.c</code>, <code>helpers.h</code>, <code>helpers.c</code> et <code>Makefile</code>. Vous devriez Ã©galement voir un dossier, <code>images/</code>, avec quatre fichiers BMP. Si vous rencontrez un problÃ¨me, suivez Ã  nouveau ces Ã©tapes et essayez de dÃ©terminer oÃ¹ vous vous Ãªtes trompÃ©Â !</p>
<h2>Contexte</h2>
<h3>Technique (carte bits)</h3>
<p>Rappelons qu'un fichier est simplement une sÃ©quence de bits, agencÃ©s d'une certaine faÃ§on. Un fichier BMP 24 bits est donc essentiellement une sÃ©quence de bits, dont (presque) tous les 24 reprÃ©sentent la couleur d'un pixel. Cependant, un fichier BMP contient Ã©galement des Â« mÃ©tadonnÃ©es Â», des informations comme la hauteur et la largeur d'une image. Ces mÃ©tadonnÃ©es sont stockÃ©es au dÃ©but du fichier, sous la forme de deux structures de donnÃ©es gÃ©nÃ©ralement appelÃ©es Â« en-tÃªtes Â», Ã  ne pas confondre avec les fichiers d'en-tÃªte de C. (D'ailleurs, ces en-tÃªtes ont Ã©voluÃ© au fil du temps. Ce problÃ¨me utilise la derniÃ¨re version du format BMP de Microsoft, la 4.0, qui a fait ses dÃ©buts avec Windows 95.)</p>
<p>Le premier de ces en-tÃªtes, appelÃ© <code>BITMAPFILEHEADER</code>, fait 14 octets de long. (Rappelons que 1 octet est Ã©gal Ã  8 bits.) Le second en-tÃªte, appelÃ© <code>BITMAPINFOHEADER</code>, fait 40 octets de long. ImmÃ©diatement aprÃ¨s ces en-tÃªtes se trouve la carte bits rÃ©elle : une chaÃ®ne d'octets, dont les triplets reprÃ©sentent la couleur d'un pixel. Cependant, BMP stocke ces triplets Ã  l'envers (c.-Ã -d. en tant que BGR), avec 8 bits pour le bleu, suivis de 8 bits pour le vert, suivis de 8 bits pour le rouge. (Certains BMP stockent Ã©galement la carte bits entiÃ¨re Ã  l'envers, avec la ligne supÃ©rieure d'une image Ã  la fin du fichier BMP. Cependant, nous avons stockÃ© les fichiers BMP de cet ensemble de problÃ¨mes tels que dÃ©crits ici, avec la premiÃ¨re ligne de chaque carte bits en premier et la derniÃ¨re ligne en dernier.) En d'autres termes, si nous devions convertir le smiley 1 bit ci-dessus en un smiley 24 bits, en remplaÃ§ant le noir par du rouge, un BMP 24 bits stockerait cette carte bits comme suit, avec <code>0000ff</code> signifiant rouge et <code>ffffff</code> signifiant blanc ; nous avons mis en Ã©vidence au crayon rouge toutes les instances de <code>0000ff</code>.</p>
<p><img alt="red smile" src="https://cs50.harvard.edu/x/2024/psets/4/filter/less/red_smile.png" /></p>
<p>Comme nous avons prÃ©sentÃ© ces bits de gauche Ã  droite, de haut en bas, en 8 colonnes, vous pouvez rÃ©ellement voir la petite tÃªte rouge si vous reculez.</p>
<p>Pour plus de clartÃ©, rappelons qu'un chiffre hexadÃ©cimal reprÃ©sente 4 bits. Par consÃ©quent, <code>ffffff</code> en hexadÃ©cimal signifie en rÃ©alitÃ© <code>111111111111111111111111</code> en binaire.</p>
<p>Notez que vous pouvez reprÃ©senter une carte bits comme un tableau de pixels Ã  deux dimensions : l'image est un tableau de lignes, chaque ligne Ã©tant un tableau de pixels. En effet, c'est ainsi que nous avons choisi de reprÃ©senter les images bitmap dans ce problÃ¨me.</p>
<h3>Filtre d'image</h3>
<p>Que signifie mÃªme filtrer une image ? Filtrer une image consiste Ã  prendre les pixels de l'image originale et Ã  modifier chaque pixel de maniÃ¨re Ã  ce qu'un effet particulier soit apparent sur l'image rÃ©sultante.</p>
<h2>ComprÃ©hension</h2>
<p>Examinons maintenant certains des fichiers qui vous ont Ã©tÃ© fournis comme code de distribution pour comprendre ce qu'ils contiennent.</p>
<h3><code>bmp.h</code></h3>
<p>Ouvrez <code>bmp.h</code> (en double-cliquant dessus dans le navigateur de fichiers) et jetez un coup d'Å“il.</p>
<p>Vous verrez des dÃ©finitions pour les en-tÃªtes que nous avons mentionnÃ©s (<code>BITMAPINFOHEADER</code> et <code>BITMAPFILEHEADER</code>). De plus, ce fichier dÃ©finit <code>BYTE</code>, <code>DWORD</code>, <code>LONG</code> et <code>WORD</code>, des types de donnÃ©es que l'on trouve normalement dans le monde de la programmation Windows. Remarquez qu'il s'agit simplement d'alias pour des primitives que vous connaissez (espÃ©rons-le) dÃ©jÃ . Il semble que <code>BITMAPFILEHEADER</code> et <code>BITMAPINFOHEADER</code> utilisent ces types.</p>
<p>Le plus important pour vous, peut-Ãªtre, est que ce fichier dÃ©finit Ã©galement une structure appelÃ©e <code>RGBTRIPLE</code> qui, tout simplement, Â« encapsule Â» trois octets : un bleu, un vert et un rouge (l'ordre, rappelez-vous, dans lequel nous nous attendons Ã  trouver les triplets RVB sur le disque).</p>
<p>Pourquoi ces structures sont-elles utiles ? Eh bien, rappelons qu'un fichier est simplement une sÃ©quence d'octets (ou, au final, de bits) sur le disque. Cependant, ces octets sont gÃ©nÃ©ralement ordonnÃ©s de telle maniÃ¨re que les premiers reprÃ©sentent quelque chose, les suivants reprÃ©sentent autre chose, et ainsi de suite. Les Â« formats de fichiers Â» existent parce que le monde a standardisÃ© ce que les octets signifient. Maintenant, nous pourrions simplement lire un fichier sur un disque en RAM comme un grand tableau d'octets. Et nous pourrions simplement nous rappeler que l'octet <code>array[i]</code> reprÃ©sente une chose, tandis que l'octet <code>array[j]</code> en reprÃ©sente une autre. Mais pourquoi ne pas donner des noms Ã  certains de ces octets afin de pouvoir les rÃ©cupÃ©rer de la mÃ©moire plus facilement ? C'est prÃ©cisÃ©ment ce que nous permettent de faire les structures de <code>bmp.h</code>. Au lieu de penser Ã  certains fichiers comme une longue sÃ©quence d'octets, nous pouvons plutÃ´t les considÃ©rer comme une sÃ©quence de structures.</p>
<h3><code>filter.c</code></h3>
<p>Maintenant, ouvrons <code>filter.c</code>. Ce fichier a dÃ©jÃ  Ã©tÃ© Ã©crit pour vous, mais voici quelques points importants Ã  noter.</p>
<p>Tout d'abord, remarquez la dÃ©finition de <code>filters</code> Ã  la ligne 10. Cette chaÃ®ne indique au programme quels sont les arguments de ligne de commande autorisÃ©s pour le programme : <code>b</code>, <code>g</code>, <code>r</code> et <code>s</code>. Chacun d'eux spÃ©cifient un filtre diffÃ©rent que nous pourrions appliquer Ã  nos images : flou, Ã©chelle de gris, effet miroir et sÃ©pia.</p>
<p>Les lignes suivantes ouvrent un fichier image, s'assurent qu'il s'agit bien d'un fichier BMP et lisent toutes les informations sur les pixels dans un tableau 2D appelÃ© <code>image</code>.</p>
<p>Faites dÃ©filer jusqu'Ã  l'instruction <code>switch</code> qui commence Ã  la ligne 101. Notez que, selon le filtre <code>filter</code> que nous avons choisi, une fonction diffÃ©rente est appelÃ©e : si l'utilisateur choisit le filtre <code>b</code>, le programme appelle la fonction <code>blur</code> ; si <code>g</code>, alors <code>grayscale</code> est appelÃ© ; si <code>r</code>, alors <code>reflect</code> est appelÃ© ; et si <code>s</code>, alors <code>sepia</code> est appelÃ©. Notez Ã©galement que chacune de ces fonctions prend en arguments la hauteur de l'image, la largeur de l'image et le tableau 2D des pixels.</p>
<p>Ce sont les fonctions que vous implÃ©menterez (bientÃ´t !). Comme vous pouvez l'imaginer, le but est que chacune de ces fonctions modifie le tableau 2D des pixels de maniÃ¨re Ã  ce que le filtre souhaitÃ© soit appliquÃ© Ã  l'image.</p>
<p>Les lignes restantes du programme prennent l'image <code>image</code> rÃ©sultante et l'Ã©crivent dans un nouveau fichier image.</p>
<h3><code>helpers.h</code></h3>
<p>Ensuite, jetez un Å“il Ã  <code>helpers.h</code>. Ce fichier est assez court et ne fournit que les prototypes de fonction pour les fonctions que vous avez vues prÃ©cÃ©demment.</p>
<p>Notez ici que chaque fonction prend un tableau 2D appelÃ© <code>image</code> comme argument, oÃ¹ <code>image</code> est un tableau de <code>height</code> lignes, et que chaque ligne est elle-mÃªme un autre tableau de <code>width</code> <code>RGBTRIPLE</code>. Donc, si <code>image</code> reprÃ©sente l'image entiÃ¨re, alors <code>image[0]</code> reprÃ©sente la premiÃ¨re ligne, et <code>image[0][0]</code> reprÃ©sente le pixel dans le coin supÃ©rieur gauche de l'image.</p>
<h3><code>helpers.c</code></h3>
<p>Maintenant, ouvrez <code>helpers.c</code>. C'est ici que l'implÃ©mentation des fonctions dÃ©clarÃ©es dans <code>helpers.h</code> a sa place. Mais veuillez noter que, pour le moment, les implÃ©mentations sont manquantesÂ ! Cette partie vous revient.</p>
<h3><code>Makefile</code></h3>
<p>Enfin, examinons <code>Makefile</code>. Ce fichier spÃ©cifie ce qui doit se produire lorsque nous exÃ©cutons une commande de terminal comme <code>make filter</code>. Alors que les programmes que vous avez pu Ã©crire auparavant Ã©taient confinÃ©s Ã  un seul fichier, <code>filter</code> semble utiliser plusieurs fichiersÂ : <code>filter.c</code> et <code>helpers.c</code>. Nous devrons donc indiquer Ã  <code>make</code> comment compiler ce fichier.</p>
<p>Essayez de compiler <code>filter</code> vous-mÃªme en accÃ©dant Ã  votre terminal et en exÃ©cutantÂ :</p>
<pre><code>  $ make filter
</code></pre>
<p>Ensuite, vous pouvez exÃ©cuter le programme en exÃ©cutantÂ :</p>
<pre><code>  $ ./filter -g images/yard.bmp out.bmp
</code></pre>
<p>Ce qui prend l'image <code>images/yard.bmp</code> et gÃ©nÃ¨re une nouvelle image appelÃ©e <code>out.bmp</code> aprÃ¨s avoir passÃ© les pixels par la fonction <code>grayscale</code>. Cependant, <code>grayscale</code> ne fait rien pour l'instant, donc l'image de sortie doit ressembler Ã  la cour d'origine.</p>
<h2>SpÃ©cification</h2>
<p>ImplÃ©mentez les fonctions dans <code>helpers.c</code> de sorte qu'un utilisateur puisse appliquer des filtres en niveaux de gris, sÃ©pia, rÃ©flexion ou flou Ã  leurs images.</p>
<ul>
<li>La fonction <code>grayscale</code> doit prendre une image et la transformer en une version en noir et blanc de la mÃªme image.</li>
<li>La fonction <code>sepia</code> doit prendre une image et la transformer en une version sÃ©pia de la mÃªme image.</li>
<li>La fonction <code>reflect</code> doit prendre une image et la reflÃ©ter horizontalement.</li>
<li>Enfin, la fonction <code>blur</code> doit prendre une image et la transformer en une version floue au carrÃ© de la mÃªme image.</li>
</ul>
<p>Vous ne devez modifier aucune des signatures de fonction, ni aucun autre fichier que <code>helpers.c</code>.</p>
<h2>Astuces</h2>
<h3>ImplÃ©mentez <code>grayscale</code></h3>
<p>Un filtre courant est le filtre Â«Â en niveaux de grisÂ Â», oÃ¹ nous prenons une image et voulons la convertir en noir et blanc. Comment cela fonctionne-t-ilÂ ?</p>
<ul>
<li>Rappelez-vous que si les valeurs rouge, verte et bleue sont toutes dÃ©finies sur <code>0x00</code> (hexadÃ©cimal pour <code>0</code>), le pixel est noir. Et si toutes les valeurs sont dÃ©finies sur <code>0xff</code> (hexadÃ©cimal pour <code>255</code>), le pixel est blanc. Tant que les valeurs rouge, verte et bleue sont toutes Ã©gales, le rÃ©sultat sera des nuances de gris variables sur le spectre noir-blanc, les valeurs plus Ã©levÃ©es signifiant des teintes plus claires (plus proches du blanc) et les valeurs plus faibles signifiant des teintes plus foncÃ©es (plus proches du noir).</li>
<li>Donc, pour convertir un pixel en niveaux de gris, il suffit de s'assurer que les valeurs rouge, verte et bleue sont toutes de la mÃªme valeur. Mais comment savoir quelle valeur leur donnerÂ ? Eh bien, il est probablement raisonnable de s'attendre Ã  ce que si les valeurs rouge, verte et bleue d'origine Ã©taient toutes assez Ã©levÃ©es, la nouvelle valeur devrait Ã©galement Ãªtre assez Ã©levÃ©e. Et si les valeurs d'origine Ã©taient toutes faibles, la nouvelle valeur devrait Ã©galement Ãªtre faible.</li>
<li>En fait, pour garantir que chaque pixel de la nouvelle image ait toujours la mÃªme luminositÃ© ou obscuritÃ© gÃ©nÃ©rale que l'ancienne image, vous pouvez prendre la <strong>moyenne</strong> des valeurs rouge, verte et bleue pour dÃ©terminer la nuance de gris Ã  appliquer au nouveau pixel.</li>
</ul>
<p>Si vous appliquez l'algorithme ci-dessus Ã  chaque pixel de l'image, le rÃ©sultat sera une image convertie en niveaux de gris. Ã‰crivez du pseudo-code pour vous aider Ã  rÃ©soudre ce problÃ¨me.</p>
<pre><code>  void grayscale(int height, int width, RGBTRIPLE image[height][width])
  {
      // Boucler sur tous les pixels

          // Prendre la moyenne des valeurs rouge, verte et bleue

          // Mettre Ã  jour les valeurs des pixels
  }
</code></pre>
<p>Tout d'abord, comment pouvez-vous faire une boucle sur tous les pixelsÂ ? Rappelez-vous que les pixels de l'image sont stockÃ©s dans le tableau Ã  deux dimensions <code>image</code>. Pour itÃ©rer sur un tableau Ã  deux dimensions, vous aurez besoin de deux boucles, l'une imbriquÃ©e dans l'autre.</p>
<pre><code>  void grayscale(int height, int width, RGBTRIPLE image[height][width])
  {
      // Boucler sur tous les pixels
      for (int i = 0; i &lt; height; i++)
      {
          for (int j = 0; j &lt; width; j++)
          {
              // Prendre la moyenne des valeurs rouge, verte et bleue

              // Mettre Ã  jour les valeurs des pixels
          }
      }
  }
</code></pre>
<p>Maintenant, vous pouvez utiliser <code>image[i][j]</code> pour accÃ©der Ã  n'importe quel pixel individuel de l'image. Mais comment prendre la moyenne des Ã©lÃ©ments rouge, vert et bleuÂ ? Rappelez-vous que chaque Ã©lÃ©ment de <code>image</code> est un <code>RGBTRIPLE</code>, qui est la <code>struct</code> dÃ©finie dans <code>bmp.h</code> pour reprÃ©senter un pixel. La syntaxe habituelle pour accÃ©der aux membres d'une <code>struct</code> s'applique, dans laquelle <code>image[i][j].rgbtRed</code> vous donnera accÃ¨s Ã  la valeur rouge de <code>RGBTRIPLE</code>, <code>image[i][j].rgbtGreen</code> vous donnera accÃ¨s Ã  sa valeur verte, et ainsi de suite.</p>
<p>Lorsque vous calculez la moyenne, gardez Ã  l'esprit que les valeurs des composants <code>rgbtRed</code>, <code>rgbtGreen</code> et <code>rgbtBlue</code> d'un pixel sont tous des entiers. Assurez-vous donc d'<a href="https://manual.cs50.io/3/round">arrondir</a> tous les nombres Ã  virgule flottante Ã  l'entier le plus proche lorsque vous les affectez Ã  une valeur de pixelÂ ! Et pourquoi voudriez-vous diviser la somme de ces entiers par 3,0 et non par 3Â ?</p>
<p>Une fois que vous avez fait la moyenne des valeurs rouge, verte et bleue du pixel en une couleur en niveaux de gris rÃ©sultante, mettez Ã  jour les valeurs rouge, verte et bleue du pixel. Ã€ prÃ©sent, vous connaissez dÃ©jÃ  la syntaxe de l'affectationÂ !</p>
<h3>ImplÃ©menterÂ <code>sÃ©pia</code></h3>
<p>La plupart des logiciels de retouche d'images prennent en charge un filtreÂ Â«Â sÃ©piaÂ Â», qui donne aux images un aspect ancien en rendant l'ensemble de l'image lÃ©gÃ¨rement brun rougeÃ¢tre.</p>
<ul>
<li>On peut convertir une image en sÃ©pia en prenant chaque pixel et en calculant de nouvelles valeurs rouge, verte et bleue en fonction des valeurs d'origine des trois.</li>
<li>
<p>Il existe un certain nombre d'algorithmes pour convertir une image en sÃ©pia, mais pour ce problÃ¨me, nous vous demandons d'utiliser l'algorithme suivant. Pour chaque pixel, les valeurs de couleur sÃ©pia doivent Ãªtre calculÃ©es en fonction des valeurs de couleur d'origine comme indiquÃ© ci-dessous.
  sepiaRouge = 0,393 _ rougeOriginal + 0,769 _ vertOriginal + 0,189 _ bleuOriginal
  sepiaVert = 0,349 _ rougeOriginal + 0,686 _ vertOriginal + 0,168 _ bleuOriginal
  sepiaBleu = 0,272 _ rougeOriginal + 0,534 _ vertOriginal + 0,131 _ bleuOriginal</p>
</li>
<li>
<p>Bien sÃ»r, le rÃ©sultat de chacune de ces formules peut ne pas Ãªtre un entier, mais chaque valeur peut Ãªtre arrondie Ã  l'entier le plus proche. Il est Ã©galement possible que le rÃ©sultat de la formule soit un nombre supÃ©rieur Ã Â 255, la valeur maximale pour une valeur de couleurÂ 8Â bits. Dans ce cas, les valeurs rouge, verte et bleue doivent Ãªtre plafonnÃ©es Ã Â 255. Par consÃ©quent, nous pouvons garantir que les valeurs rouge, verte et bleue rÃ©sultantes seront des nombres entiers compris entreÂ 0 etÂ 255, inclus.</p>
</li>
</ul>
<p>Ã‰crivez un pseudoc code pour vous aider Ã  rÃ©soudre ce problÃ¨me et Ã  vous souvenir de l'utilisation de bouclesÂ <code>for</code> imbriquÃ©es pour visiter chaque pixel.</p>
<pre><code>  void sÃ©pia(int hauteur, int largeur, RGBTRIPLE image[hauteur][largeur])
  {
      // Boucler sur tous les pixels
      for (int i = 0Â ; i &lt; hauteurÂ ; i++)
      {
          for (int j = 0Â ; j &lt; largeurÂ ; j++)
          {
              // Calculer les valeurs sÃ©pia

              // Mettre Ã  jour le pixel avec des valeurs sÃ©pia
          }
      }
  }
</code></pre>
<p>Pour calculer les valeursÂ <code>sÃ©pia</code>, relisez les puces ci-dessus. Vous avez une formule pour calculer les valeurs sÃ©pia, mais il y a encore quelques piÃ¨ges. En particulier, vous devrezÂ :</p>
<ul>
<li>Arrondir le rÃ©sultat de chaque calcul Ã  l'entier le plus proche</li>
<li>S'assurer que la valeur rÃ©sultante n'est pas supÃ©rieure Ã Â 255</li>
</ul>
<p>Comment une fonction qui renvoie le plus petit de deux entiers peut-elle Ãªtre utile lors de l'implÃ©mentation deÂ <code>sÃ©pia</code>, en particulier lorsque vous devez vous assurer que la valeur d'une couleur n'est pas supÃ©rieure Ã Â 255Â ? Vous pouvez, mais ce n'est pas obligatoire, Ã©crire votre propre fonction d'assistance pour faire exactement celaÂ !</p>
<h3>ImplÃ©menterÂ <code>reflÃ©ter</code></h3>
<p>Certains filtres peuvent Ã©galement dÃ©placer les pixels. La rÃ©flexion d'une image, par exemple, est un filtre oÃ¹ l'image rÃ©sultante est ce que vous obtiendriez en plaÃ§ant l'image originale devant un miroir.</p>
<ul>
<li>Tous les pixels sur le cÃ´tÃ© gauche de l'image doivent se retrouver Ã  droite, et vice versa.</li>
<li>Notez que tous les pixels originaux de l'image originale seront toujours prÃ©sents dans l'image rÃ©flÃ©chie, c'est juste que ces pixels ont peut-Ãªtre Ã©tÃ© rÃ©arrangÃ©s pour Ãªtre Ã  un endroit diffÃ©rent dans l'image.</li>
</ul>
<p>Dans la fonctionÂ <code>reflÃ©ter</code>, vous devrez donc permuter les valeurs des pixels sur les cÃ´tÃ©s opposÃ©s d'une ligne. Ã‰crivez un pseudoc code pour vous aider Ã  dÃ©marrerÂ :</p>
<pre><code>  void reflÃ©ter(int hauteur, int largeur, RGBTRIPLE image[hauteur][largeur])
  {
      // Boucler sur tous les pixels
      for (int i = 0Â ; i &lt; hauteurÂ ; i++)
      {
          for (int j = 0Â ; j &lt; largeurÂ ; j++)
          {
              // Permuter les pixels
          }
      }
  }
</code></pre>
<p>Rappelez-vous du cours comment nous avons implÃ©mentÃ© l'Ã©change de deux valeurs avec une variable temporaire. Pas besoin d'utiliser une fonction sÃ©parÃ©e pour l'Ã©change, sauf si vous le souhaitezÂ !</p>
<p>Et c'est le bon moment pour penser Ã  vos bouclesÂ <code>for</code> imbriquÃ©es. La boucleÂ <code>for</code> externe itÃ¨re sur chaque ligne, tandis que la boucleÂ <code>for</code> interne itÃ¨re sur chaque pixel de cette ligne. Cependant, pour rÃ©ussir Ã  reflÃ©ter une ligne, avez-vous besoin d'itÃ©rer sur chaque pixelÂ ?</p>
<h3>ImplÃ©menter <code>flou</code></h3>
<p>Il existe plusieurs faÃ§ons de crÃ©er l'effet d'un flou ou d'un adoucissement d'une image. Pour ce problÃ¨me, nous utiliserons le "flou de boÃ®te", qui consiste Ã  prendre chaque pixel et, pour chaque valeur de couleur, Ã  lui donner une nouvelle valeur en faisant la moyenne des valeurs de couleur des pixels voisins.</p>
<ul>
<li>ConsidÃ©rez la grille de pixels suivante, oÃ¹ nous avons numÃ©rotÃ© chaque pixel.
  <img alt="une grille de pixels" src="grid.png" /></li>
<li>La nouvelle valeur de chaque pixel serait la moyenne des valeurs de tous les pixels qui sont Ã  1 rangÃ©e et Ã  1 colonne du pixel d'origine (formant une boÃ®te 3x3). Par exemple, chacune des valeurs de couleur du pixel 6 serait obtenue en faisant la moyenne des valeurs de couleur d'origine des pixels 1, 2, 3, 5, 6, 7, 9, 10 et 11 (notez que le pixel 6 lui-mÃªme est inclus dans la moyenne). De mÃªme, les valeurs de couleur du pixel 11 seraient obtenues en faisant la moyenne des valeurs de couleur des pixels 6, 7, 8, 10, 11, 12, 14, 15 et 16.</li>
<li>Pour un pixel situÃ© sur le bord ou le coin, comme le pixel 15, nous rechercherions toujours tous les pixels Ã  1 rangÃ©e et Ã  1 colonne : dans ce cas, les pixels 10, 11, 12, 14, 15 et 16.</li>
</ul>
<p>Lors de l'implÃ©mentation de la fonction <code>flou</code>, vous constaterez peut-Ãªtre que le fait de flouter un pixel finit par affecter le flou d'un autre pixel. Il serait prÃ©fÃ©rable de crÃ©er une copie de <code>image</code> en dÃ©clarant un nouveau tableau Ã  deux dimensions avec du code tel que <code>RGBTRIPLE copy[height][width];</code>. Puis copiez <code>image</code> dans <code>copy</code>, pixel par pixel, avec des boucles <code>for</code> imbriquÃ©es, comme ceci :</p>
<pre><code>  void blur(int height, int width, RGBTRIPLE image[height][width])
  {
      // CrÃ©er une copie de image
      RGBTRIPLE copy[height][width];
      for (int i = 0; i &lt; height; i++)
      {
          for (int j = 0; j &lt; width; j++)
          {
              copy[i][j] = image[i][j];
          }
      }
  }
</code></pre>
<p>Maintenant, vous pouvez lire les couleurs des pixels Ã  partir de <code>copy</code> mais Ã©crire (c'est-Ã -dire modifier) les couleurs des pixels dans <code>image</code> !</p>
<h2>ProcÃ©dure pas Ã  pas</h2>
<p><strong>Veuillez noter qu'il y a 5 vidÃ©os dans cette liste de lecture.</strong></p>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/K0v9byp9jd0?modestbranding=0&amp;rel=0&amp;showinfo=1&amp;list=PLhQjrBD2T3837jmUt0ep7Tpmnxdv9NVut"></iframe></div>

<h2>Comment tester</h2>
<p>Assurez-vous de tester tous vos filtres sur les fichiers bitmap d'exemple fournis !</p>
<h3>Justesse</h3>
<pre><code>  check50 cs50/problems/2024/x/filter/less
</code></pre>
<h3>Style</h3>
<pre><code>  style50 helpers.c
</code></pre>
<h2>Comment soumettre</h2>
<pre><code>  submit50 cs50/problems/2024/x/filter/less
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>