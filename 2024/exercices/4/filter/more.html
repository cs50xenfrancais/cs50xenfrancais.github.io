<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en FranÃ§ais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en FranÃ§ais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch ğŸ˜º
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        MÃ©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de DonnÃ©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        CybersÃ©curitÃ©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">HonnÃªtetÃ© AcadÃ©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions FrÃ©quemment PosÃ©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Ã‰quipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>Filtre</h1>
<p><img alt="Harvard Yard avec DÃ©tection des Bords" src="https://cs50.harvard.edu/x/2024/psets/4/filter/more/yard-edges.bmp" /></p>
<h2>ProblÃ¨me Ã  RÃ©soudre</h2>
<p>Le moyen le plus simple de reprÃ©senter une image est peut-Ãªtre d'utiliser une grille de pixels (c'est-Ã -dire de points), chacun pouvant Ãªtre d'une couleur diffÃ©rente. Pour les images en noir et blanc, nous avons donc besoin de 1 bit par pixel, car 0 pourrait reprÃ©senter le noir et 1 pourrait reprÃ©senter le blanc, comme indiquÃ© ci-dessous.</p>
<p><img alt="un bitmap simple" src="https://cs50.harvard.edu/x/2024/psets/4/filter/more/bitmap.png" /></p>
<p>En ce sens, une image n'est-elle qu'un bitmap (c'est-Ã -dire une carte de bits) ? Pour les images plus colorÃ©es, vous avez simplement besoin de plus de bits par pixel. Un format de fichier (comme <a href="https://en.wikipedia.org/wiki/BMP_file_format">BMP</a>, <a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a> ou <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics">PNG</a>) qui prend en charge la "couleur 24 bits" utilise 24 bits par pixel. (BMP prend en charge les couleurs 1, 4, 8, 16, 24 et 32 bits.)</p>
<p>Un BMP 24 bits utilise 8 bits pour indiquer la quantitÃ© de rouge dans la couleur d'un pixel, 8 bits pour indiquer la quantitÃ© de vert dans la couleur d'un pixel et 8 bits pour indiquer la quantitÃ© de bleu dans la couleur d'un pixel. Si vous avez dÃ©jÃ  entendu parler de la couleur RVB, eh bien, vous l'avez : rouge, vert, bleu.</p>
<p>Si les valeurs R, V et B d'un pixel dans un BMP sont, par exemple, <code>0xff</code>, <code>0x00</code> et <code>0x00</code> en hexadÃ©cimal, ce pixel est purement rouge, car <code>0xff</code> (Ã©galement connu sous le nom <code>255</code> en dÃ©cimal) implique "beaucoup de rouge", tandis que <code>0x00</code> et <code>0x00</code> impliquent respectivement "pas de vert" et "pas de bleu". Dans ce problÃ¨me, vous manipulerez ces valeurs R, V et B de pixels individuels, crÃ©ant ainsi vos propres filtres d'image.</p>
<p>Dans un fichier appelÃ© <code>helpers.c</code> dans un dossier appelÃ© <code>filter-more</code>, Ã©crivez un programme pour appliquer des filtres aux BMP.</p>
<h2>DÃ©monstration</h2>
<script async="" data-autoplay="1" data-cols="100" data-loop="1" data-rows="12" id="asciicast-DC5vtWOatmXC3Ff825YxHE0CZ" src="https://asciinema.org/a/DC5vtWOatmXC3Ff825YxHE0CZ.js"></script>

<h2>Code de distribution</h2>
<p>Pour ce problÃ¨me, vous Ã©tendrez les fonctionnalitÃ©s du code fourni par l'Ã©quipe de CS50.</p>
<p>Connectez-vous Ã  <a href="https://cs50.dev/">cs50.dev</a>, cliquez sur votre fenÃªtre de terminal et exÃ©cutez <code>cd</code> seul. Vous devriez constater que l'invite de votre fenÃªtre de terminal ressemble Ã  celle-ciÂ :</p>
<pre><code>  $
</code></pre>
<p>ExÃ©cutez ensuiteÂ :</p>
<pre><code>  wget https://cdn.cs50.net/2023/fall/psets/4/filter-more.zip
</code></pre>
<p>afin de tÃ©lÃ©charger un ZIP nommÃ© <code>filter-more.zip</code> dans votre espace de code.</p>
<p>ExÃ©cutez ensuiteÂ :</p>
<pre><code>  unzip filter-more.zip
</code></pre>
<p>pour crÃ©er un dossier appelÃ© <code>filter-more</code>. Vous n'avez plus besoin du fichier ZIP, vous pouvez donc exÃ©cuterÂ :</p>
<pre><code>  rm filter-more.zip
</code></pre>
<p>et rÃ©pondre par Â« y Â» suivi de EntrÃ©e Ã  l'invite pour supprimer le fichier ZIP que vous avez tÃ©lÃ©chargÃ©.</p>
<p>Tapez maintenantÂ :</p>
<pre><code>  cd filter-more
</code></pre>
<p>suivi de EntrÃ©e pour vous dÃ©placer dans (c'est-Ã -dire ouvrir) ce rÃ©pertoire. Votre invite devrait maintenant ressembler Ã  celle-ciÂ :</p>
<pre><code>  filter-more/ $
</code></pre>
<p>ExÃ©cutez <code>ls</code> seul, et vous devriez voir quelques fichiers : <code>bmp.h</code>, <code>filter.c</code>, <code>helpers.h</code>, <code>helpers.c</code> et <code>Makefile</code>. Vous devriez Ã©galement voir un dossier appelÃ© <code>images</code> avec quatre fichiers BMP. Si vous rencontrez des problÃ¨mes, suivez Ã  nouveau ces mÃªmes Ã©tapes et voyez si vous pouvez dÃ©terminer oÃ¹ vous vous Ãªtes trompÃ©Â !</p>
<h2>Contexte</h2>
<h3>Un peu (mappage de bits) plus technique</h3>
<p>N'oubliez pas qu'un fichier est juste une sÃ©quence de bits, arrangÃ©s d'une certaine faÃ§on. Un fichier BMP 24 bits n'est donc essentiellement qu'une sÃ©quence de bits, dont (presque) tous les 24 reprÃ©sentent la couleur d'un pixel. Mais un fichier BMP contient Ã©galement des Â« mÃ©tadonnÃ©es Â», des informations telles que la hauteur et la largeur d'une image. Ces mÃ©tadonnÃ©es sont stockÃ©es au dÃ©but du fichier sous la forme de deux structures de donnÃ©es gÃ©nÃ©ralement appelÃ©es Â« en-tÃªtes Â», Ã  ne pas confondre avec les fichiers d'en-tÃªte C. (D'ailleurs, ces en-tÃªtes ont Ã©voluÃ© au fil du temps. Ce problÃ¨me utilise la derniÃ¨re version du format BMP de Microsoft, 4.0, qui a fait ses dÃ©buts avec Windows 95.)</p>
<p>Le premier de ces en-tÃªtes, appelÃ© <code>BITMAPFILEHEADER</code>, a une longueur de 14 octets. (Rappelons que 1 octet Ã©quivaut Ã  8 bits.) Le second de ces en-tÃªtes, appelÃ© <code>BITMAPINFOHEADER</code>, a une longueur de 40 octets. ImmÃ©diatement aprÃ¨s ces en-tÃªtes se trouve le bitmap rÃ©elÂ : un tableau d'octets, dont les triplets reprÃ©sentent la couleur d'un pixel. Cependant, BMP stocke ces triplets Ã  l'envers (c'est-Ã -dire comme BGR), avec 8 bits pour le bleu, suivis de 8 bits pour le vert, suivis de 8 bits pour le rouge. (Certains BMP stockent Ã©galement le bitmap entier Ã  l'envers, avec la rangÃ©e supÃ©rieure d'une image Ã  la fin du fichier BMP. Mais nous avons stockÃ© les BMP de cet ensemble de problÃ¨mes comme dÃ©crit ici, avec la rangÃ©e supÃ©rieure de chaque bitmap en premier et la rangÃ©e infÃ©rieure en dernier.) En d'autres termes, si nous devions convertir le smiley 1 bit ci-dessus en un smiley 24 bits, en remplaÃ§ant le noir par du rouge, un BMP 24 bits stockerait ce bitmap comme suit, oÃ¹ <code>0000ff</code> signifie rouge et <code>ffffff</code> signifie blancÂ ; nous avons surlignÃ© en rouge toutes les instances de <code>0000ff</code>.</p>
<p><img alt="sourire rouge" src="https://cs50.harvard.edu/x/2024/psets/4/filter/more/red_smile.png" /></p>
<p>Parce que nous avons prÃ©sentÃ© ces bits de gauche Ã  droite, de haut en bas, en 8 colonnes, vous pouvez rÃ©ellement voir le smiley rouge si vous prenez du recul.</p>
<p>Pour Ãªtre clair, rappelez-vous qu'un chiffre hexadÃ©cimal reprÃ©sente 4 bits. En consÃ©quence, <code>ffffff</code> en hexadÃ©cimal signifie en rÃ©alitÃ© <code>111111111111111111111111</code> en binaire.</p>
<p>Notez que vous pouvez reprÃ©senter un bitmap sous la forme d'un tableau de pixels Ã  2 dimensionsÂ : oÃ¹ l'image est un tableau de lignes, chaque ligne est un tableau de pixels. En effet, c'est ainsi que nous avons choisi de reprÃ©senter les images bitmap dans ce problÃ¨me.</p>
<h3>Filtrage d'image</h3>
<p>Que signifie filtrer une image ? On peut considÃ©rer le filtrage d'une image comme la prise des pixels d'une image originale, et la modification de chaque pixel de telle sorte qu'un effet particulier soit apparent dans l'image rÃ©sultante.</p>
<h4>Niveaux de gris</h4>
<p>Un filtre courant est le filtre Â« niveaux de gris Â», oÃ¹ on prend une image et on veut la convertir en noir et blanc. Comment cela fonctionne-t-il ?</p>
<p>Rappelons que si les valeurs rouge, verte et bleue sont toutes dÃ©finies Ã  <code>0x00</code> (hexadÃ©cimal pour <code>0</code>), alors le pixel est noir. Et si toutes les valeurs sont dÃ©finies Ã  <code>0xff</code> (hexadÃ©cimal pour <code>255</code>), alors le pixel est blanc. Tant que les valeurs rouge, verte et bleue sont toutes Ã©gales, le rÃ©sultat sera des nuances de gris variables le long du spectre noir et blanc, avec des valeurs plus Ã©levÃ©es signifiant des nuances plus claires (plus proches du blanc) et des valeurs plus faibles signifiant des nuances plus foncÃ©es (plus proches du noir).</p>
<p>Donc, pour convertir un pixel en niveaux de gris, il suffit de s'assurer que les valeurs rouge, verte et bleue sont toutes de la mÃªme valeur. Mais comment savoir quelle valeur leur donner ? Eh bien, il est probablement raisonnable de s'attendre Ã  ce que si les valeurs rouge, verte et bleue d'origine Ã©taient toutes assez Ã©levÃ©es, la nouvelle valeur devrait Ã©galement Ãªtre assez Ã©levÃ©e. Et si les valeurs originales Ã©taient toutes faibles, alors la nouvelle valeur devrait Ã©galement Ãªtre faible.</p>
<p>En fait, pour s'assurer que chaque pixel de la nouvelle image a toujours la mÃªme luminositÃ© ou la mÃªme obscuritÃ© que l'ancienne image, on peut prendre la moyenne des valeurs rouge, verte et bleue pour dÃ©terminer quelle nuance de gris donner au nouveau pixel.</p>
<p>Si vous appliquez cela Ã  chaque pixel de l'image, le rÃ©sultat sera une image convertie en niveaux de gris.</p>
<h4>RÃ©flexion</h4>
<p>Certains filtres peuvent Ã©galement dÃ©placer les pixels. La rÃ©flexion d'une image, par exemple, est un filtre oÃ¹ l'image rÃ©sultante est ce que vous obtiendriez en plaÃ§ant l'image originale devant un miroir. Ainsi, tous les pixels du cÃ´tÃ© gauche de l'image doivent se retrouver sur la droite, et vice versa.</p>
<p>Notez que tous les pixels originaux de l'image originale seront toujours prÃ©sents dans l'image rÃ©flÃ©chie, c'est juste que ces pixels peuvent avoir Ã©tÃ© rÃ©arrangÃ©s pour Ãªtre Ã  un autre endroit de l'image.</p>
<h4>Flou</h4>
<p>Il y a plusieurs faÃ§ons de crÃ©er l'effet de flou ou d'adoucissement d'une image. Pour ce problÃ¨me, nous allons utiliser le Â« flou gaussien Â», qui fonctionne en prenant chaque pixel et, pour chaque valeur de couleur, en lui donnant une nouvelle valeur en faisant la moyenne des valeurs de couleur des pixels voisins.</p>
<p>ConsidÃ©rez la grille de pixels suivante, oÃ¹ nous avons numÃ©rotÃ© chaque pixel.</p>
<p><img alt="Une grille de pixels" src="https://cs50.harvard.edu/x/2024/psets/4/filter/more/grid.png" /></p>
<p>La nouvelle valeur de chaque pixel serait la moyenne des valeurs de tous les pixels qui se trouvent dans une ligne et une colonne de l'image originale (formant une boÃ®te de 3x3). Par exemple, chacune des valeurs de couleur du pixel 6 serait obtenue en faisant la moyenne des valeurs de couleur d'origine des pixels 1, 2, 3, 5, 6, 7, 9, 10 et 11 (notez que le pixel 6 lui-mÃªme est inclus dans la moyenne). De mÃªme, les valeurs de couleur du pixel 11 seraient obtenues en faisant la moyenne des valeurs de couleur des pixels 6, 7, 8, 10, 11, 12, 14, 15 et 16.</p>
<p>Pour un pixel situÃ© sur le bord ou dans le coin, comme le pixel 15, on chercherait toujours tous les pixels situÃ©s dans une ligne et une colonne : dans ce cas, les pixels 10, 11, 12, 14, 15 et 16.</p>
<h4>ArÃªtes</h4>
<p>Dans les algorithmes d'intelligence artificielle pour le traitement d'images, il est souvent utile de dÃ©tecter les arÃªtes dans une image : des lignes dans l'image qui crÃ©ent une frontiÃ¨re entre un objet et un autre. Une faÃ§on d'obtenir cet effet est d'appliquer l'opÃ©rateur de <a href="https://fr.wikipedia.org/wiki/Op%C3%A9rateur_de_Sobel">Sobel</a> Ã  l'image.</p>
<p>Tout comme le flou d'image, la dÃ©tection des arÃªtes fonctionne Ã©galement en prenant chaque pixel et en le modifiant en fonction de la grille 3x3 des pixels qui entourent ce pixel. Mais au lieu de simplement prendre la moyenne des neuf pixels, l'opÃ©rateur de Sobel calcule la nouvelle valeur de chaque pixel en prenant une somme pondÃ©rÃ©e des valeurs des pixels environnants. Et puisque les arÃªtes entre les objets peuvent se produire dans une direction verticale et une direction horizontale, vous calculerez en fait deux sommes pondÃ©rÃ©es : une pour dÃ©tecter les arÃªtes dans la direction x et une pour dÃ©tecter les arÃªtes dans la direction y. En particulier, vous utiliserez les deux Â« noyaux Â» suivants :</p>
<p><img alt="Noyaux de Sobel" src="https://cs50.harvard.edu/x/2024/psets/4/filter/more/sobel.png" /></p>
<p>Comment interprÃ©ter ces noyauxÂ ? En bref, pour chacune des trois valeurs de couleur de chaque pixel, nous calculerons deux valeurs <code>Gx</code> et <code>Gy</code>. Pour calculer <code>Gx</code> pour la valeur du canal rouge d'un pixel, par exemple, nous prendrons les valeurs rouges d'origine des neuf pixels qui forment une boÃ®te 3x3 autour du pixel, nous les multiplierons chacune par la valeur correspondante dans le noyau <code>Gx</code>, et nous prendrons la somme des valeurs rÃ©sultantes.</p>
<p>Pourquoi ces valeurs particuliÃ¨res pour le noyauÂ ? Dans la direction <code>Gx</code>, par exemple, nous multiplions les pixels Ã  droite du pixel cible par un nombre positif, et les pixels Ã  gauche du pixel cible par un nombre nÃ©gatif. Lorsque nous prenons la somme, si les pixels de droite ont une couleur similaire Ã  celle des pixels de gauche, le rÃ©sultat sera proche de 0 (les nombres s'annulent). Mais si les pixels de droite sont trÃ¨s diffÃ©rents des pixels de gauche, alors la valeur rÃ©sultante sera trÃ¨s positive ou trÃ¨s nÃ©gative, indiquant un changement de couleur qui est probablement le rÃ©sultat d'une frontiÃ¨re entre des objets. Et un argument similaire est valable pour le calcul des arÃªtes dans la direction <code>y</code>.</p>
<p>Ã€ l'aide de ces noyaux, nous pouvons gÃ©nÃ©rer une valeur <code>Gx</code> et <code>Gy</code> pour chacun des canaux rouge, vert et bleu d'un pixel. Mais chaque canal ne peut prendre qu'une seule valeur, pas deuxÂ : nous avons donc besoin d'un moyen de combiner <code>Gx</code> et <code>Gy</code> en une seule valeur. L'algorithme du filtre de Sobel combine <code>Gx</code> et <code>Gy</code> en une valeur finale en calculant la racine carrÃ©e de <code>Gx^2 + Gy^2</code>. Et puisque les valeurs de canal ne peuvent prendre que des valeurs entiÃ¨res de 0 Ã  255, assurez-vous que la valeur rÃ©sultante soit arrondie Ã  l'entier le plus proche et plafonnÃ©e Ã  255Â !</p>
<p>Et que faire des pixels au bord ou dans le coin de l'imageÂ ? Il existe de nombreuses faÃ§ons de gÃ©rer les pixels au bord, mais pour les besoins de ce problÃ¨me, nous vous demanderons de traiter l'image comme si elle Ã©tait entourÃ©e d'une bordure noire pleine de 1 pixel : par consÃ©quent, essayer d'accÃ©der Ã  un pixel au-delÃ  du bord de l'image doit Ãªtre traitÃ© comme un pixel noir plein (valeurs de 0 pour chaque rouge, vert et bleu). Cela ignorera effectivement ces pixels de nos calculs de <code>Gx</code> et <code>Gy</code>.</p>
<h2>SpÃ©cification</h2>
<p>ImplÃ©mentez les fonctions dans <code>helpers.c</code> de telle sorte qu'un utilisateur puisse appliquer des filtres de niveaux de gris, de rÃ©flexion, de flou ou de dÃ©tection de contours Ã  ses images.</p>
<ul>
<li>La fonction <code>grayscale</code> doit prendre une image et la transformer en une version noir et blanc de la mÃªme image.</li>
<li>La fonction <code>reflect</code> doit prendre une image et la reflÃ©ter horizontalement.</li>
<li>La fonction <code>blur</code> doit prendre une image et la transformer en une version floutÃ©e (effet Â«Â box-blurÂ Â») de la mÃªme image.</li>
<li>La fonction <code>edges</code> doit prendre une image et mettre en Ã©vidence les contours entre les objets, selon l'opÃ©rateur de Sobel.</li>
</ul>
<p>Vous ne devez modifier aucune des signatures des fonctions, ni aucun autre fichier que <code>helpers.c</code>.</p>
<h2>ComprÃ©hension</h2>
<p>Examinons maintenant certains des fichiers qui vous ont Ã©tÃ© fournis en tant que code de distribution pour comprendre ce qu'ils contiennent.</p>
<h3><code>bmp.h</code></h3>
<p>Ouvrez <code>bmp.h</code> (en double-cliquant dessus dans le navigateur de fichiers) et examinez-le.</p>
<p>Vous verrez les dÃ©finitions des en-tÃªtes que nous avons mentionnÃ©s (<code>BITMAPINFOHEADER</code> et <code>BITMAPFILEHEADER</code>). En outre, ce fichier dÃ©finit <code>BYTE</code>, <code>DWORD</code>, <code>LONG</code> et <code>WORD</code>, des types de donnÃ©es que l'on trouve gÃ©nÃ©ralement dans le monde de la programmation Windows. Notez qu'ils sont simplement des alias pour des Ã©lÃ©ments primitifs que vous connaissez (probablement) dÃ©jÃ . Il semble que <code>BITMAPFILEHEADER</code> et <code>BITMAPINFOHEADER</code> utilisent ces types.</p>
<p>Surtout, ce fichier dÃ©finit Ã©galement une <code>struct</code> appelÃ©e <code>RGBTRIPLE</code> qui, tout simplement, Â«Â encapsuleÂ Â» trois octetsÂ : un bleu, un vert et un rouge (l'ordre, rappelons-nous, dans lequel nous nous attendons Ã  trouver des triplets RVB sur le disque).</p>
<p>Pourquoi ces <code>struct</code> sont-elles utilesÂ ? Eh bien, rappelez-vous qu'un fichier est simplement une sÃ©quence d'octets (ou, en fin de compte, de bits) sur le disque. Mais ces octets sont gÃ©nÃ©ralement ordonnÃ©s de telle maniÃ¨re que les premiers reprÃ©sentent quelque chose, les suivants reprÃ©sentent autre chose, etc. Les Â«Â formats de fichiersÂ Â» existent parce que le monde a normalisÃ© ce que les octets signifient. Maintenant, nous pourrions simplement lire un fichier Ã  partir du disque dans la RAM comme un grand tableau d'octets. Et nous pourrions simplement nous rappeler que l'octet Ã  <code>array[i]</code> reprÃ©sente une chose, tandis que l'octet Ã  <code>array[j]</code> reprÃ©sente autre chose. Mais pourquoi ne pas donner des noms Ã  certains de ces octets afin que nous puissions les rÃ©cupÃ©rer plus facilement de la mÃ©moireÂ ? C'est prÃ©cisÃ©ment ce que les <code>struct</code> dans <code>bmp.h</code> nous permettent de faire. PlutÃ´t que de considÃ©rer un fichier comme une longue sÃ©quence d'octets, nous pouvons le considÃ©rer comme une sÃ©quence de <code>struct</code>.</p>
<h3><code>filter.c</code></h3>
<p>Maintenant, ouvrons <code>filter.c</code>. Ce fichier a dÃ©jÃ  Ã©tÃ© Ã©crit pour vous, mais voici quelques points importants Ã  noterÂ :</p>
<p>PremiÃ¨rement, notez la dÃ©finition de <code>filters</code> Ã  la ligne 10. Cette chaÃ®ne indique au programme quels sont les arguments de ligne de commande autorisÃ©s pour le programmeÂ : <code>b</code>, <code>e</code>, <code>g</code> et <code>r</code>. Chacun d'eux spÃ©cifie un filtre diffÃ©rent que nous pouvons appliquer Ã  nos imagesÂ : flou, dÃ©tection des contours, niveaux de gris et rÃ©flexion.</p>
<p>Les lignes suivantes ouvrent un fichier image, s'assurent qu'il s'agit bien d'un fichier BMP et lisent toutes les informations sur les pixels dans un tableau 2D appelÃ© <code>image</code>.</p>
<p>Faites dÃ©filer jusqu'Ã  l'instruction <code>switch</code> qui commence Ã  la ligne 101. Notez que, selon le <code>filter</code> que nous avons choisi, une fonction diffÃ©rente est appelÃ©eÂ : si l'utilisateur choisit le filtre <code>b</code>, le programme appelle la fonction <code>blur</code>Â ; si <code>e</code>, alors <code>edges</code> est appelÃ©eÂ ; si <code>g</code>, alors <code>grayscale</code> est appelÃ©eÂ ; et si <code>r</code>, alors <code>reflect</code> est appelÃ©e. Notez Ã©galement que chacune de ces fonctions prend comme arguments la hauteur de l'image, la largeur de l'image et le tableau 2D de pixels.</p>
<p>Voici les fonctions que vous allez (bientÃ´tÂ !) implÃ©menter. Comme vous pouvez l'imaginer, l'objectif est que chacune de ces fonctions modifie le tableau 2D de pixels de maniÃ¨re Ã  ce que le filtre souhaitÃ© soit appliquÃ© Ã  l'image.</p>
<p>Les lignes restantes du programme prennent l'image <code>image</code> rÃ©sultante et l'Ã©crivent dans un nouveau fichier image.</p>
<h3><code>helpers.h</code></h3>
<p>Ensuite, regardez <code>helpers.h</code>. Ce fichier est assez court et fournit simplement les prototypes de fonctions pour les fonctions que vous avez vues prÃ©cÃ©demment.</p>
<p>Ici, notez que chaque fonction prend un tableau 2D appelÃ© <code>image</code> comme argument, oÃ¹ <code>image</code> est un tableau de <code>height</code> lignes, et chaque ligne est elle-mÃªme un autre tableau de <code>width</code> <code>RGBTRIPLE</code>. Donc, si <code>image</code> reprÃ©sente l'image entiÃ¨re, alors <code>image[0]</code> reprÃ©sente la premiÃ¨re ligne, et <code>image[0][0]</code> reprÃ©sente le pixel dans le coin supÃ©rieur gauche de l'image.</p>
<h3><code>helpers.c</code></h3>
<p>Maintenant, ouvrez <code>helpers.c</code>. C'est ici que l'implÃ©mentation des fonctions dÃ©clarÃ©es dans <code>helpers.h</code> appartient. Mais notez que, pour l'instant, les implÃ©mentations sont manquantesÂ ! Cette partie est Ã  vous.</p>
<h3><code>Makefile</code></h3>
<p>Enfin, examinons <code>Makefile</code>. Ce fichier spÃ©cifie ce qui doit se produire lorsque nous exÃ©cutons une commande de terminal comme <code>make filter</code>. Alors que les programmes que vous avez peut-Ãªtre Ã©crits auparavant Ã©taient confinÃ©s Ã  un seul fichier, <code>filter</code> semble utiliser plusieurs fichiersÂ : <code>filter.c</code> et <code>helpers.c</code>. Nous devrons donc indiquer Ã  <code>make</code> comment compiler ce fichier.</p>
<p>Essayez de compiler <code>filter</code> vous-mÃªme en allant Ã  votre terminal et en exÃ©cutantÂ :</p>
<pre><code>  $ make filter
</code></pre>
<p>Ensuite, vous pouvez exÃ©cuter le programme en exÃ©cutantÂ :</p>
<pre><code>  $ ./filter -g images/yard.bmp out.bmp
</code></pre>
<p>qui prend l'image dans <code>images/yard.bmp</code> et gÃ©nÃ¨re une nouvelle image appelÃ©e <code>out.bmp</code> aprÃ¨s avoir fait passer les pixels dans la fonction <code>grayscale</code>. <code>grayscale</code> ne fait encore rien, donc l'image de sortie devrait ressembler Ã  la cour d'origine.</p>
<h2>Astuces</h2>
<ul>
<li>Les valeurs des composants <code>rgbtRed</code>, <code>rgbtGreen</code> et <code>rgbtBlue</code> d'un pixel sont toutes des entiers, alors assurez-vous d'arrondir tout nombre Ã  virgule flottante Ã  l'entier le plus proche lorsque vous l'assignez Ã  une valeur de pixelÂ !</li>
</ul>
<h2>ProcÃ©dure pas Ã  pas</h2>
<p><strong>Veuillez noter qu'il y a 5 vidÃ©os dans cette playlist.</strong></p>
<div class="ratio ratio-16x9" data-video=""><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" class="border" data-video="" src="https://www.youtube.com/embed/vsOsctDernw?modestbranding=0&amp;rel=0&amp;showinfo=1&amp;list=PLhQjrBD2T382OwvMbZuaMGtD9wZkhnhYj"></iframe></div>

<h2>Comment tester</h2>
<p>Assurez-vous de tester tous vos filtres sur les exemples de fichiers bitmap fournisÂ !</p>
<h3>Correction</h3>
<pre><code>  check50 cs50/problems/2024/x/filter/more
</code></pre>
<h3>Style</h3>
<pre><code>  style50 helpers.c
</code></pre>
<h2>Comment soumettre</h2>
<pre><code>  submit50 cs50/problems/2024/x/filter/more
</code></pre>


        </main>
      </div>
    </div>
  </body>

</html>