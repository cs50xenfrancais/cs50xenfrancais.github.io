<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en FranÃ§ais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en FranÃ§ais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch ğŸ˜º
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        MÃ©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de DonnÃ©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        CybersÃ©curitÃ©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">HonnÃªtetÃ© AcadÃ©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions FrÃ©quemment PosÃ©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Ã‰quipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>LeÃ§on 1</h2>
<ul>
<li><a href="#c">C</a></li>
<li><a href="#hello-world">hello, world</a></li>
<li><a href="#compilateurs">Compilateurs</a></li>
<li><a href="#chaÃ®ne">ChaÃ®ne de caractÃ¨res</a></li>
<li><a href="#blocs-scratch-en-c">Blocs Scratch en C</a></li>
<li><a href="#types-formats-opÃ©rateurs">Types, formats, opÃ©rateurs</a></li>
<li><a href="#autres-exemples">Autres exemples</a><ul>
<li><a href="#Ã©crans">Ã‰crans</a></li>
</ul>
</li>
<li><a href="#mÃ©moire-imprÃ©cision-et-dÃ©passement">MÃ©moire, imprÃ©cision, et dÃ©passement</a></li>
</ul>
<h2>C</h2>
<ul>
<li>
<p>Aujourd'hui, nous allons apprendre un nouveau langage, <strong>C</strong> : un langage de programmation qui possÃ¨de toutes les fonctionnalitÃ©s de Scratch et plus encore, mais peut-Ãªtre un peu moins convivial puisqu'il est uniquement en texteÂ :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      printf("hello, world\n");
  }
</code></pre>
<ul>
<li>Bien que les mots soient nouveaux, les idÃ©es sont exactement les mÃªmes que les blocs Â«Â lorsque le drapeau vert est cliquÃ©Â Â»Â et Â«Â dire (hello, world)Â Â» dans ScratchÂ :
  <img alt="bloc intitulÃ© 'lorsque le drapeau vert est cliquÃ©', bloc intitulÃ© 'dire (hello, world)'" src="https://cs50.harvard.edu/x/2020/notes/1/when_green_flag.png" /></li>
</ul>
</li>
<li>
<p>Bien que cryptique, n'oubliez pas que 2/3 des Ã©tudiants de CS50 n'ont jamais suivi de CS auparavant, alors ne soyez pas intimidÃ©Â ! Et bien qu'au dÃ©but, pour emprunter une expression du MIT, essayer d'absorber tous ces nouveaux concepts puisse vous donner l'impression de boire Ã  mÃªme une bouche d'incendie, soyez assurÃ© qu'Ã  la fin du semestre, nous aurons acquis les compÃ©tences et l'expÃ©rience nÃ©cessaires pour apprendre et appliquer ces concepts.</p>
</li>
<li>Nous pouvons comparer de nombreuses constructions en C avec des blocs que nous avons dÃ©jÃ  vus et utilisÃ©s dans Scratch. La syntaxe est bien moins importante que les principes, auxquels nous avons dÃ©jÃ  Ã©tÃ© initiÃ©s.</li>
</ul>
<h2>bonjour, le monde</h2>
<ul>
<li>
<p>Le bloc Â« quand le drapeau vert est cliquÃ© Â» dans Scratch dÃ©marre le programme principal ; le clic sur le drapeau vert dÃ©clenche l'exÃ©cution du bon jeu de blocs ci-dessous. En C, la premiÃ¨re ligne pour le mÃªme est Â« int main(vide) Â», que nous apprendrons plus en dÃ©tail au cours des prochaines semaines, suivie d'une accolade ouvrante Â« { Â» et d'une accolade fermante Â« } Â», englobant tout ce qui devrait Ãªtre dans le programme.</p>
<pre><code>  int main(vide)
  {

  }
</code></pre>
</li>
<li>
<p>Le bloc Â« dire (bonjour, le monde) Â» est une fonction, et correspond Ã  Â« printf("bonjour, le monde"); Â». En C, la fonction pour imprimer quelque chose Ã  l'Ã©cran est Â« printf Â», oÃ¹ Â« f Â» signifie Â« format Â», ce qui signifie que nous pouvons formater la chaÃ®ne imprimÃ©e de diffÃ©rentes maniÃ¨res. Ensuite, nous utilisons des parenthÃ¨ses pour transmettre ce que nous voulons imprimer. Nous devons utiliser des guillemets doubles pour encadrer notre texte afin qu'il soit compris comme du texte, et enfin, nous ajoutons un point-virgule Â« ; Â» pour terminer cette ligne de code.</p>
</li>
<li>
<p>Pour que notre programme fonctionne, nous avons Ã©galement besoin d'une autre ligne en haut, une ligne d'en-tÃªte Â« #include <stdio.h> Â» qui dÃ©finit la fonction Â« printf Â» que nous voulons utiliser. Quelque part sur notre ordinateur, il existe un fichier, Â« stdio.h Â», qui inclut le code qui nous permet d'accÃ©der Ã  la fonction Â« printf Â», et la ligne Â« #include Â» indique Ã  l'ordinateur d'inclure ce fichier dans notre programme.</p>
</li>
<li>
<p>Pour Ã©crire notre premier programme en Scratch, nous avons ouvert le site Web de Scratch. De la mÃªme maniÃ¨re, nous utiliserons le [bac Ã  sable CS50] (https://sandbox.cs50.io/) pour commencer Ã  Ã©crire et Ã  exÃ©cuter du code de la mÃªme maniÃ¨re. Le bac Ã  sable CS50 est un environnement virtuel basÃ© sur le cloud avec les bibliothÃ¨ques et les outils dÃ©jÃ  installÃ©s pour Ã©crire des programmes dans diffÃ©rentes langues. En haut, il y a un simple Ã©diteur de code, dans lequel nous pouvons taper du texte. Ci-dessous, nous avons une fenÃªtre de terminal, dans laquelle nous pouvons taper des commandes :<br />
  ![deux panneaux, le haut intitulÃ© hello.c, le bas intitulÃ© Terminal] (https://cs50.harvard.edu/x/2020/notes/1/cs50_sandbox.png)</p>
</li>
<li>
<p>Nous taperons notre code prÃ©cÃ©dent dans la partie supÃ©rieure, aprÃ¨s avoir utilisÃ© le signe Â« + Â» pour crÃ©er un nouveau fichier appelÃ© Â« hello.c Â» :<br />
  ![bonjour, le monde dans l'Ã©diteur] (https://cs50.harvard.edu/x/2020/notes/1/editor.png)</p>
</li>
<li>
<p>Nous terminons le fichier de notre programme par Â« .c Â» par convention, pour indiquer qu'il est destinÃ© Ã  un programme C. Notez que notre code est colorÃ©, de sorte que certaines choses sont plus visibles.</p>
</li>
</ul>
<h2>Compilateurs</h2>
<ul>
<li>Une fois que nous avons enregistrÃ© le code que nous avons Ã©crit, qui est appelÃ© <strong>code source</strong>, nous devons le convertir en <strong>code machine</strong>, des instructions binaires que l'ordinateur comprend directement.</li>
<li>Nous utilisons un programme appelÃ© <strong>compilateur</strong> pour compiler notre code source en code machine.</li>
<li>Pour ce faire, nous utilisons le panneau <strong>Terminal</strong>, qui dispose d'une <strong>invite de commande</strong>. Le <code>$</code> Ã  gauche est une invite, aprÃ¨s laquelle nous pouvons taper des commandes.<ul>
<li>Nous tapons <code>clang hello.c</code> (oÃ¹ <code>clang</code> signifie Â« langages C Â», un compilateur Ã©crit par un groupe de personnes). Mais avant d'appuyer sur EntrÃ©e, nous cliquons sur l'icÃ´ne de dossier en haut Ã  gauche de CS50 Sandbox. Nous voyons notre fichier, <code>hello.c</code>. Nous appuyons donc sur EntrÃ©e dans la fenÃªtre du terminal et voyons que nous avons maintenant un autre fichier, appelÃ© <code>a.out</code> (abrÃ©viation de Â« sortie d'assemblage Â»). Ã€ l'intÃ©rieur de ce fichier se trouve le code de notre programme, en binaire. Nous pouvons maintenant taper <code>./a.out</code> dans l'invite du terminal pour exÃ©cuter le programme <code>a.out</code> dans notre dossier actuel. Nous venons d'Ã©crire, de compiler et d'exÃ©cuter notre premier programme !</li>
</ul>
</li>
</ul>
<h2>ChaÃ®ne de caractÃ¨res</h2>
<ul>
<li>
<p>Cependant, aprÃ¨s avoir exÃ©cutÃ© notre programme, nous voyons <code>hello, world$</code>, avec la nouvelle invite sur la mÃªme ligne que notre sortie. Il s'avÃ¨re que nous devons spÃ©cifier prÃ©cisÃ©ment que nous avons besoin d'une nouvelle ligne aprÃ¨s notre programme, nous pouvons donc mettre Ã  jour notre code pour inclure un caractÃ¨re de nouvelle ligne spÃ©cial, <code>\n</code>Â :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      printf("hello, world\n");
  }
</code></pre>
<ul>
<li>Maintenant, nous devons penser Ã  recompiler notre programme avec <code>clang hello.c</code> avant de pouvoir exÃ©cuter cette nouvelle version.</li>
</ul>
</li>
<li>
<p>La ligneÂ 2 de notre programme est intentionnellement vide puisque nous voulons dÃ©marrer une nouvelle section de code, un peu comme on commence de nouveaux paragraphes dans les essais. Ce n'est pas strictement nÃ©cessaire pour que notre programme s'exÃ©cute correctement, mais cela aide les humains Ã  lire plus facilement des programmes plus longs.</p>
</li>
<li>Nous pouvons Ã©galement changer le nom de notre programme de <code>a.out</code> Ã  autre chose. Nous pouvons passer des <strong>arguments de ligne de commande</strong>, ou des options supplÃ©mentaires, aux programmes dans le terminal, en fonction de ce que le programme est Ã©crit pour comprendre. Par exemple, nous pouvons taper <code>clang -o hello hello.c</code>, et <code>-o hello</code> indique au programme <code>clang</code> d'enregistrer la sortie compilÃ©e en tant que <code>hello</code>. Ensuite, nous pouvons simplement exÃ©cuter <code>./hello</code>.</li>
<li>
<p>Dans notre invite de commande, nous pouvons exÃ©cuter d'autres commandes, comme <code>ls</code> (liste), qui affiche les fichiers dans notre dossier actuelÂ :</p>
<pre><code>  $ ls
  a.out* hello* hello.c
</code></pre>
<ul>
<li>L'astÃ©risque, <code>*</code>, indique que ces fichiers sont exÃ©cutables, ou qu'ils peuvent Ãªtre exÃ©cutÃ©s par notre ordinateur.</li>
</ul>
</li>
<li>
<p>Nous pouvons utiliser la commande <code>rm</code> (supprimer) pour supprimer un fichierÂ :</p>
<pre><code>  $ rm a.out
  rm: supprimer le fichier rÃ©gulier 'a.out'Â ?
</code></pre>
<ul>
<li>Nous pouvons taper <code>y</code> ou <code>yes</code> pour confirmer, et utiliser Ã  nouveau <code>ls</code> pour voir qu'il a effectivement disparu.</li>
</ul>
</li>
<li>
<p>Maintenant, essayons d'obtenir des informations de l'utilisateur, comme nous l'avons fait dans Scratch lorsque nous voulions dire Â«Â bonjour, DavidÂ Â»Â :<br />
<img alt="Capture d'Ã©cran de blocs Â«Â demander quel est votre nomÂ ? et attendreÂ Â», Â«Â dire joindre bonjour, rÃ©ponseÂ Â»" src="https://cs50.harvard.edu/x/2020/notes/1/ask_say_join.png" /></p>
<pre><code>  string answer = get_string("What's your name?\n");
  printf("hello, %s\n", answer);
</code></pre>
<ul>
<li>Tout d'abord, nous avons besoin d'une <strong>chaÃ®ne de caractÃ¨res</strong>, ou d'un morceau de texte (plus prÃ©cisÃ©ment, zÃ©ro ou plusieurs caractÃ¨res dans une sÃ©quence entre guillemets doubles, comme <code>""</code>, <code>"ba"</code> ou "bananes"), que nous pouvons demander Ã  l'utilisateur, avec la fonction <code>get_string</code>. Nous passons l'invite, ou ce que nous voulons demander Ã  l'utilisateur, Ã  la fonction avec <code>"What is your name?\n"</code> entre parenthÃ¨ses. Sur la gauche, nous voulons crÃ©er une variable, <code>answer</code>, dont la valeur sera ce que l'utilisateur saisit. (Le signe Ã©gal <code>=</code> dÃ©finit la valeur de droite Ã  gauche.) Enfin, le type de variable que nous voulons est <code>string</code>, nous prÃ©cisons donc cela Ã  gauche de <code>answer</code>.</li>
<li>Ensuite, Ã  l'intÃ©rieur de la fonction <code>printf</code>, nous voulons la valeur de <code>answer</code> dans ce que nous imprimons en retour. Nous utilisons un espace rÃ©servÃ© pour notre variable de chaÃ®ne, <code>%s</code>, dans la phrase que nous voulons imprimer, comme <code>"hello, %s\n"</code>, puis nous donnons Ã  <code>printf</code> un autre argument, ou une option, pour lui dire que nous voulons que la variable <code>answer</code> soit remplacÃ©.</li>
</ul>
</li>
<li>
<p>Si nous avons fait une erreur, comme Ã©crire <code>printf("hello, world"\n);</code> avec <code>\n</code> en dehors des guillemets doubles pour notre chaÃ®ne, nous verrons une erreur de notre compilateurÂ :</p>
<pre><code>  $ clang -o hello hello.c
  hello.c:5:26: error: expected ')'
      printf("hello, world"\n);
                           ^
  hello.c:5:11: note: to match this '('
      printf("hello, world"\n);
            ^
  1 error generated.
</code></pre>
<ul>
<li>La premiÃ¨re ligne de l'erreur nous dit de regarder <code>hello.c</code>, ligneÂ 5, colonneÂ 26, oÃ¹ le compilateur attendait une parenthÃ¨se fermante, au lieu d'une barre oblique inverse.</li>
</ul>
</li>
<li>
<p>Pour simplifier les choses (du moins pour le dÃ©but), nous inclurons une bibliothÃ¨que, ou un ensemble de code, de CS50. La bibliothÃ¨que nous fournit le type de variable <code>string</code>, la fonction <code>get_string</code>, et plus encore. Il suffit d'Ã©crire une ligne en haut pour <code>inclure</code> le fichier <code>cs50.h</code>Â :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("What's your name?\n");
      printf("hello, name\n");
  }
</code></pre>
</li>
<li>
<p>CrÃ©ons donc un nouveau fichier, <code>string.c</code>, avec ce codeÂ :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("What's your name?\n");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>Maintenant, si nous essayons de compiler ce code, nous obtenons de nombreuses erreurs. Parfois, une erreur signifie que le compilateur commence alors Ã  interprÃ©ter le code correct de maniÃ¨re incorrecte, gÃ©nÃ©rant plus d'erreurs qu'il n'y en a rÃ©ellement. Nous commenÃ§ons donc par notre premiÃ¨re erreurÂ :</p>
<pre><code>  $ clang -o string string.c
  string.c:5:5: error: use of undeclared identifier 'string'; did you mean 'stdin'?
    string name = get_string("What's your name?\n");
    ^~~~~~
    stdin
  /usr/include/stdio.h:135:25: note: 'stdin' declared here
  extern struct _IO_FILE *stdin;          /* Standard input stream.  */
</code></pre>
<ul>
<li>Nous ne voulions pas dire <code>stdin</code> (Â«Â entrÃ©e standardÂ Â») au lieu de <code>string</code>, donc ce message d'erreur n'Ã©tait pas utile. En fait, nous devons importer un autre fichier qui dÃ©finit le type <code>string</code> (en rÃ©alitÃ© une roue d'entraÃ®nement de CS50, comme nous le dÃ©couvrirons dans les semaines Ã  venir).</li>
</ul>
</li>
<li>
<p>Nous pouvons donc inclure un autre fichier, <code>cs50.h</code>, qui inclut Ã©galement la fonction <code>get_string</code>, entre autres.</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("What's your name?\n");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>Maintenant, lorsque nous essayons de compiler notre programme, nous n'avons qu'une seule erreurÂ :</p>
<pre><code>  $ clang -o string string.c
  /tmp/string-aca94d.o: In function `main':
  string.c:(.text+0x19): undefined reference to `get_string'
  clang-7: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>
<ul>
<li>Il s'avÃ¨re que nous devons Ã©galement indiquer Ã  notre compilateur d'ajouter notre fichier de bibliothÃ¨que CS50 spÃ©cial, avec <code>clang -o string string.c -lcs50</code>, avec <code>-l</code> pour Â«Â lierÂ Â».</li>
</ul>
</li>
<li>
<p>Nous pouvons mÃªme faire abstraction de cela et simplement taper <code>make string</code>. Nous voyons que, par dÃ©faut dans le bac Ã  sable CS50, <code>make</code> utilise <code>clang</code> pour compiler notre code Ã  partir de <code>string.c</code> en <code>string</code>, avec tous les arguments, ou drapeaux, nÃ©cessaires transmis.</p>
</li>
</ul>
<h2>Blocs Scratch en C</h2>
<ul>
<li>
<p>Le bloc â€œmettre [compteur] Ã  (0)â€ crÃ©e une variable ; en C, nous Ã©cririons <code>int compteur = 0 ;</code>, oÃ¹ <code>int</code> prÃ©cise que notre variable est un nombre entier :<br />
<img alt="bloc nommÃ© 'mettre compteur Ã  (0)'" src="https://cs50.harvard.edu/x/2020/notes/1/set_counter_to_0.png" /></p>
</li>
<li>
<p>â€œincrÃ©menter [compteur] de (1)â€ Ã©quivaut en C Ã  <code>compteur = compteur + 1 ;</code>. (En C, le symbole <code>=</code> nâ€™est pas un signe dâ€™Ã©galitÃ©, comme dans une Ã©quation oÃ¹ <code>compteur</code> serait Ã©gal Ã  <code>compteur + 1</code>. Au lieu de cela, <code>=</code> est un opÃ©rateur dâ€™affectation qui signifie Â« copier la valeur de droite dans la valeur de gauche Â».) Et remarquez que nous nâ€™avons plus besoin de prÃ©ciser <code>int</code>, car nous supposons que nous avons dÃ©jÃ  spÃ©cifiÃ© auparavant que <code>compteur</code> est un <code>int</code>, dotÃ© dâ€™une valeur existante. Nous pouvons Ã©galement Ã©crire <code>compteur += 1 ;</code> ou <code>compteur++ ;</code> qui sont tous deux du Â« sucre syntaxique Â», Ã  savoir des raccourcis qui ont le mÃªme effet avec moins de caractÃ¨res Ã  taper.<br />
<img alt="bloc nommÃ© 'incrÃ©menter compteur de (1)'" src="https://cs50.harvard.edu/x/2020/notes/1/change_counter_by_1.png" /></p>
</li>
<li>
<p>Une condition correspondrait Ã  :<br />
<img alt="bloc nommÃ© 'si &lt; (x) &lt; (y) &gt; alors', qui contient un bloc nommÃ© 'dire (x est infÃ©rieur Ã  y)'" src="https://cs50.harvard.edu/x/2020/notes/1/if_x_y.png" /></p>
<pre><code>  if (x &lt; y)
  {
      printf("x est infÃ©rieur Ã  y\n");
  }
</code></pre>
<ul>
<li>Remarquez quâ€™en C nous utilisons les caractÃ¨res <code>{</code> et <code>}</code> (ainsi que lâ€™indentation) pour indiquer comment les lignes de code doivent Ãªtre imbriquÃ©es.</li>
</ul>
</li>
<li>
<p>Nous pouvons Ã©galement avoir des conditions if-else :<br />
<img alt="bloc nommÃ© 'si &lt; (x) &lt; (y) &gt; alors', qui contient un bloc nommÃ© 'dire (x est infÃ©rieur Ã  y)', qui contient Ã©galement un bloc 'sinon', contenant un bloc nommÃ© 'dire (x n'est pas infÃ©rieur Ã  y)'" src="https://cs50.harvard.edu/x/2020/notes/1/if_else.png" /></p>
<pre><code>  if (x &lt; y)
  {
      printf("x est infÃ©rieur Ã  y\n");
  }
  else
  {
      printf("x n'est pas infÃ©rieur Ã  y\n");
  }
</code></pre>
<ul>
<li>Remarquez que les lignes de code qui ne constituent pas elles-mÃªmes une action (<code>if...</code> et les accolades) ne se terminent pas par un point-virgule.</li>
</ul>
</li>
<li>
<p>Et mÃªme <code>else if</code> :
  <img alt="bloc nommÃ© 'si &lt; (x) &lt; (y) &gt; alors', qui contient un bloc nommÃ© 'dire (x est infÃ©rieur Ã  y)', qui contient Ã©galement un bloc 'sinon', Ã  l'intÃ©rieur duquel se trouve un bloc imbriquÃ© nommÃ© 'si &lt; (x) &gt; (y) &gt; alors', contenant un bloc nommÃ© 'dire (x est supÃ©rieur Ã  y)', qui contient Ã©galement un bloc 'sinon', Ã  l'intÃ©rieur duquel se trouve un bloc nommÃ© 'si &lt; (x) = (y) &gt; alors', contenant un bloc nommÃ© 'dire (x est Ã©gal Ã  y)'" src="https://cs50.harvard.edu/x/2020/notes/1/if_else_if.png" /></p>
<pre><code>  if (x &lt; y)
  {
      printf("x est infÃ©rieur Ã  y\n");
  }
  else if (x &gt; y)
  {
      printf("x est supÃ©rieur Ã  y\n");
  }
  else if (x == y)
  {
      printf("x est Ã©gal Ã  y\n");
  }
</code></pre>
<ul>
<li>Remarquez que pour comparer deux valeurs en C, nous utilisons <code>==</code>, soit deux signes Ã©gal.</li>
<li>Et logiquement, nous nâ€™avons pas besoin du <code>if (x == y)</code> dans la condition finale, car câ€™est le seul cas restant et nous pouvons simplement dire <code>else</code>.</li>
</ul>
</li>
<li>
<p>Les boucles peuvent Ãªtre Ã©crites comme suit :<br />
<img alt="bloc nommÃ© 'pour toujours', qui contient un bloc nommÃ© 'dire (bonjour, monde)'" src="https://cs50.harvard.edu/x/2020/notes/1/forever.png" /></p>
<pre><code>  while (true)
  {
      printf("bonjour, monde\n");
  }
</code></pre>
<ul>
<li>Le mot-clÃ© <code>while</code> nÃ©cessite Ã©galement une condition, nous utilisons donc <code>true</code> comme expression boolÃ©enne pour nous assurer que notre boucle fonctionnera indÃ©finiment. Notre programme vÃ©rifiera si lâ€™expression est Ã©valuÃ©e Ã  <code>true</code> (ce qui sera toujours le cas ici), puis exÃ©cutera les lignes Ã  lâ€™intÃ©rieur des accolades. Ensuite, il rÃ©pÃ©tera cette opÃ©ration jusquâ€™Ã  ce que lâ€™expression ne soit plus vraie (ce qui ne changera pas dans ce cas).</li>
</ul>
</li>
<li>
<p>Nous pourrions faire quelque chose un certain nombre de fois avec <code>while</code> :<br />
<img alt="bloc nommÃ© 'rÃ©pÃ©ter (50)', qui contient un bloc nommÃ© 'dire (bonjour, monde)'" src="https://cs50.harvard.edu/x/2020/notes/1/repeat.png" /></p>
<pre><code>  int i = 0;
  while (i &lt; 50)
  {
      printf("bonjour, monde\n");
      i++;
  }
</code></pre>
<ul>
<li>Nous crÃ©ons une variable <code>i</code> et la dÃ©finissons sur 0. Ensuite, tant que <code>i &lt; 50</code>, nous exÃ©cutons des lignes de code, et nous ajoutons 1 Ã  <code>i</code> aprÃ¨s chaque exÃ©cution.</li>
<li>Les accolades autour des deux lignes Ã  lâ€™intÃ©rieur de la boucle <code>while</code> indiquent que ces lignes se rÃ©pÃ©teront, et nous pouvons ajouter des lignes Ã  notre programme aprÃ¨s si nous le souhaitons.</li>
</ul>
</li>
<li>
<p>Pour effectuer la mÃªme rÃ©pÃ©tition, nous pouvons plus couramment utiliser le mot-clÃ© <code>for</code> :</p>
<pre><code>  for (int i = 0; i &lt; 50; i++)
  {
      printf("bonjour, monde\n");
  }
</code></pre>
<ul>
<li>Encore une fois, nous crÃ©ons dâ€™abord une variable nommÃ©e <code>i</code> et la dÃ©finissons sur 0. Ensuite, nous vÃ©rifions que <code>i &lt; 50</code> Ã  chaque fois que nous atteignons le dÃ©but de la boucle, avant dâ€™exÃ©cuter le code Ã  lâ€™intÃ©rieur. Si cette expression est vraie, alors nous exÃ©cutons le code Ã  lâ€™intÃ©rieur. Enfin, aprÃ¨s avoir exÃ©cutÃ© le code Ã  lâ€™intÃ©rieur, nous utilisons <code>i++</code> pour ajouter un Ã  <code>i</code> et la boucle se rÃ©pÃ¨te.</li>
</ul>
</li>
</ul>
<h2>Types, formats, operateurs</h2>
<ul>
<li>On peut utiliser d'autres types pour nos variables :<ul>
<li><code>bool</code>, une expression boolÃ©enne de valeur <code>true</code> ou <code>false</code></li>
<li><code>char</code>, un seul caractÃ¨re comme <code>a</code> ou <code>2</code></li>
<li><code>double</code>, une valeur Ã  virgule flottante avec encore plus de chiffres</li>
<li><code>float</code>, une valeur Ã  virgule flottante, ou un nombre rÃ©el avec une valeur dÃ©cimale</li>
<li><code>int</code>, des entiers jusqu'Ã  une certaine taille, ou nombre de bits</li>
<li><code>long</code>, des entiers avec plus de bits, ce qui leur permet de compter plus haut</li>
<li><code>string</code>, une chaÃ®ne de caractÃ¨res</li>
</ul>
</li>
<li>Et la bibliothÃ¨que CS50 dispose des fonctions correspondantes pour obtenir des entrÃ©es de diffÃ©rents types :<ul>
<li><code>get_char</code></li>
<li><code>get_double</code></li>
<li><code>get_float</code></li>
<li><code>get_int</code></li>
<li><code>get_long</code></li>
<li><code>get_string</code></li>
</ul>
</li>
<li>Pour <code>printf</code> aussi, il existe diffÃ©rents espaces rÃ©servÃ©s pour chaque type :<ul>
<li><code>%c</code> pour les caractÃ¨res</li>
<li><code>%f</code> pour les flottants, doubles</li>
<li><code>%i</code> pour les entiers</li>
<li><code>%li</code> pour les longs</li>
<li><code>%s</code> pour les chaÃ®nes</li>
</ul>
</li>
<li>Et il existe des opÃ©rateurs mathÃ©matiques que nous pouvons utiliser :<ul>
<li><code>+</code> pour l'addition</li>
<li><code>-</code> pour la soustraction</li>
<li><code>*</code> pour la multiplication</li>
<li><code>/</code> pour la division</li>
<li><code>%</code> pour le reste</li>
</ul>
</li>
</ul>
<h1>Plus d'exemples</h1>
<ul>
<li>Pour chacun de ces exemples, vous pouvez cliquer sur les <a href="../../weeks/1/">liens du bac Ã  sable</a> pour lancer et modifier vos propres copies.</li>
<li>
<p>Dans <code>int.c</code>, nous rÃ©cupÃ©rons et affichons un entier :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      int age = get_int("Quel Ã¢ge avez-vousÂ ?\n");
      int jours = age * 365;
      printf("Vous avez au moins %i jours.\n", jours);
  }
</code></pre>
<ul>
<li>Notez que nous utilisons <code>%i</code> pour afficher un entier.</li>
<li>Nous pouvons maintenant lancer <code>make int</code> et lancer notre programme avec <code>./int</code>.</li>
<li>
<p>Nous pouvons combiner des lignes et supprimer la variable <code>jours</code> avecÂ :</p>
<pre><code>  int age = get_int("Quel Ã¢ge avez-vousÂ ?\n");
  printf("Vous avez au moins %i jours.\n", age * 365);
</code></pre>
</li>
<li>
<p>Ou mÃªme tout combiner sur une ligneÂ :</p>
<pre><code>  printf("Vous avez au moins %i jours.\n", get_int("Quel Ã¢ge avez-vousÂ ?\n") * 365);
</code></pre>
</li>
<li>
<p>Cependant, si une ligne devient trop longue ou trop compliquÃ©e, il peut Ãªtre prÃ©fÃ©rable de conserver deux ou trois lignes pour plus de lisibilitÃ©.</p>
</li>
</ul>
</li>
<li>
<p>Dans <code>float.c</code>, nous pouvons rÃ©cupÃ©rer des nombres dÃ©cimaux (ce qu'on appelle des valeurs Ã  virgule flottante en informatique, parce que la virgule dÃ©cimale peut Â«Â flotterÂ Â» entre les chiffres, en fonction du nombreÂ ):</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      float prix = get_float("Quel est le prixÂ ?\n");
      printf("Votre total est de %f.\n", prix * 1,0625);
  }
</code></pre>
<ul>
<li>Maintenant, si nous compilons et lanÃ§ons notre programme, nous verrons un prix affichÃ© avec la taxe.</li>
<li>Nous pouvons spÃ©cifier le nombre de chiffres imprimÃ©s aprÃ¨s la virgule dÃ©cimale avec un espace rÃ©servÃ© tel que <code>%.2f</code> pour deux chiffres aprÃ¨s la virgule dÃ©cimale.</li>
</ul>
</li>
<li>
<p>Avec <code>parity.c</code>, nous pouvons vÃ©rifier si un nombre est pair ou impairÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      int n = get_int("nÂ : ");

      if (n % 2 == 0)
      {
          printf("pair\n");
      }
      else
      {
          printf("impair\n");
      }
  }
</code></pre>
<ul>
<li>Avec l'opÃ©rateur <code>%</code> (modulo), nous pouvons obtenir le reste de <code>n</code> aprÃ¨s sa division par 2. Si le reste est 0, nous savons que <code>n</code> est pair. Sinon, nous savons que <code>n</code> est impair.</li>
<li>De plus, des fonctions comme <code>get_int</code> de la bibliothÃ¨que CS50 effectuent une vÃ©rification des erreurs, oÃ¹ seules les entrÃ©es de l'utilisateur correspondant au type que nous voulons sont acceptÃ©es.</li>
</ul>
</li>
<li>
<p>Dans <code>conditions.c</code>, nous transformons les extraits de conditions prÃ©cÃ©dents en un programmeÂ :</p>
<pre><code>  // Conditions et opÃ©rateurs relationnels

  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Demander Ã  l'utilisateur de saisir x
      int x = get_int("xÂ : ");

      // Demander Ã  l'utilisateur de saisir y
      int y = get_int("yÂ : ");

      // Comparer x et y
      if (x &lt; y)
      {
          printf("x est infÃ©rieur Ã  y\n");
      }
      else if (x &gt; y)
      {
          printf("x est supÃ©rieur Ã  y\n");
      }
      else
      {
          printf("x est Ã©gal Ã  y\n");
      }
  }
</code></pre>
<ul>
<li>Les lignes commenÃ§ant par <code>//</code> sont des commentaires ou des notes pour les humains que le compilateur ignorera.</li>
<li>Pour que David compile et exÃ©cute ce programme dans son bac Ã  sable, il devait d'abord exÃ©cuter <code>cd src1</code> dans le terminal. Cela change le rÃ©pertoire, ou dossier, en celui dans lequel il a enregistrÃ© tous les fichiers sources du cours. Ensuite, il pouvait exÃ©cuter <code>make conditions</code> et <code>./conditions</code>. Avec <code>pwd</code>, il peut voir qu'il se trouve dans un dossier <code>src1</code> (Ã  l'intÃ©rieur d'autres dossiers). Et <code>cd</code> tout seul, sans arguments, nous ramÃ¨nera Ã  notre dossier par dÃ©faut dans le bac Ã  sable.</li>
</ul>
</li>
<li>
<p>Dans <code>agree.c</code>, nous pouvons demander Ã  l'utilisateur de confirmer ou d'infirmer quelque choseÂ :</p>
<pre><code>  // OpÃ©rateurs logiques

  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Demander Ã  l'utilisateur d'accepter
      char c = get_char("ÃŠtes-vous d'accordÂ ?\n");

      // VÃ©rifier si l'utilisateur est d'accord
      if (c == 'Y' || c == 'y')
      {
          printf("D'accord.\n");
      }
      else if (c == 'N' || c == 'n')
      {
          printf("Pas d'accord.\n");
      }
  }
</code></pre>
<ul>
<li>Nous utilisons deux barres verticales, <code>||</code>, pour indiquer un Â«Â ouÂ Â» logique, indiquant que l'une ou l'autre expression peut Ãªtre vraie pour que la condition soit suivie.</li>
<li>Et si aucune des expressions n'est vraie, rien ne se passera puisque notre programme n'a pas de boucle.</li>
</ul>
</li>
<li>
<p>Mettons en oeuvre le programme de toux depuis la semaine 0 :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      printf("toux\n");
      printf("toux\n");
      printf("toux\n");
  }
</code></pre>
</li>
<li>
<p>Nous pourrions utiliser une boucle <code>for</code> :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      for (int i = 0; i &lt; 3; i++)
      {
          printf("toux\n");
      }
  }
</code></pre>
<ul>
<li>Par convention, les programmeurs ont tendance Ã  commencer Ã  compter Ã  0, ainsi <code>i</code> aura le valeurs <code>0</code>, <code>1</code> et <code>2</code> avant de s'arrÃªter, pour un total de trois itÃ©rations. Nous pourrions Ã©galement Ã©crire <code>for (int i = 1; i &lt;= 3; i++)</code> pour le mÃªme effet final.</li>
</ul>
</li>
<li>
<p>Nous pouvons dÃ©placer la ligne <code>printf</code> vers sa propre fonction:</p>
<pre><code>  #include &lt;stdio.h&gt;

  void toux(void);

  int main(void)
  {
      for (int i = 0; i &lt; 3; i++)
      {
          toux();
      }
  }

  void toux(void)
  {
      printf("toux\n");
  }
</code></pre>
<ul>
<li>Nous dÃ©clarons une nouvelle fonction avec <code>void toux(void);</code>, avant que notre fonction <code>main</code> ne l'appelle. Le compilateur C lit notre code de haut en bas, nous devons donc lui indiquer que la fonction <code>toux</code> existe, avant que nous l'utilisions. Puis, aprÃ¨s notre fonction <code>main</code>, nous pouvons implÃ©menter la fonction <code>toux</code>. De cette faÃ§on, le compilateur sait que la fonction existe, et nous pouvons garder notre fonction <code>main</code> prÃ¨s du dÃ©but.</li>
<li>Et notre fonction <code>toux</code> ne prend aucune entrÃ©e, nous avons donc <code>toux(void)</code>.</li>
</ul>
</li>
<li>
<p>Nous pouvons abstraire d'avantage <code>toux</code> :</p>
<pre><code>  #include &lt;stdio.h&gt;

  void toux(int n);

  int main(void)
  {
      toux(3);
  }

  void toux(int n)
  {
      for (int i = 0; i &lt; n; i++)
      {
          printf("toux\n");
      }
  }
</code></pre>
<ul>
<li>Maintenant, quand nous voulons afficher "toux" un certain nombre de fois, nous pouvons simplement appeler la mÃªme fonction. Notez qu'avec <code>void toux(int n)</code>, nous indiquons que la fonction <code>toux</code> prend en entrÃ©e un <code>int</code>, auquel nous nous rÃ©fÃ©rons comme <code>n</code>. Et Ã  l'intÃ©rieur de <code>toux</code>, nous utilisons <code>n</code> dans notre boucle <code>for</code> pour afficher "toux" le bon nombre de fois.</li>
</ul>
</li>
<li>
<p>Regardons <code>positive.c</code> :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int get_positive_int(void);

  int main(void)
  {
      int i = get_positive_int();
      printf("%i\n", i);
  }

  // Demander Ã  l'utilisateur un entier positif
  int get_positive_int(void)
  {
      int n;
      do
      {
          n = get_int("%s", "Entier positif : ");
      }
      while (n &lt; 1);
      return n;
  }
</code></pre>
<ul>
<li>La bibliothÃ¨que CS50 n'a pas de fonction <code>get_positive_int</code>, mais nous pouvons en Ã©crire une nous-mÃªmes. Notre fonction <code>int get_positive_int(void)</code> demande Ã  l'utilisateur un <code>int</code> et retourne cet <code>int</code>, que notre fonction <code>main</code> stocke comme <code>i</code>. Dans <code>get_positive_int</code>, nous initialisons une variable, <code>int n</code>, sans encore lui assigner de valeur. Puis, nous avons une nouvelle construction, <code>do ... while</code>, qui fait quelque chose <em>en premier</em>, puis vÃ©rifie une condition, et rÃ©pÃ¨te cela jusqu'Ã  ce que la condition ne soit plus vraie.</li>
<li>Une fois que la boucle se termine parce qu'on a un <code>n</code> qui n'est pas <code>&lt; 1</code>, on peut le retourner avec le mot-clÃ© <code>return</code>. Et de retour dans notre fonction <code>main</code>, on peut dÃ©finir <code>int i</code> sur cette valeur.</li>
</ul>
</li>
</ul>
<h2>Ã‰crans</h2>
<ul>
<li>
<p>Nous pourrions avoir besoin d'un programme qui imprime une partie d'Ã©cran d'un jeu vidÃ©o comme Super Mario Bros. Dans <code>mario0.c</code>, nous avons :</p>
<pre><code>  // Affiche une ligne de 4 points d'interrogation

  #include &lt;stdio.h&gt;

  int main(void)
  {
      printf("????\n");
  }
</code></pre>
</li>
<li>
<p>Nous pouvons demander Ã  l'utilisateur un nombre de points d'interrogation, puis les imprimer avec <code>mario2.c</code> :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      int n;
      do
      {
          n = get_int("Largeur : ");
      }
      while (n &lt; 1);
      for (int i = 0; i &lt; n; i++)
      {
          printf("?");
      }
      printf("\n");
  }
</code></pre>
</li>
<li>
<p>Et nous pouvons imprimer un ensemble bidimensionnel de blocs avec <code>mario8.c</code> :</p>
<pre><code>  // Affiche une grille de briques n-par-n avec une boucle

  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      int n;
      do
      {
          n = get_int("Taille : ");
      }
      while (n &lt; 1);
      for (int i = 0; i &lt; n; i++)
      {
          for (int j = 0; j &lt; n; j++)
          {
              printf("#");
          }
          printf("\n");
      }
  }
</code></pre>
</li>
<li>
<p>Notez que nous avons deux boucles imbriquÃ©es, oÃ¹ la boucle externe utilise <code>i</code> pour tout faire Ã  l'intÃ©rieur <code>n</code> fois, et la boucle interne utilise <code>j</code>, une variable diffÃ©rente, pour faire quelque chose <code>n</code> fois pour chacune de <em>ces</em> fois. En d'autres termes, la boucle externe imprime <code>n</code> Â« lignes Â» ou lignes, et la boucle interne imprime <code>n</code> Â« colonnes Â» ou caractÃ¨res <code>#</code> dans chaque ligne.</p>
</li>
<li>
<p>D'autres exemples non abordÃ©s en cours sont disponibles sous Â« Code source Â» pour <a href="../../weeks/1/">Semaine 1</a>.</p>
</li>
</ul>
<h1>MÃ©moire, imprÃ©cision et dÃ©passement de capacitÃ©</h1>
<ul>
<li>Notre ordinateur possÃ¨de une mÃ©moire, dans des puces de matÃ©riel appelÃ©es RAM, mÃ©moire Ã  accÃ¨s alÃ©atoire. Nos programmes utilisent cette RAM pour stocker des donnÃ©es pendant leur exÃ©cution, mais cette mÃ©moire est finie. Donc, avec un nombre fini de bits, nous ne pouvons pas reprÃ©senter tous les nombres possibles (dont il existe un nombre infini). Ainsi, notre ordinateur dispose d'un certain nombre de bits pour chaque flottant et entier, et doit arrondir Ã  une valeur dÃ©cimale donnÃ©e Ã  un certain moment.</li>
<li>
<p>Avec <code>floats.c</code>, nous pouvons voir ce qui se passe lorsque nous utilisons des flottants :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Invite l'utilisateur Ã  saisir x
      float x = get_float("x: ");

      // Invite l'utilisateur Ã  saisir y
      float y = get_float("y: ");

      // Effectue une division
      printf("x / y = %.50f\n", x / y);
  }
</code></pre>
<ul>
<li>Avec <code>%50f</code>, nous pouvons spÃ©cifier le nombre de dÃ©cimales affichÃ©es.</li>
<li>
<p>Hum, maintenant nous obtenons â€¦</p>
<pre><code>  x: 1
  y: 10
  x / y = 0.10000000149011611938476562500000000000000000000000
</code></pre>
</li>
<li>
<p>Il s'avÃ¨re que cela s'appelle <strong>l'imprÃ©cision en virgule flottante</strong>, oÃ¹ nous n'avons pas assez de bits pour stocker toutes les valeurs possibles, de sorte que l'ordinateur doit stocker la valeur la plus proche possible de 1 divisÃ© par 10.</p>
</li>
</ul>
</li>
<li>
<p>Nous pouvons voir un problÃ¨me similaire dans <code>overflow.c</code> :</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;unistd.h&gt;

  int main(void)
  {
      for (int i = 1; ; i *= 2)
      {
          printf("%i\n", i);
          sleep(1);
      }
  }
</code></pre>
<ul>
<li>Dans notre boucle <code>pour</code>, nous dÃ©finissons <code>i</code> sur <code>1</code> et le multiplions par <code>*= 2</code>. (Et nous allons continuer Ã  le faire indÃ©finiment, donc il n'y a pas de condition que nous vÃ©rifions.)</li>
<li>Nous utilisons Ã©galement la fonction <code>sleep</code> de <code>unistd.h</code> pour permettre Ã  notre programme de faire une pause Ã  chaque fois.</li>
<li>
<p>Maintenant, lorsque nous exÃ©cutons ce programme, nous voyons le nombre augmenter de plus en plus, jusqu'Ã  :</p>
<pre><code>  1073741824
  overflow.c:6:25: erreur d'exÃ©cution: dÃ©passement d'entier signÃ©: 1073741824 * 2 ne peut pas Ãªtre reprÃ©sentÃ© dans le type 'int'
  -2147483648
  0
  0
  ...
</code></pre>
</li>
<li>
<p>Il s'avÃ¨re que notre programme a reconnu qu'un entier signÃ© (un entier avec un signe positif ou nÃ©gatif) ne pouvait pas stocker cette prochaine valeur et a imprimÃ© une erreur. Ensuite, puisqu'il essayait de le doubler quand mÃªme, <code>i</code> est devenu un nombre nÃ©gatif, puis 0.</p>
</li>
<li>Ce problÃ¨me est appelÃ© <strong>dÃ©passement de capacitÃ© d'entier</strong>, oÃ¹ un entier ne peut Ãªtre que si grand avant de manquer de bits et de Â« dÃ©border Â». Nous pouvons imaginer ajouter 1 Ã  999 en dÃ©cimal. Le dernier chiffre devient 0, nous reportons le 1 pour que le chiffre suivant devienne 0, et nous obtenons 1000. Mais si nous n'avions que trois chiffres, nous nous retrouverions avec 000 car il n'y a pas de place pour mettre le 1 final !</li>
</ul>
</li>
<li>
<p>Le problÃ¨me Y2K est survenu parce que de nombreux programmes stockaient l'annÃ©e civile avec seulement deux chiffres, comme 98 pour 1998 et 99 pour 1999. Mais Ã  l'approche de l'an 2000, les programmes auraient stockÃ© 00, ce qui entraÃ®nerait une confusion entre les annÃ©es 1900 et 2000.</p>
</li>
<li>Un avion Boeing 787 avait Ã©galement un bug oÃ¹ un compteur dans le gÃ©nÃ©rateur dÃ©bordait aprÃ¨s un certain nombre de jours de fonctionnement continu, car le nombre de secondes de fonctionnement ne pouvait plus Ãªtre stockÃ© dans ce compteur.</li>
<li>Donc, nous avons vu quelques problÃ¨mes qui peuvent survenir, mais maintenant nous comprenons pourquoi et comment les Ã©viter.</li>
<li>Avec le problÃ¨me de la semaine, nous utiliserons le CS50 Lab, basÃ© sur le CS50 Sandbox, pour Ã©crire quelques programmes avec des procÃ©dures pas Ã  pas pour nous guider.</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>