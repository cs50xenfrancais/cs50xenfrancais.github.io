<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Fran√ßais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en Fran√ßais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        M√©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de Donn√©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        Cybers√©curit√©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">Honn√™tet√© Acad√©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions Fr√©quemment Pos√©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">√âquipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>S√©ance 5</h1>
<ul>
<li><a href="#pointers">Pointeurs</a></li>
<li><a href="#resizing-arrays">Redimensionnement de tableaux</a></li>
<li><a href="#data-structures">Structures de donn√©es</a></li>
<li><a href="#linked-lists">Listes cha√Æn√©es</a></li>
<li><a href="#more-data-structures">Autres structures de donn√©es</a></li>
</ul>
<h2>Pointeurs</h2>
<ul>
<li>La derni√®re fois, nous avons appris les pointeurs, <code>malloc</code>, et d‚Äôautres outils utiles pour travailler avec la m√©moire.</li>
<li>
<p>R√©visons ce bout de code¬†:</p>
<pre><code>  int main(void)
  {
      int *x;
      int *y;

      x = malloc(sizeof(int));

      *x = 42;
      *y = 13;
  }
</code></pre>
<ul>
<li>Ici, les deux premi√®res lignes de code dans notre fonction <code>main</code> d√©clarent deux pointeurs, <code>x</code> et <code>y</code>. Puis, nous allouons assez de m√©moire pour un <code>int</code> avec <code>malloc</code>, et stockons l‚Äôadresse retourn√©e par <code>malloc</code> dans <code>x</code>.</li>
<li>Avec <code>*x = 42;</code>, nous allons √† l‚Äôadresse point√©e par <code>x</code> et y stockons la valeur <code>42</code> √† cet emplacement.</li>
<li>
<p>La derni√®re ligne, cependant, est bogu√©e, puisque nous ne savons pas quelle est la valeur de <code>y</code>, puisque nous ne lui avons jamais attribu√© de valeur. √Ä la place, nous pouvons √©crire¬†:</p>
<pre><code>  y = x;
  *y = 13;
</code></pre>
<ul>
<li>Et ceci fera pointer <code>y</code> sur le m√™me emplacement que <code>x</code>, et ensuite attribuera la valeur <code>13</code> √† cet emplacement.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Nous jetons un ≈ìil √† un court clip, <a href="https://www.youtube.com/watch?v=3uLKjb973HU">Pointer Fun with Binky</a>, qui explique aussi ce bout de code de mani√®re anim√©e¬†!</p>
</li>
</ul>
<h2>Redimensionnement de tableaux</h2>
<ul>
<li>Au cours de la semaine 2, nous avons appris sur les tableaux, o√π nous pouvions stocker le m√™me type de valeur dans une liste, c√¥te √† c√¥te. Mais nous devons d√©clarer la taille des tableaux lorsque nous les cr√©ons, et lorsque nous voulons augmenter la taille du tableau, la m√©moire qui l'entoure peut √™tre occup√©e par d'autres donn√©es.</li>
<li>Une solution pourrait √™tre d'allouer plus de m√©moire dans une zone plus grande qui est libre, et d'y d√©placer notre tableau, o√π il a plus d'espace. Mais nous devrons copier notre tableau, ce qui devient une op√©ration avec un temps d'ex√©cution de <em>O</em>(<em>n</em>), car nous devons copier chacun des <em>n</em> √©l√©ments dans un tableau.</li>
<li>
<p>Nous pourrions √©crire un programme comme celui qui suit, pour le faire dans le code :</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(void)
  {
      // Ici, nous allouons suffisamment de m√©moire pour accueillir trois entiers, et notre variable
      // list pointera vers le premier entier.
      int *list = malloc(3 * sizeof(int));
      // Nous devrions v√©rifier que nous avons correctement allou√© de la m√©moire, car malloc pourrait
      // ne pas obtenir suffisamment de m√©moire libre.
      if (list == NULL)
      {
          return 1;
      }

      // Avec cette syntaxe, le compilateur effectuera l'arithm√©tique des pointeurs pour nous, et
      // calculera l'octet en m√©moire auquel list[0], list[1] et list[2] sont mapp√©s,
      // puisque les entiers font 4 octets.
      list[0] = 1;
      list[1] = 2;
      list[2] = 3;

      // Maintenant, si nous voulons redimensionner notre tableau pour accueillir 4 entiers, nous allons essayer d'allouer
      // suffisamment de m√©moire pour eux, et utiliser temporairement tmp pour pointer vers le premier :
      int *tmp = malloc(4 * sizeof(int));
      if (tmp == NULL)
      {
          return 1;
      }

      // Maintenant, nous copions les entiers de l'ancien tableau dans le nouveau tableau ...
      for (int i = 0; i &lt; 3; i++)
      {
          tmp[i] = list[i];
      }

      // ... et ajoutons le quatri√®me entier :
      tmp[3] = 4;

      // Nous devrions lib√©rer la m√©moire d'origine pour list, c'est pourquoi nous avons besoin d'une
      // variable temporaire pour pointer vers le nouveau tableau ...
      free(list);

      // ... et maintenant nous pouvons d√©finir notre variable list pour qu'elle pointe vers le nouveau tableau que
      // tmp indique :
      list = tmp;

      // Maintenant, nous pouvons imprimer le nouveau tableau :
      for (int i = 0; i &lt; 4; i++)
      {
          printf("%i\n", list[i]);
      }

      // Et enfin, lib√©rer la m√©moire du nouveau tableau.
      free(list);
  }
</code></pre>
</li>
<li>
<p>Il s'av√®re qu'il existe en fait une fonction utile, <code>realloc</code>, qui r√©allouera de la m√©moire :</p>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  int main(void)
  {
      int *list = malloc(3 * sizeof(int));
      if (list == NULL)
      {
          return 1;
      }

      list[0] = 1;
      list[1] = 2;
      list[2] = 3;

      // Ici, nous donnons √† realloc notre tableau d'origine sur lequel list pointe, et il
      // renverra une nouvelle adresse pour un nouveau tableau, avec les anciennes donn√©es copi√©es :
      int *tmp = realloc(list, 4 * sizeof(int));
      if (tmp == NULL)
      {
          return 1;
      }
      // Maintenant, tout ce que nous avons √† faire est de m√©moriser l'emplacement du nouveau tableau :
      list = tmp;

      list[3] = 4;

      for (int i = 0; i &lt; 4; i++)
      {
          printf("%i\n", list[i]);
      }

      free(list);
  }
</code></pre>
</li>
</ul>
<h2>Structures de donn√©es</h2>
<ul>
<li>Les <strong>Structures de donn√©es</strong> sont des structures de programmation qui nous permettent de stocker des informations selon diff√©rentes dispositions, dans la m√©moire de notre ordinateur.</li>
<li>Pour construire une structure de donn√©es, nous allons utiliser quelques outils que nous avons vu :<ul>
<li><code>struct</code> pour cr√©er des types de donn√©es personnalis√©s</li>
<li><code>.</code> pour acc√©der aux propri√©t√©s d'une structure</li>
<li><code>*</code> pour aller √† une adresse en m√©moire point√©e par un pointeur</li>
</ul>
</li>
</ul>
<h2>Listes cha√Æn√©es</h2>
<ul>
<li>
<p>Avec une <strong>liste cha√Æn√©e</strong>, nous pouvons stocker une liste de valeurs qui peut facilement √™tre √©tendue en stockant des valeurs dans diff√©rentes parties de la m√©moire¬†:</p>
<p><img alt="grille repr√©sentant la m√©moire, avec trois bo√Ætes √©tiquet√©es avec des bo√Ætes vides entre elles, chacune √©tiquet√©e 1 0x123, 2 0x456, et 3 0x789" src="https://cs50.harvard.edu/x/2020/notes/5/linked_list.png" /></p>
<ul>
<li>C‚Äôest diff√©rent d‚Äôun tableau car nos valeurs ne sont plus les unes √† c√¥t√© des autres en m√©moire.</li>
</ul>
</li>
<li>
<p>Nous pouvons lier notre liste ensemble en allouant, pour chaque √©l√©ment, suffisamment de m√©moire pour la valeur que nous voulons stocker, et pour l‚Äôadresse de l‚Äô√©l√©ment suivant¬†:</p>
<p><img alt="trois cases, chacune divis√©e en deux et √©tiquet√©e (1 0x123 et 0x456), (2 0x456 et 0x789), et (3 0x789 et NULL)" src="https://cs50.harvard.edu/x/2020/notes/5/linked_list_with_addresses.png" /></p>
<ul>
<li>Au fait, <code>NUL</code> fait r√©f√©rence √† <code>\0</code>, un caract√®re qui termine une cha√Æne de caract√®res, et <code>NULL</code> fait r√©f√©rence √† une adresse de tous les z√©ros, ou un pointeur nul que nous pouvons consid√©rer comme pointant vers nulle part.</li>
</ul>
</li>
<li>
<p>Contrairement √† ce que nous pouvons faire avec des tableaux, nous n‚Äôavons plus acc√®s al√©atoire aux √©l√©ments d‚Äôune liste cha√Æn√©e. Par exemple, nous ne pouvons plus acc√©der au 5e √©l√©ment de la liste en calculant o√π il se trouve, en temps constant. (Sachant que les tableaux stockent les √©l√©ments bout √† bout, nous pouvons ajouter 1, ou 4, ou la taille de notre √©l√©ment, pour calculer les adresses.) Au lieu de cela, nous devons suivre le pointeur de chaque √©l√©ment, un √† la fois. Et nous devons allouer deux fois plus de m√©moire que n√©cessaire auparavant pour chaque √©l√©ment.</p>
</li>
<li>
<p>En code, nous pouvons cr√©er notre propre structure appel√©e <code>node</code> (comme un n≈ìud d‚Äôun graphe en math√©matiques), et nous devons stocker √† la fois un <code>int</code> et un pointeur vers le prochain <code>node</code> appel√© <code>next</code>¬†:</p>
<pre><code>  typedef struct node
  {
      int number;
      struct node *next;
  }
  node;
</code></pre>
<ul>
<li>Nous commen√ßons cette structure par <code>typedef struct node</code> de sorte que nous puissions faire r√©f√©rence √† un <code>node</code> √† l‚Äôint√©rieur de notre structure.</li>
</ul>
</li>
<li>
<p>Nous pouvons construire une liste cha√Æn√©e en code en commen√ßant par notre structure. Tout d‚Äôabord, nous allons vouloir nous souvenir d‚Äôune liste vide, nous pouvons donc utiliser le pointeur null¬†: <code>node *list = NULL;</code>.</p>
</li>
<li>
<p>Pour ajouter un √©l√©ment, nous aurons d‚Äôabord besoin d‚Äôallouer de la m√©moire pour un n≈ìud et de d√©finir ses valeurs¬†:</p>
<pre><code>  node *n = malloc(sizeof(node));
  // Nous voulons nous assurer que malloc a r√©ussi √† obtenir de la m√©moire pour nous¬†:
  if (n != NULL)
  {
      // Cela √©quivaut √† (*n).number, o√π nous allons d'abord au n≈ìud point√©
      // par n, puis d√©finissons la propri√©t√© number. En C, nous pouvons √©galement
      // utiliser cette notation de fl√®che¬†:
      n-&gt;number = 2;
      // Ensuite, nous devons stocker un pointeur vers le n≈ìud suivant de notre liste,
      // mais le nouveau n≈ìud ne pointera vers rien (pour l‚Äôinstant)¬†:
      n-&gt;next = NULL;
  }
</code></pre>
</li>
<li>
<p>Maintenant, notre liste peut pointer vers ce n≈ìud¬†: <code>list = n;</code>¬†:</p>
<p><img alt="une case √©tiquet√©e liste avec une fl√®che vers l‚Äôext√©rieur pointant vers deux cases connect√©es, une avec 2 et une vide)" src="https://cs50.harvard.edu/x/2020/notes/5/list_with_one_node.png" /></p>
</li>
<li>
<p>Pour ajouter √† la liste, nous allons cr√©er un nouveau n≈ìud de la m√™me mani√®re, peut-√™tre avec la valeur 4. Mais maintenant, nous devons mettre √† jour le pointeur dans notre premier n≈ìud pour qu‚Äôil y pointe.</p>
</li>
<li>
<p>√âtant donn√© que notre pointeur <code>list</code> pointe uniquement vers le premier n≈ìud (et nous ne pouvons pas √™tre s√ªrs que la liste ne comporte qu‚Äôun seul n≈ìud), nous devons ¬´¬†suivre les miettes de pain¬†¬ª et suivre le pointeur suivant de chaque n≈ìud¬†:</p>
<pre><code>  // Cr√©er un pointeur temporaire vers ce que pointe list
  node *tmp = list;
  // Tant que le n≈ìud a un pointeur suivant ...
  while (tmp-&gt;next != NULL)
  {
      // ... d√©finir le temporaire au n≈ìud suivant
      tmp = tmp-&gt;next;
  }
  // Maintenant, tmp pointe vers le dernier n≈ìud de notre liste, et nous pouvons mettre
  // √† jour son pointeur suivant pour qu'il pointe vers notre nouveau n≈ìud.
</code></pre>
</li>
<li>
<p>Si nous voulons ins√©rer un n≈ìud au d√©but de notre liste cha√Æn√©e, nous devons soigneusement mettre √† jour notre n≈ìud pour qu‚Äôil pointe vers celui qui le suit, avant de mettre √† jour la liste. Sinon, nous perdrons le reste de notre liste¬†:</p>
<pre><code>  // Ici, nous ins√©rons un n≈ìud au d√©but de la liste, nous voulons donc que son
  // pointeur suivant pointe vers la liste d'origine, avant de pointer la liste vers
  // n¬†:
  n-&gt;next = list;
  list = n;
</code></pre>
</li>
<li>
<p>Et pour ins√©rer un n≈ìud au milieu de notre liste, nous pouvons parcourir la liste, en suivant chaque √©l√©ment un √† la fois, en comparant ses valeurs et en modifiant √©galement avec soin les pointeurs <code>next</code>.</p>
</li>
<li>
<p>Avec quelques volontaires sur sc√®ne, nous simulons une liste, chaque volontaire agissant comme la variable <code>list</code> ou un n≈ìud. Au fur et √† mesure que nous ins√©rons des n≈ìuds dans la liste, nous avons besoin d‚Äôun pointeur temporaire pour suivre la liste et nous assurer de ne perdre aucune partie de notre liste. Notre liste cha√Æn√©e ne pointe que vers le premier n≈ìud de notre liste, nous ne pouvons donc regarder qu'un n≈ìud √† la fois, mais nous pouvons allouer dynamiquement plus de m√©moire au fur et √† mesure que nous devons agrandir notre liste.</p>
</li>
<li>
<p>D√©sormais, m√™me si notre liste cha√Æn√©e est tri√©e, le temps de recherche sera de <em>O</em>(<em>n</em>), car nous devons parcourir chaque n≈ìud afin de v√©rifier ses valeurs et nous ne savons pas o√π se situe le milieu de notre liste.</p>
</li>
<li>Nous pouvons combiner tous nos fragments de code en un programme complet¬†:<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;

  // Repr√©sente un n≈ìud
  typedef struct node
  {
      int number;
      struct node *next;
  }
  node;

  int main(void)
  {
      // Liste de taille 0, qui ne pointe initialement vers rien
      node *list = NULL;

      // Ajouter un nombre √† la liste
      node *n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }
      n-&gt;number = 1;
      n-&gt;next = NULL;
      // Nous cr√©ons notre premier n≈ìud, y stockons la valeur 1 et laissons le pointeur suivant pointer vers rien. Ensuite, notre variable de liste peut y pointer.
      list = n;

      // Ajouter un nombre √† la liste
      n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }
      n-&gt;number = 2;
      n-&gt;next = NULL;
      // Maintenant, nous allons √† notre premier n≈ìud point√© par list, et nous d√©finissons le pointeur suivant pour qu'il pointe vers notre nouveau n≈ìud, ajoutant ainsi celui-ci √† la fin de la liste¬†:
      list-&gt;next = n;

      // Ajouter un nombre √† la liste
      n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }
      n-&gt;number = 3;
      n-&gt;next = NULL;
      // Nous pouvons suivre plusieurs n≈ìuds avec cette syntaxe, en utilisant le pointeur suivant encore et encore pour ajouter notre troisi√®me nouveau n≈ìud √† la fin de la liste¬†:
      list-&gt;next-&gt;next = n;
      // Normalement, nous voudrions toutefois une boucle et une variable temporaire pour ajouter un nouveau n≈ìud √† notre liste.

      // Imprimer la liste
      // Ici, nous pouvons it√©rer sur tous les n≈ìuds de notre liste avec une variable temporaire. Tout d'abord, nous avons un pointeur temporaire, tmp, qui pointe vers la liste. Ensuite, notre condition pour continuer est que tmp ne soit pas NULL. Enfin, nous mettons √† jour tmp sur le pointeur suivant¬†:
      for (node *tmp = list; tmp != NULL; tmp = tmp-&gt;next)
      {
          // Dans le n≈ìud, nous imprimerons simplement le nombre stock√©¬†:
          printf("%i\n", tmp-&gt;number);
      }

      // Lib√©rer la liste
      // Comme nous lib√©rons chaque n≈ìud au fur et √† mesure, nous allons utiliser une boucle¬†while et suivrons le pointeur suivant de chaque n≈ìud avant de le lib√©rer. Toutefois, nous verrons cela plus en d√©tail dans le probl√®me n¬∞¬†5.
      while (list != NULL)
      {
          node *tmp = list-&gt;next;
          free(list);
          list = tmp;
      }
  }
</code></pre>
</li>
</ul>
<h2>Plus de structures de donn√©es</h2>
<ul>
<li>Un <strong>arbre</strong> est une autre structure de donn√©es o√π chaque n≈ìud pointe vers deux autres n≈ìuds, un √† gauche (avec une valeur plus petite) et un √† droite (avec une valeur plus grande) :
  <img alt="arbre avec le n≈ìud 4 au centre en haut, fl√®che gauche vers 3 en bas, fl√®che droite vers 6 en bas ; 2 a une fl√®che gauche vers 1 en bas, fl√®che droite vers 3 en bas ; 6 a une fl√®che gauche vers 5 en bas, fl√®che droite vers 7 en bas" src="https://cs50.harvard.edu/x/2020/notes/5/binary_search_tree.png" /><ul>
<li>Notez qu'il y a maintenant deux dimensions dans cette structure de donn√©es, o√π certains n≈ìuds sont √† des ¬´ niveaux ¬ª diff√©rents des autres. Et nous pouvons imaginer l'impl√©menter avec une version plus complexe d'un n≈ìud dans une liste cha√Æn√©e, o√π chaque n≈ìud n'a pas un mais deux pointeurs, un vers la valeur au ¬´ milieu de la moiti√© gauche ¬ª et un vers la valeur au ¬´ milieu de la moiti√© droite ¬ª. Et tous les √©l√©ments √† gauche d'un n≈ìud sont plus petits, et tous les √©l√©ments √† droite sont plus grands.</li>
<li>Ceci est appel√© un arbre de recherche binaire parce que chaque n≈ìud a au plus deux enfants, ou n≈ìuds vers lesquels il pointe, et un arbre de recherche parce qu'il est tri√© d'une mani√®re qui nous permet de rechercher correctement.</li>
<li>Et comme une liste cha√Æn√©e, nous voudrons garder un pointeur juste au d√©but de la liste, mais dans ce cas, nous voulons pointer vers la racine, ou n≈ìud central sup√©rieur de l'arbre (le 4).</li>
</ul>
</li>
<li>
<p>Maintenant, nous pouvons facilement faire une recherche binaire, et puisque chaque n≈ìud pointe vers un autre, nous pouvons √©galement ins√©rer des n≈ìuds dans l'arbre sans avoir √† les d√©placer tous comme nous aurions √† le faire dans un tableau. La recherche r√©cursive de cet arbre ressemblerait √† ceci :</p>
<pre><code>  typedef struct node
  {
      int number;
      struct node *left;
      struct node *right;
  } node;

  // Ici, *tree est un pointeur vers la racine de notre arbre.
  bool search(node *tree)
  {
      // Nous avons besoin d'un cas de base, si l'arbre courant (ou une partie de l'arbre) est NULL,
      // pour renvoyer faux :
      if (tree == NULL)
      {
          return false;
      }
      // Maintenant, selon que le nombre dans le n≈ìud courant est plus grand ou plus petit,
      // on peut simplement regarder le c√¥t√© gauche ou droit de l'arbre :
      else if (50 &lt; tree-&gt;number)
      {
          return search(tree-&gt;left);
      }
      else if (50 &gt; tree-&gt;number)
      {
          return search(tree-&gt;right);
      }
      // Sinon, le nombre doit √™tre √©gal √† celui que nous recherchons :
      else {
          return true;
      }
  }
</code></pre>
</li>
<li>
<p>Le temps d'ex√©cution pour rechercher dans un arbre est <em>O</em>(log <em>n</em>), et l'insertion de n≈ìuds tout en maintenant l'arbre √©quilibr√© est √©galement <em>O</em>(log <em>n</em>). En d√©pensant un peu plus de m√©moire et de temps pour maintenir l'arbre, nous avons maintenant gagn√© en rapidit√© pour les recherches par rapport √† une liste cha√Æn√©e simple.</p>
</li>
<li>Une structure de donn√©es avec un temps de recherche presque constant est une <strong>table de hachage</strong>, qui est une combinaison d'un tableau et d'une liste cha√Æn√©e. Nous avons un tableau de listes cha√Æn√©es, et chaque liste cha√Æn√©e dans le tableau contient des √©l√©ments d'une certaine cat√©gorie. Par exemple, dans le monde r√©el, nous pourrions avoir beaucoup de badges nominaux, et nous pourrions les trier en 26 compartiments, chacun √©tiquet√© avec une lettre de l'alphabet, afin de pouvoir trouver les badges en regardant simplement dans un compartiment.</li>
<li>Nous pouvons impl√©menter cela dans une table de hachage avec un tableau de 26 pointeurs, chacun pointant vers une liste cha√Æn√©e pour une lettre de l'alphabet :<br />
<img alt="tableau vertical avec 26 cases, la premi√®re avec une fl√®che pointant vers une case √©tiquet√©e Albus, la deuxi√®me vide, la troisi√®me avec une fl√®che pointant vers une case √©tiquet√©e Cedric... la septi√®me avec une fl√®che pointant vers une case √©tiquet√©e Ginny avec une fl√®che de cette case pointant vers une case √©tiquet√©e George..." src="https://cs50.harvard.edu/x/2020/notes/5/hash_table.png" /></li>
<li>√âtant donn√© que nous avons un acc√®s al√©atoire avec les tableaux, nous pouvons ajouter des √©l√©ments rapidement et aussi indexer rapidement dans un compartiment.</li>
<li>Un compartiment peut contenir plusieurs valeurs correspondantes, nous utiliserons donc une liste cha√Æn√©e pour stocker toutes les valeurs horizontalement. (Nous appelons cela une collision, lorsque deux valeurs correspondent d'une certaine mani√®re.)</li>
<li>Cela s'appelle une table de hachage parce que nous utilisons une fonction de hachage, qui prend une entr√©e et la mappe dans un compartiment o√π elle doit aller. Dans notre exemple, la fonction de hachage se contente de regarder la premi√®re lettre du nom, donc elle pourrait retourner <code>0</code> pour "Albus" et <code>25</code> pour "Zacharias".</li>
<li>Mais dans le pire des cas, tous les noms pourraient commencer par la m√™me lettre, donc nous pourrions nous retrouver avec l'√©quivalent d'une seule liste cha√Æn√©e. Nous pourrions examiner les deux premi√®res lettres et allouer suffisamment de compartiments pour 26*26 valeurs hach√©es possibles, ou m√™me les trois premi√®res lettres, et maintenant nous aurions besoin de 26*26*26 compartiments. Mais nous pourrions encore avoir un pire cas o√π toutes nos valeurs commencent par les m√™mes trois caract√®res, donc le temps d'ex√©cution pour la recherche est <em>O</em>(<em>n</em>). En pratique, cependant, nous pouvons nous rapprocher de <em>O</em>(1) si nous avons √† peu pr√®s autant de compartiments que de valeurs possibles, surtout si nous avons une fonction de hachage id√©ale, o√π nous pouvons trier nos entr√©es dans des compartiments uniques.</li>
<li>Nous pouvons utiliser une autre structure de donn√©es appel√©e <strong>trie</strong> (se prononce comme ‚Äútry‚Äù, et est l'abr√©viation de ‚Äúretrieval‚Äù) :<br />
<img alt="tableau avec les lettres de A √† Z en 26 √©l√©ments, avec H pointant vers un autre tableau contenant toutes les 26 lettres. Le A et le E de ce tableau pointent chacun vers deux tableaux suppl√©mentaires de toutes les 26 lettres, et cela continue dans un arbre jusqu'√† ce que les tableaux les plus bas n'aient qu'une seule lettre marqu√©e comme valide" src="https://cs50.harvard.edu/x/2020/notes/5/trie.png" /><ul>
<li>Imaginez que nous voulons stocker un dictionnaire de mots de mani√®re efficace et √™tre capable d'acc√©der √† chacun d'eux en temps constant. Un trie est comme un arbre, mais chaque n≈ìud est un tableau. Chaque tableau contiendra chaque lettre, de A √† Z. Pour chaque mot, la premi√®re lettre pointera vers un tableau, o√π la lettre suivante valide pointera vers un autre tableau, et ainsi de suite, jusqu'√† ce que nous atteignions quelque chose indiquant la fin d'un mot valide. Si notre mot n'est pas dans le trie, alors l'un des tableaux ne contiendra pas de pointeur ou de caract√®re de terminaison pour notre mot. Maintenant, m√™me si notre structure de donn√©es contient beaucoup de mots, le temps de recherche sera juste la longueur du mot que nous recherchons, et cela pourrait √™tre un maximum fixe donc nous avons <em>O</em>(1) pour la recherche et l'insertion. Le co√ªt pour cela, cependant, est 26 fois plus de m√©moire que ce dont nous avons besoin pour chaque caract√®re.</li>
</ul>
</li>
<li>Il existe des constructions encore plus complexes, les <strong>structures de donn√©es abstraites</strong>, o√π nous utilisons nos blocs de construction de tableaux, listes cha√Æn√©es, tables de hachage et tries pour impl√©menter une solution √† un probl√®me donn√©.</li>
<li>Par exemple, une structure de donn√©es abstraite est une <strong>queue</strong>, o√π nous voulons pouvoir ajouter des valeurs et en supprimer dans un ordre premier entr√©, premier sorti (FIFO). Pour ajouter une valeur, nous pourrions l‚Äôenfiler, et pour en retirer une, nous la d√©congestionnerions. Et nous pouvons l'impl√©menter avec un tableau que nous redimensionnons √† mesure que nous ajoutons des √©l√©ments, ou une liste cha√Æn√©e o√π nous ajoutons des valeurs √† la fin.</li>
<li>Une structure de donn√©es ‚Äúoppos√©e‚Äù serait une <strong>pile</strong>, o√π les √©l√©ments les plus r√©cemment ajout√©s (empil√©s) sont supprim√©s (d√©pil√©s) en premier, dans un ordre dernier entr√©, premier sorti (LIFO). Notre bo√Æte de r√©ception d'e-mails est une pile, o√π nos e-mails les plus r√©cents sont en haut.</li>
<li>Un autre exemple est un <strong>dictionnaire</strong>, o√π nous pouvons mapper des cl√©s √† des valeurs, ou des cha√Ænes √† des valeurs, et nous pouvons en impl√©menter un avec une table de hachage o√π un mot est associ√© √† d'autres informations (comme sa d√©finition ou son sens).</li>
<li>Nous jetons un ≈ìil √† <a href="https://www.youtube.com/watch?v=2wM6_PuBIxY">‚ÄúJack Learns the Facts About Queues and Stacks‚Äù</a>, une animation sur ces structures de donn√©es.</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>