<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en FranÃ§ais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en FranÃ§ais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch ğŸ˜º
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        MÃ©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de DonnÃ©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        CybersÃ©curitÃ©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">HonnÃªtetÃ© AcadÃ©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions FrÃ©quemment PosÃ©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Ã‰quipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>LeÃ§on 0</h1>
<ul>
<li><a href="#bienvenue">Bienvenue</a></li>
<li><a href="#quest-ce-que-linformatique-">Qu'est-ce que l'informatique ?</a></li>
<li><a href="#binaire">Binaire</a></li>
<li><a href="#reprÃ©sentation-des-donnÃ©es">ReprÃ©sentation des donnÃ©es</a></li>
<li><a href="#algorithmes">Algorithmes</a></li>
<li><a href="#pseudocode">Pseudocode</a></li>
<li><a href="#scratch">Scratch</a></li>
</ul>
<h2>Bienvenue</h2>
<ul>
<li>Lorsqu'il Ã©tait en premiÃ¨re annÃ©e, David Ã©tait trop intimidÃ© pour suivre des cours d'informatique. Lorsqu'il Ã©tait en deuxiÃ¨me annÃ©e, il a trouvÃ© le courage de suivre l'Ã©quivalent de CS50, mais seulement pour rÃ©ussir ou Ã©chouer.</li>
<li>En fait, deux tiers des Ã©tudiants de CS50 n'ont jamais suivi de cours de CS auparavant.</li>
<li>
<p>Et surtout :</p>
<blockquote>
<p>ce qui compte en fin de compte dans ce cours, ce n'est pas tant l'endroit oÃ¹ vous vous situez par rapport Ã  vos camarades de classe, mais l'endroit oÃ¹ vous vous situez par rapport Ã  vous-mÃªme lorsque vous avez commencÃ©</p>
</blockquote>
</li>
</ul>
<h2>Qu'est-ce que l'informatique ?</h2>
<ul>
<li>L'informatique est fondamentalement la rÃ©solution de problÃ¨mes.</li>
<li>On peut considÃ©rer la rÃ©solution de problÃ¨mes comme le processus consistant Ã  prendre une entrÃ©e (dÃ©tails sur notre problÃ¨me) et Ã  gÃ©nÃ©rer une sortie (la solution Ã  notre problÃ¨me). La Â« boÃ®te noire Â» au milieu, c'est l'informatique.<br />
<img alt="mot &quot;entrÃ©e&quot;, flÃ¨che dans la boÃ®te, flÃ¨che hors de la boÃ®te, mot &quot;sortie&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/input_output.png" /></li>
<li>Nous avons besoin d'un moyen de reprÃ©senter les entrÃ©es, de maniÃ¨re Ã  pouvoir stocker et traiter les informations de maniÃ¨re standard.</li>
</ul>
<h2>Binaire</h2>
<ul>
<li>Un ordinateur, au niveau le plus bas, stocke les donnÃ©es en binaire, un systÃ¨me de numÃ©ration dans lequel il n'y a que deux chiffres, 0 et 1.</li>
<li>Lorsque nous avons appris Ã  compter, nous avons peut-Ãªtre utilisÃ© un doigt pour reprÃ©senter une chose. Ce systÃ¨me est appelÃ© unaire. Lorsque nous avons appris Ã  Ã©crire les nombres avec les chiffres de 0 Ã  9, nous avons appris Ã  utiliser le systÃ¨me dÃ©cimal.</li>
<li>Par exemple, nous savons que ce qui suit reprÃ©sente cent vingt-trois.</li>
</ul>
<pre>
    1 2 3
</pre>

<ul>
<li>Le <code>3</code> est dans la colonne des uns, le <code>2</code> dans la colonne des dizaines et le <code>1</code> dans la colonne des centaines.</li>
<li>Donc <code>123</code> est Ã©gal Ã  100Ã—1 + 10Ã—2 + 1Ã—3 = 100 + 20 + 3 = 123.</li>
<li>
<p>Chaque place pour un chiffre reprÃ©sente une puissance de dix, puisqu'il y a dix chiffres possibles pour chaque place.</p>
</li>
<li>
<p>En binaire, avec seulement deux chiffres, nous avons des puissances de deux pour chaque valeur de position :</p>
</li>
</ul>
<pre>
    4 2 1
    <b>0 0 0</b>
</pre>

<ul>
<li>
<p>Cela serait toujours Ã©gal Ã  0.</p>
</li>
<li>
<p>Maintenant, si nous changeons la valeur binaire en, disons, <code>0 1 1</code>, la valeur dÃ©cimale serait 3.</p>
</li>
</ul>
<pre>
    4 2 1
    <b>0 1 1</b>
</pre>
<ul>
<li>Si nous voulions reprÃ©senter 8, nous aurions besoin d'un autre chiffre :</li>
</ul>
<pre>
    8 4 2 1
    <b>1 0 0 0</b>
</pre>

<ul>
<li>Et le binaire a du sens pour les ordinateurs parce que nous les alimentons avec de l'Ã©lectricitÃ©, qui peut Ãªtre allumÃ©e ou Ã©teinte, donc chaque bit n'a besoin d'Ãªtre que allumÃ© ou Ã©teint. Dans un ordinateur, il y a des millions ou des milliards d'interrupteurs appelÃ©s transistors qui peuvent stocker de l'Ã©lectricitÃ© et reprÃ©senter un bit en Ã©tant Â« allumÃ©s Â» ou Â« Ã©teints Â».</li>
<li>Avec suffisamment de bits, ou de chiffres binaires, les ordinateurs peuvent compter n'importe quel nombre.</li>
<li>8 bits forment un <strong>octet</strong>.</li>
</ul>
<h2>ReprÃ©sentation des donnÃ©es</h2>
<ul>
<li>Pour reprÃ©senter des lettres, il suffit de dÃ©cider comment les nombres sont mappÃ©s aux lettres. Il y a de nombreuses annÃ©es, des humains se sont mis d'accord sur un mappage standard appelÃ© <a href="https://fr.wikipedia.org/wiki/ASCII">ASCII</a>. La lettre Â« A Â», par exemple, est le nombre 65, et Â« B Â» est 66, et ainsi de suite. Le mappage inclut Ã©galement la ponctuation et d'autres symboles. D'autres caractÃ¨res, comme les lettres accentuÃ©es et les Ã©mojis, font partie d'une norme appelÃ©e <a href="https://fr.wikipedia.org/wiki/Unicode">Unicode</a> qui utilise plus de bits que l'ASCII pour accueillir tous ces caractÃ¨res.<ul>
<li>Lorsque nous recevons un emoji, notre ordinateur reÃ§oit en fait juste un nombre dÃ©cimal comme <code>128514</code> (<code>11111011000000010</code> en binaire, si vous pouvez le lire plus facilement) qu'il mappe ensuite Ã  l'image de l'emoji.</li>
</ul>
</li>
<li>Une image, elle aussi, est composÃ©e de nombreux petits points carrÃ©s, ou pixels, qui peuvent chacun Ãªtre reprÃ©sentÃ©s en binaire avec un systÃ¨me appelÃ© RVB, avec des valeurs pour la lumiÃ¨re rouge, verte et bleue dans chaque pixel. En mÃ©langeant des quantitÃ©s diffÃ©rentes de chaque couleur, nous pouvons reprÃ©senter des millions de couleurs :<br />
<img alt="carrÃ© rouge Ã©tiquetÃ© 72, carrÃ© vert Ã©tiquetÃ© 73, carrÃ© bleu Ã©tiquetÃ© 33" src="https://cs50.harvard.edu/x/2020/notes/0/rgb.png" /><ul>
<li>Les valeurs rouge, verte et bleue sont combinÃ©es pour obtenir une couleur jaune clair :<br />
<img alt="carrÃ© jaune clair" src="https://cs50.harvard.edu/x/2020/notes/0/rgb_combined.png" /></li>
</ul>
</li>
<li>Nous pouvons le voir dans un emoji si nous zoomons suffisamment : <img alt="emoji agrandi de larmes de joie avec des carrÃ©s de pixels distinguables" src="https://cs50.harvard.edu/x/2020/notes/0/emoji_zoomed.png" /></li>
<li>Et les programmes informatiques savent, en fonction du contexte de leur code, si les nombres binaires doivent Ãªtre interprÃ©tÃ©s comme des nombres, des lettres ou des pixels.</li>
<li>Et les vidÃ©os ne sont que de nombreuses images affichÃ©es les unes aprÃ¨s les autres, Ã  un certain nombre d'images par seconde. La musique, elle aussi, peut Ãªtre reprÃ©sentÃ©e par les notes jouÃ©es, leur durÃ©e et leur volume.</li>
</ul>
<h2>Algorithmes</h2>
<ul>
<li>Nous pouvons maintenant reprÃ©senter des intrants et des extrants. La boÃ®te noire prÃ©cÃ©dente contiendra des <em>algorithmes</em>, des instructions Ã©tape par Ã©tape pour rÃ©soudre un problÃ¨meÂ :
  <img alt="boÃ®te avec le mot Â«Â algorithmesÂ Â»" src="https://cs50.harvard.edu/x/2020/notes/0/algorithms.png" /></li>
<li>Disons que nous voulons trouver un ami, Mike Smith, dans un annuaire tÃ©lÃ©phonique.<ul>
<li>Nous pourrions commencer par feuilleter le livre, une page Ã  la fois, jusqu'Ã  ce que nous trouvions Mike Smith ou que nous arrivions Ã  la fin du livre.</li>
<li>Nous pourrions Ã©galement feuilleter deux pages Ã  la fois, mais si nous allons trop loin, nous devrons savoir revenir en arriÃ¨re d'une page.</li>
<li>Mais un moyen encore plus efficace serait d'ouvrir l'annuaire au milieu, de dÃ©cider si Mike sera dans la moitiÃ© gauche ou la moitiÃ© droite du livre (car le livre est classÃ© par ordre alphabÃ©tique) et de jeter immÃ©diatement la moitiÃ© du problÃ¨me. Nous pouvons rÃ©pÃ©ter cela, en divisant Ã  chaque fois le problÃ¨me par deux. Avec 1Â 024 pages pour commencer, nous n'aurions besoin que de 10 Ã©tapes de division par deux pour qu'il ne reste qu'une page Ã  vÃ©rifier.</li>
</ul>
</li>
<li>En fait, nous pouvons reprÃ©senter l'efficacitÃ© de chacun de ces algorithmes avec un graphiqueÂ :
  <img alt="graphique avecÂ : Â«Â taille du problÃ¨meÂ Â» comme axe des xÂ ; Â«Â temps de rÃ©solutionÂ Â» comme axe des yÂ ; droite rouge et raide allant de l'origine au sommet du graphique Ã©tiquetÃ©e Â«Â nÂ Â»Â ; droite jaune, moins raide allant de l'origine au sommet du graphique Ã©tiquetÃ©e Â«Â n/2Â Â»Â ; ligne verte et courbe qui devient de moins en moins raide de l'origine Ã  la droite du graphique Ã©tiquetÃ©e Â«Â log nÂ Â»" src="https://cs50.harvard.edu/x/2020/notes/0/running_time.png" /><ul>
<li>Notre premiÃ¨re solution, une page Ã  la fois, est comme la ligne rougeÂ : notre temps de rÃ©solution augmente linÃ©airement Ã  mesure que la taille du problÃ¨me augmente.</li>
<li>La deuxiÃ¨me solution, deux pages Ã  la fois, est comme la ligne jauneÂ : notre pente est moins raide, mais toujours linÃ©aire.</li>
<li>Notre derniÃ¨re solution est comme la ligne verteÂ : logarithmique, car notre temps de rÃ©solution augmente de plus en plus lentement Ã  mesure que la taille du problÃ¨me augmente. En d'autres termes, si l'annuaire passe de 1Â 000 Ã  2Â 000 pages, nous aurions besoin d'une Ã©tape supplÃ©mentaire pour trouver Mike. Si la taille doublait Ã  nouveau, passant de 2Â 000 Ã  4Â 000 pages, nous n'aurions toujours besoin que d'une Ã©tape supplÃ©mentaire.</li>
</ul>
</li>
</ul>
<h2>Pseudocode</h2>
<ul>
<li>
<p>On peut Ã©crire du <em>pseudocode</em>, une syntaxe informelle qui est juste une version plus spÃ©cifique de l'anglais (ou d'une autre langue humaine) qui reprÃ©sente notre algorithmeÂ :</p>
<pre><code>    1  Prendre l'annuaire
    2  Ouvrir l'annuaire au milieu
    3  Regarder la page
    4  Si Smith est sur la page
    5      Appeler Michel
    6  Sinon si Smith est plus tÃ´t dans l'annuaire
    7      Ouvrir le milieu de la moitiÃ© gauche de l'annuaire
    8      Retourner Ã  la ligne 3
    9  Sinon si Smith est plus tard dans l'annuaire
    10     Ouvrir le milieu de la moitiÃ© droite de l'annuaire
    11     Retourner Ã  la ligne 3
    12 Sinon
    13     ArrÃªter
</code></pre>
</li>
<li>
<p>Quelques-unes de ces lignes commencent par des verbes, ou des actions. On va commencer Ã  les appeler des <em>fonctions</em>Â :</p>
</li>
</ul>
<pre>
    1  <b>Prendre</b> l'annuaire
    2  <b>Ouvrir</b> l'annuaire au milieu
    3  <b>Regarder</b> la page
    4  Si Smith est sur la page  
    5      <b>Appeler</b> Michel
    6  Sinon si Smith est plus tÃ´t dans l'annuaire
    7      <b>Ouvrir</b> le milieu de la moitiÃ© gauche de l'annuaire
    8      Retourner Ã  la ligne 3
    9  Sinon si Smith est plus tard dans l'annuaire
    10     <b>Ouvrir</b> le milieu de la moitiÃ© droite de l'annuaire
    11     Retourner Ã  la ligne 3
    12 Sinon
    13     <b>ArrÃªter</b>
</pre>

<ul>
<li>On a aussi des branches qui mÃ¨nent Ã  des chemins diffÃ©rents, comme des bifurcations sur la route, qu'on va appeler des <em>conditions</em>Â :</li>
</ul>
<pre>
    1  Prendre l'annuaire
    2  Ouvrir l'annuaire au milieu
    3  Regarder la page
    4  <b>Si</b> Smith est sur la page
    5      Appeler Michel
    6  <b>Sinon si</b> Smith est plus tÃ´t dans l'annuaire
    7      Ouvrir le milieu de la moitiÃ© gauche de l'annuaire
    8      Retourner Ã  la ligne 3
    9  <b>Sinon si</b> Smith est plus tard dans l'annuaire
    10     Ouvrir le milieu de la moitiÃ© droite de l'annuaire
    11     Retourner Ã  la ligne 3
    12 <b>Sinon</b>
    13     ArrÃªter
</pre>

<ul>
<li>Et les questions qui dÃ©cident oÃ¹ on va sont appelÃ©es des <em>expressions boolÃ©ennes</em>, qui donnent finalement une valeur de vrai ou fauxÂ :</li>
</ul>
<pre>
    1  Prendre l'annuaire
    2  Ouvrir l'annuaire au milieu
    3  Regarder la page
    4  Si <b>Smith est sur la page</b>
    5      Appeler Michel
    6  Sinon si <b>Smith est plus tÃ´t dans l'annuaire</b>
    7      Ouvrir le milieu de la moitiÃ© gauche de l'annuaire
    8      Retourner Ã  la ligne 3
    9  Sinon si <b>Smith est plus tard dans l'annuaire</b>
    10     Ouvrir le milieu de la moitiÃ© droite de l'annuaire
    11     Retourner Ã  la ligne 3
    12 Sinon
    13     ArrÃªter
</pre>

<ul>
<li>Finalement, on a des mots qui mÃ¨nent Ã  des cycles, oÃ¹ on peut rÃ©pÃ©ter des parties de notre programme, appelÃ©s des <em>boucles</em>Â :</li>
</ul>
<pre>
    1  Prendre l'annuaire
    2  Ouvrir l'annuaire au milieu
    3  Regarder la page
    4  Si Smith est sur la page
    5      Appeler Michel
    6  Sinon si Smith est plus tÃ´t dans l'annuaire
    7      Ouvrir le milieu de la moitiÃ© gauche de l'annuaire
    8      <b>Retourner Ã  la ligne 3</b>
    9  Sinon si Smith est plus tard dans l'annuaire
    10     Ouvrir le milieu de la moitiÃ© droite de l'annuaire
    11     <b>Retourner Ã  la ligne 3</b>
    12 Sinon
    13     ArrÃªter
</pre>

<h2>Scratch</h2>
<ul>
<li>Nous pouvons Ã©crire des programmes avec les Ã©lÃ©ments de base que nous venons de dÃ©couvrirÂ :<ul>
<li>fonctions</li>
<li>conditions</li>
<li>expressions boolÃ©ennes</li>
<li>boucles</li>
</ul>
</li>
<li>Nous utiliserons un langage de programmation graphique appelÃ© <a href="https://scratch.mit.edu/">Scratch</a>, where weâ€™ll drag and drop blocks that contain instructions.</li>
<li>Plus tard dans notre cours, nous passerons Ã  des langages de programmation textuels comme C, Python et JavaScript. Tous ces langages, y compris Scratch, ont des fonctionnalitÃ©s plus puissantes commeÂ :<ul>
<li>variables<ul>
<li>la possibilitÃ© de stocker des valeurs et de les modifier</li>
</ul>
</li>
<li>threads<ul>
<li>la possibilitÃ© pour notre programme de faire plusieurs choses Ã  la fois</li>
</ul>
</li>
<li>Ã©vÃ©nements<ul>
<li>la possibilitÃ© de rÃ©pondre aux changements dans notre programme ou aux entrÃ©es</li>
</ul>
</li>
<li>â€¦</li>
</ul>
</li>
<li>L'environnement de programmation pour Scratch ressemble Ã  ceciÂ :<br />
<img alt="capture d'Ã©cran de scratch" src="https://cs50.harvard.edu/x/2020/notes/0/scratch.png" /><ul>
<li>Sur la gauche, nous avons des piÃ¨ces de puzzle qui reprÃ©sentent des fonctions ou des variables, ou d'autres concepts, que nous pouvons glisser-dÃ©poser dans notre zone d'instructions au centre.</li>
<li>Sur la droite, nous avons une scÃ¨ne qui sera montrÃ©e par notre programme Ã  un humain, oÃ¹ nous pouvons ajouter ou modifier des arriÃ¨re-plans, des personnages (appelÃ©s sprites dans Scratch), et plus encore.</li>
</ul>
</li>
<li>Nous pouvons glisser quelques blocs pour faire dire Â«Â bonjour, mondeÂ Â» Ã  ScratchÂ :<br />
<img alt="capture d'Ã©cran de bonjour, monde" src="https://cs50.harvard.edu/x/2020/notes/0/hello_world.png" /><ul>
<li>Le bloc Â«Â when green flag clickedÂ Â» est le dÃ©but de notre programme, et en dessous, nous avons insÃ©rÃ© un bloc Â«Â sayÂ Â» et tapÃ© Â«Â hello, worldÂ Â».</li>
</ul>
</li>
<li>Nous pouvons Ã©galement faire glisser le bloc Â«Â ask and waitÂ Â», avec une question comme Â«Â What's your nameÂ ?Â Â», et le combiner avec un bloc Â«Â sayÂ Â» pour la rÃ©ponseÂ :<br />
<img alt="capture d'Ã©cran de question et rÃ©ponse" src="https://cs50.harvard.edu/x/2020/notes/0/answer.png" /></li>
<li>Mais nous n'avons pas attendu aprÃ¨s avoir dit Â«Â HelloÂ Â» avec le premier bloc, nous pouvons donc utiliser le bloc Â«Â say () for () secondsÂ Â»Â :<br />
<img alt="capture d'Ã©cran des blocs avec say pendant 2 secondes" src="https://cs50.harvard.edu/x/2020/notes/0/wait.png" /></li>
<li>Nous pouvons utiliser le bloc Â«Â joinÂ Â» pour combiner deux phrases afin que Scratch puisse dire Â«Â hello, DavidÂ Â»Â :<br />
<img alt="capture d'Ã©cran de join" src="https://cs50.harvard.edu/x/2020/notes/0/join.png" /><ul>
<li>Notez que nous pouvons imbriquer des instructions et des variables.</li>
</ul>
</li>
<li>En fait, le bloc Â«Â sayÂ Â» lui-mÃªme est comme un algorithme, oÃ¹ nous avons fourni une entrÃ©e de Â«Â hello, worldÂ Â» et il a produit la sortie de Scratch (le chat) Â«Â disantÂ Â» cette phraseÂ :<br />
<img alt="say comme algorithme avec &quot;hello, world&quot; comme entrÃ©e et chat comme sortie" src="https://cs50.harvard.edu/x/2020/notes/0/say_algorithm.png" /></li>
<li>Le bloc Â«Â askÂ Â» prend Ã©galement une entrÃ©e (la question que nous voulons poser) et produit la sortie du bloc Â«Â answerÂ Â»Â :<br />
<img alt="ask comme algorithme avec &quot;What's your name?&quot; comme entrÃ©e et bloc de rÃ©ponse comme sortie" src="https://cs50.harvard.edu/x/2020/notes/0/ask_algorithm.png" /></li>
<li>Nous pouvons ensuite utiliser le bloc Â«Â answerÂ Â» avec notre propre texte, Â«Â hello,Â Â», comme deux entrÃ©es de l'algorithme joinÂ â€¦<br />
<img alt="join comme algorithme avec &quot;hello, &quot; et &quot;answer&quot; comme entrÃ©e et &quot;hello, David!&quot; comme sortie" src="https://cs50.harvard.edu/x/2020/notes/0/join_algorithm.png" /></li>
<li>â€¦ que nous passons Ã  nouveau comme entrÃ©e au bloc Â«Â sayÂ Â»Â :<br />
<img alt="say comme algorithme avec &quot;hello, David!&quot; comme entrÃ©e et chat comme sortie" src="https://cs50.harvard.edu/x/2020/notes/0/say_again.png" /></li>
<li>Nous pouvons essayer de faire dire meow Ã  Scratch (le nom du chat)Â :<br />
<img alt="blocs Ã©tiquetÃ©s &quot;forever&quot; avec &quot;play sound Meow until done&quot; imbriquÃ©s Ã  l'intÃ©rieur" src="https://cs50.harvard.edu/x/2020/notes/0/forever_meow.png" /><ul>
<li>Mais lorsque nous cliquons sur le drapeau vert, nous entendons immÃ©diatement le miaulement Ã  plusieurs reprises. Notre premier bug, ou erreurÂ ! Nous pouvons ajouter un bloc pour attendre, afin que les miaulements sonnent plus normaux.<br />
<img alt="blocs Ã©tiquetÃ©s &quot;forever&quot; avec &quot;play sound Meow until done&quot; et &quot;wait 1 seconds&quot; imbriquÃ©s Ã  l'intÃ©rieur" src="https://cs50.harvard.edu/x/2020/notes/0/forever_meow_wait.png" /></li>
</ul>
</li>
<li>Nous pouvons faire pointer Scratch vers la souris et se dÃ©placer vers elleÂ :<br />
<img alt="blocs Ã©tiquetÃ©s &quot;forever&quot; avec &quot;point towards mouse-pointer&quot; et &quot;move 10 steps&quot; imbriquÃ©s Ã  l'intÃ©rieur" src="https://cs50.harvard.edu/x/2020/notes/0/point_towards.png" /></li>
<li>Nous allons regarder un mouton qui sait compterÂ :<br />
<img alt="blocs Ã©tiquetÃ©s &quot;set counter to 1&quot; et &quot;forever&quot; avec &quot;say counter for 1 seconds&quot;, &quot;wait 1 seconds&quot; et &quot;change counter by 1&quot; imbriquÃ©s Ã  l'intÃ©rieur" src="https://cs50.harvard.edu/x/2020/notes/0/count.png" /><ul>
<li>Ici, <code>counter</code> est une variable dont nous pouvons dÃ©finir, utiliser et modifier la valeur.</li>
</ul>
</li>
<li>Nous pouvons Ã©galement faire miauler Scratch si on le touche avec le pointeur de la sourisÂ :<br />
<img alt="blocs Ã©tiquetÃ©s &quot;forever&quot; avec &quot;if touching mouse-pointer? then&quot; et &quot;play sound Meow until done&quot; imbriquÃ©s Ã  l'intÃ©rieur" src="https://cs50.harvard.edu/x/2020/notes/0/pet0.png" /></li>
<li>Alternativement, nous pouvons faire rugir Scratch si nous le faisonsÂ :<br />
<img alt="blocs Ã©tiquetÃ©s &quot;forever&quot; avec &quot;if touching mouse-pointer? then&quot; et &quot;play sound roar until done&quot; imbriquÃ©s Ã  l'intÃ©rieur, et &quot;else&quot;, &quot;play sound Meow until done&quot;, &quot;wait 1 seconds&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/pet1.png" /><ul>
<li>Ici, nous avons deux branches diffÃ©rentes, ou conditions, qui se rÃ©pÃ©teront pour toujours. Si la souris le touche, Scratch Â«Â rugiraÂ Â», sinon il miaulera.</li>
</ul>
</li>
<li>
<p>Nous pouvons faire bouger Scratch d'avant en arriÃ¨re sur l'Ã©cran avec quelques blocs supplÃ©mentaires que nous pouvons dÃ©couvrir en regardant autour de nousÂ :<br />
<img alt="blocs Ã©tiquetÃ©s &quot;set rotation style left-right&quot; et &quot;forever&quot; avec &quot;move 10 steps&quot;, &quot;if touching edge? then&quot; et &quot;play sound ouch until done&quot;, &quot;turn 180 degrees&quot;" src="https://cs50.harvard.edu/x/2020/notes/0/ouch.png" /></p>
<ul>
<li>Nous pouvons mÃªme enregistrer notre propre son Ã  lire.</li>
</ul>
</li>
<li>
<p>Avec deux Â«Â costumesÂ Â» diffÃ©rents, ou images de Scratch avec ses pattes dans diffÃ©rentes positions, nous pouvons mÃªme simuler un mouvement de marche animÃ©Â :<br />
<img alt="blocs Ã©tiquetÃ©s Â«Â set rotation style left-rightÂ Â» et Â«Â foreverÂ Â» avec Â«Â move 10 stepsÂ Â», Â«Â if touching edge? thenÂ Â» avec Â«Â play sound ouch until doneÂ Â», Â«Â turn 180 degreesÂ Â» imbriquÃ© Ã  l'intÃ©rieur et Â«Â next costumeÂ Â»" src="https://cs50.harvard.edu/x/2020/notes/0/bounce.png" /></p>
</li>
<li>Nous examinons un autre programme, bark, oÃ¹ nous pouvons utiliser la barre d'espace pour couper le son d'un lion de merÂ :<br />
<img alt="blocs Ã©tiquetÃ©s Â«Â set muted to falseÂ Â» et Â«Â foreverÂ Â» avec if key space pressed? thenÂ Â» avec Â«Â if muted = true thenÂ Â» et Â«Â set muted to falseÂ Â» et Â«Â elseÂ Â» et Â«Â set muted to trueÂ Â» imbriquÃ©s Ã  l'intÃ©rieur, et Â«Â wait 1 secondsÂ Â»" src="https://cs50.harvard.edu/x/2020/notes/0/bark.png" /><ul>
<li>Nous avons une variable, <code>muted</code>, qui est <code>false</code> par dÃ©faut. Et notre programme vÃ©rifie constamment si la barre d'espace est pressÃ©e, et dÃ©finit muted sur <code>false</code> s'il est <code>true</code>, ou <code>true</code> sinon. De cette faÃ§on, nous pouvons basculer si le son est lu ou non, puisque notre autre ensemble de blocs pour le lion de mer vÃ©rifie la variable <code>muted</code>Â :<br />
<img alt="blocs Ã©tiquetÃ©s Â«Â foreverÂ Â» avec if muted = false thenÂ Â» avec Â«Â start sound SeaLionÂ Â» et Â«Â think hi hi hi for 2 secondsÂ Â» imbriquÃ©s Ã  l'intÃ©rieur, et Â«Â wait 1 secondsÂ Â»" src="https://cs50.harvard.edu/x/2020/notes/0/bark1.png" /></li>
</ul>
</li>
<li>Avec plusieurs sprites, ou personnages, nous pouvons avoir diffÃ©rents ensembles de blocs pour chacun d'euxÂ :<br />
<img alt="blocs Ã©tiquetÃ©s Â«Â foreverÂ Â» avec if key space pressed? thenÂ Â» avec Â«Â say Marco! for 2 secondsÂ Â» et Â«Â broadcast eventÂ Â» imbriquÃ©s Ã  l'intÃ©rieur" src="https://cs50.harvard.edu/x/2020/notes/0/marco.png" /><ul>
<li>Pour une marionnette, nous avons ces blocs qui disent Â«Â MarcoÂ !Â Â», puis un bloc Â«Â broadcast eventÂ Â». Cet Â«Â Ã©vÃ©nementÂ Â» est utilisÃ© pour que nos deux sprites communiquent entre eux, comme l'envoi d'un message secret. Ainsi, notre autre marionnette peut simplement attendre que cet Ã©vÃ©nement dise Â«Â PoloÂ !Â Â»Â :<br />
<img alt="blocs Ã©tiquetÃ©s Â«Â when I receive eventÂ Â», Â«Â say Polo! for 2 secondsÂ Â»" src="https://cs50.harvard.edu/x/2020/notes/0/polo.png" /></li>
</ul>
</li>
<li>Maintenant que nous connaissons quelques bases, nous pouvons rÃ©flÃ©chir Ã  la conception ou Ã  la qualitÃ© de nos programmes. Par exemple, nous pourrions vouloir faire tousser Scratch trois fois en rÃ©pÃ©tant quelques blocsÂ :<br />
<img alt="blocs Ã©tiquetÃ©s Â«Â say cough for 1 secondsÂ Â», Â«Â wait 1 secondsÂ Â», Â«Â say cough for 1 secondsÂ Â», Â«Â wait 1 secondsÂ Â», Â«Â say cough for 1 secondsÂ Â», Â«Â wait 1 secondsÂ Â»" src="https://cs50.harvard.edu/x/2020/notes/0/cough0.png" /></li>
<li>Bien que cela soit correct, nous pouvons Ã©viter de rÃ©pÃ©ter des blocs avec une boucleÂ :<br />
<img alt="blocs Ã©tiquetÃ©s Â«Â repeat 3Â Â» avec Â«Â say cough for 1 secondsÂ Â», Â«Â wait 1 secondsÂ Â» imbriquÃ©s Ã  l'intÃ©rieur" src="https://cs50.harvard.edu/x/2020/notes/0/cough1.png" /></li>
<li>L'Ã©tape suivante consiste Ã  abstraire une partie de notre code dans une fonction, ou Ã  le rendre rÃ©utilisable de diffÃ©rentes maniÃ¨res. Nous pouvons crÃ©er un bloc appelÃ© Â«Â coughÂ Â» et y placer des blocsÂ :<br />
<img alt="deux ensembles de blocs. le premier ensemble de blocs estÂ : Â«Â define coughÂ Â», Â«Â say cough for 1 secondsÂ Â», Â«Â wait 1 secondsÂ Â». le deuxiÃ¨me ensemble estÂ : Â«Â when green flag clickedÂ Â», Â«Â repeat 3Â Â», Â«Â coughÂ Â»" src="https://cs50.harvard.edu/x/2020/notes/0/cough_function.png" /><ul>
<li>DÃ©sormais, tous nos sprites peuvent utiliser le mÃªme bloc Â«Â coughÂ Â», autant de fois que nous le souhaitons.</li>
</ul>
</li>
<li>Nous pouvons mÃªme mettre un certain nombre de fois dans notre fonction cough, donc nous n'avons besoin que d'un seul bloc pour tousser un certain nombre de foisÂ :<br />
<img alt="deux ensembles de blocs. le premier ensemble de blocs estÂ : Â«Â define cough n timesÂ Â», Â«Â repeat nÂ Â», say cough for 1 secondsÂ Â», Â«Â wait 1 secondsÂ Â». le deuxiÃ¨me ensemble estÂ : Â«Â when green flag clickedÂ Â», Â«Â cough 3 timesÂ Â»" src="https://cs50.harvard.edu/x/2020/notes/0/cough_function_2.png" /></li>
<li>Nous examinons quelques exemples et discutons de la faÃ§on dont nous pourrions implÃ©menter des composants de ceux-ci avec diffÃ©rents sprites qui suivent le curseur de la souris, ou faire se produire quelque chose d'autre sur la scÃ¨ne.</li>
<li>Bienvenue Ã  bordÂ !</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>