<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Fran√ßais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en Fran√ßais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        M√©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de Donn√©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        Cybers√©curit√©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">Honn√™tet√© Acad√©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions Fr√©quemment Pos√©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">√âquipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>Le√ßon 2</h2>
<ul>
<li><a href="#compiling">Compilation</a></li>
<li><a href="#debugging">D√©bogage</a></li>
<li><a href="#help50-et-printf">help50 et printf</a></li>
<li><a href="#debug50">debug50</a></li>
<li><a href="#check50-et-style50">check50 et style50</a></li>
<li><a href="#types-de-donn√©es">Types de donn√©es</a></li>
<li><a href="#m√©moire">M√©moire</a></li>
<li><a href="#tableaux">Tableaux</a></li>
<li><a href="#cha√Ænes">Cha√Ænes</a></li>
<li><a href="#arguments-de-ligne-de-commande">Arguments de ligne de commande</a></li>
<li><a href="#lisibilit√©">Lisibilit√©</a></li>
<li><a href="#cryptage">Cryptage</a></li>
</ul>
<h2>Compilation</h2>
<ul>
<li>La derni√®re fois, nous avons appris √† √©crire notre premier programme en C. Nous avons appris la syntaxe de la fonction <code>main</code> dans notre programme, la fonction <code>printf</code> pour imprimer dans un terminal, comment cr√©er des cha√Ænes avec des guillemets doubles et comment inclure <code>stdio.h</code> pour la fonction <code>printf</code>.</li>
<li>Ensuite, nous l'avons compil√© avec <code>clang hello.c</code> pour pouvoir ex√©cuter <code>./a.out</code> (le nom par d√©faut), puis <code>clang -o hello hello.c</code> (en transmettant un argument de ligne de commande pour le nom de la sortie) pour pouvoir ex√©cuter <code>./hello</code>.</li>
<li>Si nous avons voulu utiliser la biblioth√®que de CS50, via <code>#include &lt;cs50.h&gt;</code>, pour les cha√Ænes et la fonction <code>get_string</code>, nous avons √©galement d√ª ajouter un indicateur¬†: <code>clang -o hello hello.c -lcs50</code>. L'indicateur <code>-l</code> relie le fichier <code>cs50</code>, qui est d√©j√† install√© dans le bac √† sable CS50 et comprend des prototypes ou des d√©finitions de cha√Ænes et de <code>get_string</code> (entre autres) auxquels notre programme peut ensuite se r√©f√©rer et les utiliser.</li>
<li>Nous √©crivons notre code source en C, mais nous devons le compiler en code machine, en binaire, avant que nos ordinateurs puissent l'ex√©cuter.<ul>
<li><code>clang</code> est le compilateur et <code>make</code> est un utilitaire qui nous aide √† ex√©cuter <code>clang</code> sans avoir √† indiquer toutes les options manuellement.</li>
</ul>
</li>
<li>La ¬´¬†compilation¬†¬ª du code source en code machine est en r√©alit√© constitu√©e d'√©tapes plus petites¬†:<ul>
<li>Pr√©traitement</li>
<li>Compilation</li>
<li>Assemblage</li>
<li>Liaison</li>
</ul>
</li>
<li>Le <strong>pr√©traitement</strong> implique l'examen des lignes qui commencent par un <code>#</code>, comme <code>#include</code>, avant tout autre chose. Par exemple, <code>#include &lt;cs50.h&gt;</code> indiquera √† <code>clang</code> de rechercher d'abord ce fichier d'en-t√™te, car il contient le contenu que nous souhaitons inclure dans notre programme. Ensuite, <code>clang</code> remplacera essentiellement le contenu de ces fichiers d'en-t√™te dans notre programme.</li>
<li>
<p>Par exemple¬†‚Ä¶</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("Name: ");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>‚Ä¶ sera pr√©trait√© en¬†:</p>
<pre><code>  string get_string(string prompt);
  int printf(const char *format, ...);

  int main(void)
  {
      string name = get_string("Name: ");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>La <strong>compilation</strong> prend notre code source, en C, et le convertit en code assembleur, qui ressemble √† ceci¬†:</p>
<pre><code>  ...
  main:                         # @main
      .cfi_startproc
  # BB#0:
      pushq    %rbp
  .Ltmp0:
      .cfi_def_cfa_offset 16
  .Ltmp1:
      .cfi_offset %rbp, -16
      movq    %rsp, %rbp
  .Ltmp2:
      .cfi_def_cfa_register %rbp
      subq    $16, %rsp
      xorl    %eax, %eax
      movl    %eax, %edi
      movabsq    $.L.str, %rsi
      movb    $0, %al
      callq    get_string
      movabsq    $.L.str.1, %rdi
      movq    %rax, -8(%rbp)
      movq    -8(%rbp), %rsi
      movb    $0, %al
      callq    printf
      ...
</code></pre>
<ul>
<li>Ces instructions sont de plus bas niveau et se rapprochent des instructions binaires qu'un processeur d'ordinateur peut directement comprendre. Elles fonctionnent g√©n√©ralement sur des octets eux-m√™mes, par opposition √† des abstractions comme les noms de variables.</li>
</ul>
</li>
<li>
<p>L'√©tape suivante consiste √† prendre le code assembleur et √† le traduire en instructions binaires en l'<strong>assemblant</strong>. Les instructions en binaire sont appel√©es <strong>code machine</strong>, qu'un processeur d'ordinateur peut ex√©cuter directement.</p>
</li>
<li>La derni√®re √©tape est la <strong>liaison</strong>, o√π le contenu des biblioth√®ques pr√©c√©demment compil√©es que nous souhaitons lier, comme <code>cs50.c</code>, sont r√©ellement combin√©es avec le binaire de notre programme. Nous nous retrouvons donc avec un fichier binaire, <code>a.out</code> ou <code>hello</code>, qui est la version compil√©e de <code>hello.c</code>, <code>cs50.c</code> et <code>printf.c</code>.</li>
</ul>
<h2>D√©bogage</h2>
<ul>
<li>Les bogues sont des erreurs involontaires qui surviennent dans les programmes. Le d√©bogage est le processus de recherche et de correction de ces bogues.</li>
</ul>
<h2>help50 et printf</h2>
<ul>
<li>
<p>Supposons que nous ayons √©crit ce programme, <code>buggy0.c</code>¬†:</p>
<pre><code>  int main(void)
  {
      printf("hello, world\n");
  }
</code></pre>
<ul>
<li>Lorsque nous essayons de <code>make</code> ce programme, nous voyons une erreur (en rouge) indiquant que nous d√©clarons implicitement la fonction de biblioth√®que <code>printf</code>. Nous ne comprenons pas vraiment cette erreur. Nous pouvons donc ex√©cuter <code>help50 make buggy0</code>. Cela nous indiquera en fin de compte que nous avons peut-√™tre oubli√© d‚Äô√©crire <code>#include &lt;stdio.h&gt;</code>, qui contient <code>printf</code>.</li>
</ul>
</li>
<li>
<p>Nous pouvons r√©essayer avec <code>buggy1.c</code>¬†:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("What's your name?\n");
      printf("hello, %s\n", name);
  }
</code></pre>
<ul>
<li>De nombreuses erreurs s‚Äôaffichent, et m√™me la premi√®re ne semble pas avoir beaucoup de sens. Nous pouvons donc √† nouveau ex√©cuter <code>help50 make buggy1</code>. Cela nous indiquera que nous avons besoin de <code>cs50.h</code> car <code>string</code> n‚Äôest pas d√©fini.</li>
</ul>
</li>
<li>
<p>Pour effacer la fen√™tre du terminal (afin de ne voir que la sortie de ce que nous voulons ex√©cuter ensuite), nous pouvons appuyer sur <code>control + L</code> ou taper <code>clear</code> comme commande dans la fen√™tre du terminal.</p>
</li>
<li>
<p>Examinons <code>buggy2.c</code>¬†:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      for (int i = 0; i &lt;= 10; i++)
      {
          printf("#\n");
      }
  }
</code></pre>
<ul>
<li>
<p>Hmm, nous avions l‚Äôintention de ne voir que 10 <code>#</code>, mais il y en a 11. Si nous ne savions pas quel √©tait le probl√®me (car notre programme se compile sans aucune erreur, et nous avons maintenant une erreur logique), nous pourrions ajouter une autre ligne d‚Äôimpression pour nous aider¬†:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      for (int i = 0; i &lt;= 10; i++)
      {
          printf("i est maintenant %i¬†: ", i);
          printf("#\n");
      }
  }
</code></pre>
</li>
<li>
<p>Maintenant, nous voyons que <code>i</code> a commenc√© √† 0 et a continu√© jusqu‚Äô√† 10, mais nous devrions l‚Äôarr√™ter lorsqu‚Äôil est √† 10, avec <code>i &lt; 10</code> au lieu de <code>i &lt;= 10</code>.</p>
</li>
</ul>
</li>
</ul>
<h2>debug50</h2>
<ul>
<li>Aujourd'hui, nous allons √©galement jeter un ≈ìil √† CS50 IDE, qui est comme le bac √† sable de CS50, mais avec plus de fonctionnalit√©s. C'est un environnement de d√©veloppement en ligne, avec un √©diteur de code et une fen√™tre de terminal, mais aussi des outils pour le d√©bogage et la collaboration¬†:
  <img alt="fen√™tre de navigateur avec CS50 IDE, √©diteur de code sur le dessus avec buggy2.c, fen√™tre de terminal en bas" src="https://cs50.harvard.edu/x/2020/notes/2/cs50_ide.png" /></li>
<li>Dans CS50 IDE, nous aurons un autre outil, <code>debug50</code>, pour nous aider √† d√©boguer les programmes.</li>
<li>Nous allons ouvrir <code>buggy2.c</code> et essayer de <code>faire buggy2</code>. Mais nous avons enregistr√© <code>buggy2.c</code> dans un dossier appel√© <code>src2</code>, nous devons donc ex√©cuter <code>cd src2</code> pour changer notre r√©pertoire vers le bon. Le terminal de CS50 IDE nous rappellera dans quel r√©pertoire nous sommes, avec une invite comme <code>~/src/ $</code>. (Le <code>~</code> indique le r√©pertoire par d√©faut, ou le r√©pertoire home.)</li>
<li>Au lieu d'utiliser <code>printf</code>, nous pouvons √©galement d√©boguer notre programme de mani√®re interactive. Nous pouvons ajouter un <em>point d'arr√™t</em>, ou un indicateur pour une ligne de code o√π le d√©bogueur doit interrompre notre programme. Par exemple, on peut cliquer √† gauche de la ligne 5 de notre code, un cercle rouge appara√Ætra¬†:
  <img alt="√©diteur de code avec une ic√¥ne rouge √† c√¥t√© de la ligne 5 du code" src="https://cs50.harvard.edu/x/2020/notes/2/breakpoint.png" /></li>
<li>Maintenant, si on ex√©cute <code>debug50 ./buggy2</code>, on verra le panneau de d√©bogage s'ouvrir √† droite¬†:
  <img alt="panneau du d√©bogueur avec commandes, variables" src="https://cs50.harvard.edu/x/2020/notes/2/debugger_panel.png" /></li>
<li>On voit que la variable que nous avons cr√©√©e, <code>i</code>, est dans la section <code>Variables locales</code>, et qu'elle a une valeur de <code>0</code>.</li>
<li>Notre point d'arr√™t a interrompu notre programme apr√®s la ligne 5, juste avant la ligne 7, car c'est la premi√®re ligne de code qui peut √™tre ex√©cut√©e. Pour continuer, nous avons quelques commandes dans le panneau du d√©bogueur. Le triangle bleu continuera notre programme jusqu'√† ce que nous atteignions un autre point d'arr√™t ou la fin de notre programme. La fl√®che courbe √† sa droite va ¬´ passer outre ¬ª la ligne, l'ex√©cuter et interrompre notre programme juste apr√®s.</li>
<li>Nous utiliserons donc la fl√®che courbe pour ex√©cuter la ligne suivante et voir ce qui change apr√®s. Nous sommes √† la ligne <code>printf</code>, et en appuyant √† nouveau sur la fl√®che courbe, nous voyons un seul <code>#</code> imprim√© dans notre fen√™tre de terminal. Avec un autre clic sur la fl√®che, nous voyons la valeur de <code>i</code> sur la droite changer √† <code>1</code>. Et nous pouvons continuer √† cliquer sur la fl√®che pour regarder notre programme s'ex√©cuter, une ligne √† la fois.</li>
<li>Pour quitter le d√©bogueur, on peut appuyer sur <code>ctrl + C</code> pour arr√™ter le programme.</li>
<li>Nous pouvons gagner beaucoup de temps √† l'avenir en investissant un peu maintenant pour apprendre √† utiliser <code>debug50</code>¬†!</li>
</ul>
<h2>check50 et style50</h2>
<ul>
<li>Nous pouvons ex√©cuter une commande comme <code>check50 cs50/problems/hello</code>, o√π <code>check50</code> est un programme qui suivra les instructions identifi√©es par l'argument <code>cs50/problems/hello</code> pour t√©l√©charger, ex√©cuter et tester notre programme sur les serveurs de CS50. Cela v√©rifiera l'exactitude de notre programme.<ul>
<li>Lors de l'√©criture de logiciels dans le monde r√©el, les d√©veloppeurs √©crivent g√©n√©ralement leurs propres tests pour s'assurer que leur code fonctionne comme pr√©vu, d'autant plus que des fonctionnalit√©s sont ajout√©es au m√™me code.</li>
</ul>
</li>
<li><code>style50</code> est un autre programme qui v√©rifiera notre code pour des probl√®mes esth√©tiques, comme les espaces, de sorte que notre code soit plus lisible et maintenable. Par exemple, il se peut que notre indentation soit manquante. Et le <a href="https://cs50.readthedocs.io/style/c/">guide de style</a> inclura davantage d'explications sur ce que nous attendons.</li>
<li>Nous pouvons m√™me utiliser le d√©bogage du canard en caoutchouc, une m√©thode o√π nous expliquons ce que nous essayons de faire √† un canard en caoutchouc, de sorte que nous r√©alisions ce que nous essayons de faire et ce que nous devons corriger.</li>
<li>Nous voulons √©galement √©crire notre code avec une bonne conception, o√π nous r√©solvons non seulement le probl√®me correctement, mais aussi bien, o√π nous faisons des choix raisonnables quant √† la fa√ßon dont notre programme s'ex√©cute et faisons des compromis entre le temps, le co√ªt de d√©veloppement et la m√©moire.</li>
</ul>
<h2>Types de donn√©es</h2>
<ul>
<li>En C, nous avons diff√©rents types de variables que nous pouvons utiliser pour stocker des donn√©es¬†:<ul>
<li>bool 1 octet</li>
<li>char 1 octet</li>
<li>int 4 octets</li>
<li>float 4 octets</li>
<li>long 8 octets</li>
<li>double 8 octets</li>
<li>string ? octets</li>
</ul>
</li>
<li>Chacun de ces types occupe un certain nombre d'octets par variable que nous cr√©ons, et les tailles ci-dessus sont celles que le bac √† sable, l'IDE et tr√®s probablement votre ordinateur utilisent pour chaque type en C.</li>
</ul>
<h2>M√©moire</h2>
<ul>
<li>√Ä l'int√©rieur de nos ordinateurs, nous avons des puces appel√©es RAM, m√©moire √† acc√®s al√©atoire, qui stockent des donn√©es pour une utilisation √† court terme. Nous pourrions enregistrer un programme ou un fichier sur notre disque dur (ou notre disque SSD) pour un stockage √† long terme, mais lorsque nous l'ouvrons, il est d'abord copi√© dans la RAM. Bien que la RAM soit beaucoup plus petite et temporaire (jusqu'√† ce que l'alimentation soit coup√©e), elle est beaucoup plus rapide.</li>
<li>On peut penser aux octets stock√©s dans la RAM comme s'ils √©taient dans une grille¬†:<br />
<img alt="puce d'ordinateur avec grille superpos√©e" src="https://cs50.harvard.edu/x/2020/notes/2/ram.png" /><ul>
<li>En r√©alit√©, il y a des millions ou des milliards d'octets par puce.</li>
</ul>
</li>
<li>En C, lorsque nous cr√©ons une variable de type <code>char</code>, qui sera de taille un octet, elle sera physiquement stock√©e dans l'une de ces cases de la RAM. Un entier, avec 4 octets, prendra quatre de ces cases.</li>
<li>Et chacune de ces cases est √©tiquet√©e avec un num√©ro, ou une adresse, de 0 √† 1, √† 2, etc.</li>
</ul>
<h2>Tableaux</h2>
<ul>
<li>
<p>Disons que nous voulions stocker trois variables¬†:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      char c1 = 'H';
      char c2 = 'I';
      char c3 = '!';
      printf("%c %c %c\n", c1, c2, c3);
  }
</code></pre>
<ul>
<li>Notez que nous utilisons des guillemets simples pour indiquer un caract√®re litt√©ral, et des guillemets doubles pour plusieurs caract√®res ensemble dans une cha√Æne.</li>
<li>Nous pouvons compiler et ex√©cuter ceci, pour voir <code>H I !</code>.</li>
</ul>
</li>
<li>
<p>Et nous savons que les caract√®res ne sont que des nombres, donc si nous changeons le formatage de notre cha√Æne pour √™tre <code>printf("%i %i %i\n", c1, c2, c3);</code>, nous pouvons voir les valeurs num√©riques de chaque caract√®re imprim√©¬†: <code>72 73 33</code>.</p>
<ul>
<li>Nous pouvons convertir explicitement, ou caster, chaque caract√®re en un int avant de l‚Äôutiliser, avec <code>(int) c1</code>, mais notre compilateur peut le faire implicitement pour nous.</li>
</ul>
</li>
<li>Et en m√©moire, on peut avoir trois cases, √©tiquet√©es ¬´¬†c1¬†¬ª, ¬´¬†c2¬†¬ª et ¬´¬†c3¬†¬ª d‚Äôune certaine mani√®re, chacune repr√©sentant un octet binaire avec les valeurs de chaque variable.</li>
<li>
<p>Regardons <code>scores0.c</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Scores
      int score1 = 72;
      int score2 = 73;
      int score3 = 33;

      // Print average
      printf("Average: %i\n", (score1 + score2 + score3) / 3);
  }
</code></pre>
<ul>
<li>Nous pouvons imprimer la moyenne de trois nombres, mais maintenant nous devons cr√©er une variable pour chaque score que nous voulons inclure, et nous ne pouvons pas les utiliser facilement plus tard.</li>
</ul>
</li>
<li>
<p>Il s‚Äôav√®re qu‚Äôen m√©moire, nous pouvons stocker des variables les unes apr√®s les autres, dos √† dos. Et en C, une liste de variables stock√©es, les unes apr√®s les autres dans un bloc contigu de m√©moire, est appel√©e un <strong>tableau</strong>.</p>
</li>
<li>Par exemple, nous pouvons utiliser <code>int scores[3];</code> pour d√©clarer un tableau de 3 entiers.</li>
<li>
<p>Et nous pouvons assigner et utiliser des variables dans un tableau avec¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Scores
      int scores[3];
      scores[0] = 72;
      scores[1] = 73;
      scores[2] = 33;

      // Print average
      printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
  }
</code></pre>
<ul>
<li>Notez que les tableaux sont index√©s √† z√©ro, ce qui signifie que le premier √©l√©ment, ou valeur, a l‚Äôindex 0.</li>
</ul>
</li>
<li>
<p>Et nous avons r√©p√©t√© la valeur 3, repr√©sentant la longueur de notre tableau, √† deux endroits diff√©rents. Nous pouvons donc utiliser une constante, ou une valeur fixe, pour indiquer qu‚Äôelle doit toujours √™tre la m√™me aux deux endroits¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  const int N = 3;

  int main(void)
  {
      // Scores
      int scores[N];
      scores[0] = 72;
      scores[1] = 73;
      scores[2] = 33;

      // Print average
      printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / N);
  }
</code></pre>
<ul>
<li>Nous pouvons utiliser le mot-cl√© <code>const</code> pour dire au compilateur que la valeur de <code>N</code> ne doit jamais √™tre modifi√©e par notre programme. Et par convention, nous placerons notre d√©claration de variable en dehors de la fonction <code>main</code> et mettrons son nom en majuscule, ce qui n‚Äôest pas n√©cessaire pour le compilateur, mais qui montre aux autres humains que cette variable est une constante et la rend facile √† voir depuis le d√©but.</li>
</ul>
</li>
<li>
<p>Avec un tableau, nous pouvons collecter nos scores dans une boucle, et y acc√©der plus tard dans une boucle √©galement¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  float average(int length, int array[]);

  int main(void)
  {
      // Get number of scores
      int n = get_int("Scores:  ");

      // Get scores
      int scores[n];
      for (int i = 0; i &lt; n; i++)
      {
          scores[i] = get_int("Score %i: ", i + 1);
      }

      // Print average
      printf("Average: %.1f\n", average(n, scores));
  }

  float average(int length, int array[])
  {
      int sum = 0;
      for (int i = 0; i &lt; length; i++)
      {
          sum += array[i];
      }
      return (float) sum / (float) length;
  }
</code></pre>
<ul>
<li>Tout d‚Äôabord, nous demandons √† l‚Äôutilisateur le nombre de scores qu‚Äôil a, cr√©ons un tableau avec suffisamment d‚Äôentiers pour le nombre de scores qu‚Äôil a, et utilisons une boucle pour collecter tous les scores.</li>
<li>Ensuite, nous √©crivons une fonction d‚Äôassistance, <code>average</code>, pour renvoyer un <code>float</code> ou une valeur d√©cimale. Nous passerons la longueur et un tableau de <code>int</code> (qui peut √™tre de n‚Äôimporte quelle taille), et utiliserons une autre boucle dans notre fonction d‚Äôassistance pour additionner les valeurs dans une somme. Nous utilisons <code>(float)</code> pour caster √† la fois <code>sum</code> et <code>length</code> en floats, donc le r√©sultat que nous obtenons en divisant les deux est aussi un float.</li>
<li>Enfin, lorsque nous imprimons le r√©sultat obtenu, nous utilisons <code>%.1f</code> pour n‚Äôafficher qu‚Äôune d√©cimale.</li>
</ul>
</li>
<li>
<p>En m√©moire, notre tableau est maintenant stock√© comme ceci, o√π chaque valeur occupe non pas un mais quatre octets¬†:
  <img alt="grille avec 72 √©tiquet√© score1, 73 √©tiquet√© score2, 33 √©tiquet√© score3, chacun occupant quatre cases, et de nombreuses cases vides suivent" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_array.png" /></p>
</li>
</ul>
<h2>Strings</h2>
<ul>
<li>Les strings sont en fait simplement des tableaux de caract√®res. Si nous avons une string <code>s</code>, chaque caract√®re peut √™tre acc√©d√© avec <code>s[0]</code>, <code>s[1]</code>, et ainsi de suite.
-¬†Et il s'av√®re qu'une string se termine par un caract√®re sp√©cial, ‚Äò\0‚Äô, ou un octet avec tous les bits √† 0. Ce caract√®re est appel√© caract√®re nul, ou caract√®re terminateur nul. Nous avons donc en r√©alit√© besoin de quatre octets pour stocker notre string "HI!" :<br />
<img alt=" Grille avec H √©tiquet√© s[0], I √©tiquet√© s[1], ! √©tiquet√© s[2], \0 √©tiquet√© s[3], chacun prenant une case et de nombreuses autres cases vides sont √† la suite" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_string.png" /></li>
<li>
<p>Voyons maintenant √† quoi peuvent ressembler quatre strings dans un tableau¬†:</p>
<pre><code>  string noms[4]¬†;
  noms[0] = "EMMA"¬†;
  noms[1] = "RODRIGO"¬†;
  noms[2] = "BRIAN"¬†;
  noms[3] = "DAVID"¬†;

  printf("%s\n", noms[0])¬†;
  printf("%c%c%c%c\n", noms[0][0], noms[0][1], noms[0][2], noms[0][3])¬†;
</code></pre>
<ul>
<li>Nous pouvons imprimer la premi√®re valeur de <code>noms</code> sous forme de string ou r√©cup√©rer la premi√®re string et obtenir chaque caract√®re individuel dans cette string en utilisant <code>[]</code> √† nouveau. (Nous pouvons consid√©rer cela comme <code>(noms[0])[0]</code>, bien que nous n‚Äôen ayons pas besoin les parenth√®ses.)</li>
<li>Et bien que nous sachions que le pr√©nom avait quatre caract√®res, <code>printf</code> a probablement utilis√© une boucle pour regarder chaque caract√®re de la string, les imprimant un √† la fois jusqu'√† atteindre le caract√®re nul qui marque la fin de la string. Et en fait, nous pouvons imprimer <code>noms[0][4]</code> sous forme d‚Äô<code>int</code> avec <code>%i</code>, et voir un <code>0</code> s‚Äôafficher.</li>
</ul>
</li>
<li>
<p>Nous pouvons visualiser chaque caract√®re avec sa propre √©tiquette en m√©moire¬†:<br />
<img alt=" Grille avec E √©tiquet√© noms[0][0], M √©tiquet√© noms[0][1], etc. jusqu'√† noms[3][5] avec un \0, chacun prenant une case et des cases vides suivent" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_string_array.png" /></p>
</li>
<li>
<p>Nous pouvons essayer d'exp√©rimenter avec <code>string0.c</code>¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Entr√©e¬†: ");
      printf("Sortie¬†: ");
      for (int i = 0; i &lt; strlen(s); i++)
      {
          printf("%c", s[i]);
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Nous pouvons utiliser la condition <code>s[i] != '\0'</code>, o√π nous pouvons v√©rifier le caract√®re actuel et l‚Äôimprimer uniquement s‚Äôil ne s‚Äôagit pas du caract√®re nul.</li>
<li>Nous pouvons √©galement utiliser la longueur de la string, mais nous avons d‚Äôabord besoin d‚Äôune nouvelle biblioth√®que, <code>string.h</code>, pour <code>strlen</code>, qui nous indique la longueur d‚Äôune string.</li>
</ul>
</li>
<li>
<p>Nous pouvons am√©liorer la conception de notre programme. <code>string0</code> √©tait un peu inefficace, car nous v√©rifions la longueur de la string, apr√®s que chaque caract√®re est imprim√©, dans notre condition. Mais comme la longueur de la string ne change pas, nous pouvons v√©rifier la longueur de la string une fois¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Entr√©e¬†: ");
      printf("Sortie¬†:\n");
      for (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          printf("%c\n", s[i]);
      }
  }
</code></pre>
<ul>
<li>Maintenant, au d√©but de notre boucle, nous initialisons une variable <code>i</code> et <code>n</code>, et m√©morisons la longueur de notre string dans <code>n</code>. Ensuite, nous pouvons v√©rifier les valeurs √† chaque fois, sans avoir √† calculer r√©ellement la longueur de la string.
-¬†Et nous avons effectivement eu besoin d‚Äôun peu plus de m√©moire pour <code>n</code>, mais cela nous fait gagner du temps en n‚Äôayant pas √† v√©rifier la longueur de la string √† chaque fois.</li>
</ul>
</li>
<li>
<p>Nous pouvons maintenant combiner ce que nous avons vu pour √©crire un programme capable de mettre en majuscules des lettres :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Avant : ");
      printf("Apr√®s :  ");
      for (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z')
          {
              printf("%c", s[i] - 32);
          }
          else
          {
              printf("%c", s[i]);
          }
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Tout d'abord, nous obtenons une cha√Æne <code>s</code>. Ensuite, pour chaque caract√®re dans la cha√Æne, s'il est en minuscule (sa valeur est entre celle de <code>a</code> et <code>z</code>), nous le convertissons en majuscule. Sinon, nous l'imprimons simplement.</li>
<li>Nous pouvons convertir une lettre minuscule en son √©quivalent en majuscule en soustrayant la diff√©rence entre leurs valeurs ASCII. (Nous savons que les lettres minuscules ont une valeur ASCII plus √©lev√©e que les lettres majuscules, et la diff√©rence est commod√©ment la m√™me entre les m√™mes lettres, nous pouvons donc soustraire cette diff√©rence pour obtenir une lettre majuscule √† partir d'une lettre minuscule.)</li>
</ul>
</li>
<li>
<p>Nous pouvons utiliser les <a href="https://man.cs50.io/"><strong>pages de manuel</strong></a>, ou le manuel du programmeur, pour trouver les fonctions de biblioth√®que que nous pouvons utiliser pour accomplir la m√™me chose :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;ctype.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Avant : ");
      printf("Apr√®s :  ");
      for (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          printf("%c", toupper(s[i]));
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>En recherchant dans les pages du manuel, nous voyons <code>toupper()</code> est une fonction, entre autres, d'une biblioth√®que appel√©e <code>ctype</code>, que nous pouvons utiliser.</li>
</ul>
</li>
</ul>
<h2>Arguments de ligne de commande</h2>
<ul>
<li>Nous avons utilis√© des programmes tels que <code>make</code> et <code>clang</code>, qui prennent des mots suppl√©mentaires apr√®s leur nom sur la ligne de commande. Il s‚Äôav√®re que nos propres programmes peuvent √©galement prendre des <strong>arguments de ligne de commande</strong>.</li>
<li>
<p>Dans <code>argv.c</code>, nous modifions l‚Äôapparence de notre fonction <code>main</code>¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(int argc, string argv[])
  {
      if (argc == 2)
      {
          printf("bonjour, %s\n", argv[1]);
      }
      else
      {
          printf("bonjour, le monde\n");
      }
  }
</code></pre>
<ul>
<li><code>argc</code> et <code>argv</code> sont deux variables que notre fonction <code>main</code> re√ßoit d√©sormais lorsque notre programme est ex√©cut√© depuis la ligne de commande. <code>argc</code> est le nombre d‚Äôarguments ou le nombre d‚Äôarguments, et <code>argv</code> est un tableau de cha√Ænes qui sont les arguments. Et le premier argument, <code>argv [0]</code>, est le nom de notre programme (le premier mot tap√©, comme <code>./hello</code>). Dans cet exemple, nous v√©rifions si nous avons deux arguments et, le cas √©ch√©ant, nous affichons le second.</li>
<li>Par exemple, si nous ex√©cutons <code>./argv David</code>, nous obtiendrons <code>bonjour, David</code> imprim√©, puisque nous avons tap√© <code>David</code> comme deuxi√®me mot dans notre commande.</li>
</ul>
</li>
<li>
<p>Il s‚Äôav√®re que nous pouvons indiquer les erreurs dans notre programme en renvoyant une valeur depuis notre fonction <code>main</code> (comme indiqu√© par l‚Äô<code>int</code> avant notre fonction <code>main</code>). Par d√©faut, notre fonction <code>main</code> renvoie <code>0</code> pour indiquer que rien ne s‚Äôest mal pass√©, mais nous pouvons √©crire un programme pour renvoyer une valeur diff√©rente¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(int argc, string argv[])
  {
      if (argc != 2)
      {
          printf("argument de ligne de commande manquant\n");
          return 1;
      }
      printf("bonjour, %s\n", argv[1]);
      return 0;
  }
</code></pre>
<ul>
<li>La valeur de retour de <code>main</code> dans notre programme est appel√©e code de sortie.</li>
</ul>
</li>
<li>
<p>Au fur et √† mesure que nous √©crivons des programmes plus complexes, des codes d‚Äôerreur comme celui-ci peuvent nous aider √† d√©terminer ce qui s‚Äôest mal pass√©, m√™me si ce n‚Äôest pas visible ou significatif pour l‚Äôutilisateur.</p>
</li>
</ul>
<h2>Lisibilit√©</h2>
<ul>
<li>Maintenant que nous savons utiliser des cha√Ænes de caract√®res dans nos programmes, nous pouvons analyser des paragraphes de texte pour √©valuer leur niveau de lisibilit√©, sur la base de facteurs tels que la longueur et la complexit√© des mots et des phrases.</li>
</ul>
<h2>Cryptage</h2>
<ul>
<li>Si nous voulons envoyer un message √† quelqu'un, nous pouvons vouloir le <strong>crypter</strong>, ou le brouiller en quelque sorte, pour qu'il soit difficile √† lire pour les autres. Le message original, ou l'entr√©e de notre algorithme, est appel√© <strong>texte en clair</strong>, et le message crypt√©, ou la sortie, est appel√© <strong>texte chiffr√©</strong>.</li>
<li>Un message comme <code>JE SUIS LA !</code> pourrait √™tre converti en ASCII, <code>72 73 33</code>. Mais n'importe qui pourrait le reconvertir en lettres.</li>
<li>Un algorithme de cryptage n√©cessite g√©n√©ralement une autre entr√©e, en plus du texte en clair. Une <strong>cl√©</strong> est n√©cessaire, et parfois ce n'est qu'un nombre qui est gard√© secret. Avec la cl√©, le texte en clair peut √™tre converti, via un algorithme, en texte chiffr√©, et vice versa.</li>
<li>Par exemple, si nous voulions envoyer un message comme <code>JE SUIS LA !</code>, nous pouvons d'abord le convertir en ASCII : <code>72 73 33</code>. Ensuite, nous pouvons le crypter avec une cl√© de seulement <code>1</code> et un algorithme simple, o√π nous ajoutons simplement la cl√© √† chaque valeur : <code>74 77 80 87 70 90 80 86</code>. Alors, quelqu'un qui reconvertit cet ASCII en texte verra <code>JF TOV LA !</code>. Pour d√©crypter ce message, quelqu'un devra conna√Ætre la cl√©.</li>
<li>Nous appliquerons ces concepts dans notre ensemble de probl√®mes !</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>