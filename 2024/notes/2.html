<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en FranÃ§ais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en FranÃ§ais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch ğŸ˜º
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        MÃ©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de DonnÃ©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        CybersÃ©curitÃ©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">HonnÃªtetÃ© AcadÃ©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions FrÃ©quemment PosÃ©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Ã‰quipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>LeÃ§on 2</h2>
<ul>
<li><a href="#compiling">Compilation</a></li>
<li><a href="#debugging">DÃ©bogage</a></li>
<li><a href="#help50-et-printf">help50 et printf</a></li>
<li><a href="#debug50">debug50</a></li>
<li><a href="#check50-et-style50">check50 et style50</a></li>
<li><a href="#types-de-donnÃ©es">Types de donnÃ©es</a></li>
<li><a href="#mÃ©moire">MÃ©moire</a></li>
<li><a href="#tableaux">Tableaux</a></li>
<li><a href="#chaÃ®nes">ChaÃ®nes</a></li>
<li><a href="#arguments-de-ligne-de-commande">Arguments de ligne de commande</a></li>
<li><a href="#lisibilitÃ©">LisibilitÃ©</a></li>
<li><a href="#cryptage">Cryptage</a></li>
</ul>
<h2>Compilation</h2>
<ul>
<li>La derniÃ¨re fois, nous avons appris Ã  Ã©crire notre premier programme en C. Nous avons appris la syntaxe de la fonction <code>main</code> dans notre programme, la fonction <code>printf</code> pour imprimer dans un terminal, comment crÃ©er des chaÃ®nes avec des guillemets doubles et comment inclure <code>stdio.h</code> pour la fonction <code>printf</code>.</li>
<li>Ensuite, nous l'avons compilÃ© avec <code>clang hello.c</code> pour pouvoir exÃ©cuter <code>./a.out</code> (le nom par dÃ©faut), puis <code>clang -o hello hello.c</code> (en transmettant un argument de ligne de commande pour le nom de la sortie) pour pouvoir exÃ©cuter <code>./hello</code>.</li>
<li>Si nous avons voulu utiliser la bibliothÃ¨que de CS50, via <code>#include &lt;cs50.h&gt;</code>, pour les chaÃ®nes et la fonction <code>get_string</code>, nous avons Ã©galement dÃ» ajouter un indicateurÂ : <code>clang -o hello hello.c -lcs50</code>. L'indicateur <code>-l</code> relie le fichier <code>cs50</code>, qui est dÃ©jÃ  installÃ© dans le bac Ã  sable CS50 et comprend des prototypes ou des dÃ©finitions de chaÃ®nes et de <code>get_string</code> (entre autres) auxquels notre programme peut ensuite se rÃ©fÃ©rer et les utiliser.</li>
<li>Nous Ã©crivons notre code source en C, mais nous devons le compiler en code machine, en binaire, avant que nos ordinateurs puissent l'exÃ©cuter.<ul>
<li><code>clang</code> est le compilateur et <code>make</code> est un utilitaire qui nous aide Ã  exÃ©cuter <code>clang</code> sans avoir Ã  indiquer toutes les options manuellement.</li>
</ul>
</li>
<li>La Â«Â compilationÂ Â» du code source en code machine est en rÃ©alitÃ© constituÃ©e d'Ã©tapes plus petitesÂ :<ul>
<li>PrÃ©traitement</li>
<li>Compilation</li>
<li>Assemblage</li>
<li>Liaison</li>
</ul>
</li>
<li>Le <strong>prÃ©traitement</strong> implique l'examen des lignes qui commencent par un <code>#</code>, comme <code>#include</code>, avant tout autre chose. Par exemple, <code>#include &lt;cs50.h&gt;</code> indiquera Ã  <code>clang</code> de rechercher d'abord ce fichier d'en-tÃªte, car il contient le contenu que nous souhaitons inclure dans notre programme. Ensuite, <code>clang</code> remplacera essentiellement le contenu de ces fichiers d'en-tÃªte dans notre programme.</li>
<li>
<p>Par exempleÂ â€¦</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("Name: ");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>â€¦ sera prÃ©traitÃ© enÂ :</p>
<pre><code>  string get_string(string prompt);
  int printf(const char *format, ...);

  int main(void)
  {
      string name = get_string("Name: ");
      printf("hello, %s\n", name);
  }
</code></pre>
</li>
<li>
<p>La <strong>compilation</strong> prend notre code source, en C, et le convertit en code assembleur, qui ressemble Ã  ceciÂ :</p>
<pre><code>  ...
  main:                         # @main
      .cfi_startproc
  # BB#0:
      pushq    %rbp
  .Ltmp0:
      .cfi_def_cfa_offset 16
  .Ltmp1:
      .cfi_offset %rbp, -16
      movq    %rsp, %rbp
  .Ltmp2:
      .cfi_def_cfa_register %rbp
      subq    $16, %rsp
      xorl    %eax, %eax
      movl    %eax, %edi
      movabsq    $.L.str, %rsi
      movb    $0, %al
      callq    get_string
      movabsq    $.L.str.1, %rdi
      movq    %rax, -8(%rbp)
      movq    -8(%rbp), %rsi
      movb    $0, %al
      callq    printf
      ...
</code></pre>
<ul>
<li>Ces instructions sont de plus bas niveau et se rapprochent des instructions binaires qu'un processeur d'ordinateur peut directement comprendre. Elles fonctionnent gÃ©nÃ©ralement sur des octets eux-mÃªmes, par opposition Ã  des abstractions comme les noms de variables.</li>
</ul>
</li>
<li>
<p>L'Ã©tape suivante consiste Ã  prendre le code assembleur et Ã  le traduire en instructions binaires en l'<strong>assemblant</strong>. Les instructions en binaire sont appelÃ©es <strong>code machine</strong>, qu'un processeur d'ordinateur peut exÃ©cuter directement.</p>
</li>
<li>La derniÃ¨re Ã©tape est la <strong>liaison</strong>, oÃ¹ le contenu des bibliothÃ¨ques prÃ©cÃ©demment compilÃ©es que nous souhaitons lier, comme <code>cs50.c</code>, sont rÃ©ellement combinÃ©es avec le binaire de notre programme. Nous nous retrouvons donc avec un fichier binaire, <code>a.out</code> ou <code>hello</code>, qui est la version compilÃ©e de <code>hello.c</code>, <code>cs50.c</code> et <code>printf.c</code>.</li>
</ul>
<h2>DÃ©bogage</h2>
<ul>
<li>Les bogues sont des erreurs involontaires qui surviennent dans les programmes. Le dÃ©bogage est le processus de recherche et de correction de ces bogues.</li>
</ul>
<h2>help50 et printf</h2>
<ul>
<li>
<p>Supposons que nous ayons Ã©crit ce programme, <code>buggy0.c</code>Â :</p>
<pre><code>  int main(void)
  {
      printf("hello, world\n");
  }
</code></pre>
<ul>
<li>Lorsque nous essayons de <code>make</code> ce programme, nous voyons une erreur (en rouge) indiquant que nous dÃ©clarons implicitement la fonction de bibliothÃ¨que <code>printf</code>. Nous ne comprenons pas vraiment cette erreur. Nous pouvons donc exÃ©cuter <code>help50 make buggy0</code>. Cela nous indiquera en fin de compte que nous avons peut-Ãªtre oubliÃ© dâ€™Ã©crire <code>#include &lt;stdio.h&gt;</code>, qui contient <code>printf</code>.</li>
</ul>
</li>
<li>
<p>Nous pouvons rÃ©essayer avec <code>buggy1.c</code>Â :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      string name = get_string("What's your name?\n");
      printf("hello, %s\n", name);
  }
</code></pre>
<ul>
<li>De nombreuses erreurs sâ€™affichent, et mÃªme la premiÃ¨re ne semble pas avoir beaucoup de sens. Nous pouvons donc Ã  nouveau exÃ©cuter <code>help50 make buggy1</code>. Cela nous indiquera que nous avons besoin de <code>cs50.h</code> car <code>string</code> nâ€™est pas dÃ©fini.</li>
</ul>
</li>
<li>
<p>Pour effacer la fenÃªtre du terminal (afin de ne voir que la sortie de ce que nous voulons exÃ©cuter ensuite), nous pouvons appuyer sur <code>control + L</code> ou taper <code>clear</code> comme commande dans la fenÃªtre du terminal.</p>
</li>
<li>
<p>Examinons <code>buggy2.c</code>Â :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      for (int i = 0; i &lt;= 10; i++)
      {
          printf("#\n");
      }
  }
</code></pre>
<ul>
<li>
<p>Hmm, nous avions lâ€™intention de ne voir que 10 <code>#</code>, mais il y en a 11. Si nous ne savions pas quel Ã©tait le problÃ¨me (car notre programme se compile sans aucune erreur, et nous avons maintenant une erreur logique), nous pourrions ajouter une autre ligne dâ€™impression pour nous aiderÂ :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      for (int i = 0; i &lt;= 10; i++)
      {
          printf("i est maintenant %iÂ : ", i);
          printf("#\n");
      }
  }
</code></pre>
</li>
<li>
<p>Maintenant, nous voyons que <code>i</code> a commencÃ© Ã  0 et a continuÃ© jusquâ€™Ã  10, mais nous devrions lâ€™arrÃªter lorsquâ€™il est Ã  10, avec <code>i &lt; 10</code> au lieu de <code>i &lt;= 10</code>.</p>
</li>
</ul>
</li>
</ul>
<h2>debug50</h2>
<ul>
<li>Aujourd'hui, nous allons Ã©galement jeter un Å“il Ã  CS50 IDE, qui est comme le bac Ã  sable de CS50, mais avec plus de fonctionnalitÃ©s. C'est un environnement de dÃ©veloppement en ligne, avec un Ã©diteur de code et une fenÃªtre de terminal, mais aussi des outils pour le dÃ©bogage et la collaborationÂ :
  <img alt="fenÃªtre de navigateur avec CS50 IDE, Ã©diteur de code sur le dessus avec buggy2.c, fenÃªtre de terminal en bas" src="https://cs50.harvard.edu/x/2020/notes/2/cs50_ide.png" /></li>
<li>Dans CS50 IDE, nous aurons un autre outil, <code>debug50</code>, pour nous aider Ã  dÃ©boguer les programmes.</li>
<li>Nous allons ouvrir <code>buggy2.c</code> et essayer de <code>faire buggy2</code>. Mais nous avons enregistrÃ© <code>buggy2.c</code> dans un dossier appelÃ© <code>src2</code>, nous devons donc exÃ©cuter <code>cd src2</code> pour changer notre rÃ©pertoire vers le bon. Le terminal de CS50 IDE nous rappellera dans quel rÃ©pertoire nous sommes, avec une invite comme <code>~/src/ $</code>. (Le <code>~</code> indique le rÃ©pertoire par dÃ©faut, ou le rÃ©pertoire home.)</li>
<li>Au lieu d'utiliser <code>printf</code>, nous pouvons Ã©galement dÃ©boguer notre programme de maniÃ¨re interactive. Nous pouvons ajouter un <em>point d'arrÃªt</em>, ou un indicateur pour une ligne de code oÃ¹ le dÃ©bogueur doit interrompre notre programme. Par exemple, on peut cliquer Ã  gauche de la ligne 5 de notre code, un cercle rouge apparaÃ®traÂ :
  <img alt="Ã©diteur de code avec une icÃ´ne rouge Ã  cÃ´tÃ© de la ligne 5 du code" src="https://cs50.harvard.edu/x/2020/notes/2/breakpoint.png" /></li>
<li>Maintenant, si on exÃ©cute <code>debug50 ./buggy2</code>, on verra le panneau de dÃ©bogage s'ouvrir Ã  droiteÂ :
  <img alt="panneau du dÃ©bogueur avec commandes, variables" src="https://cs50.harvard.edu/x/2020/notes/2/debugger_panel.png" /></li>
<li>On voit que la variable que nous avons crÃ©Ã©e, <code>i</code>, est dans la section <code>Variables locales</code>, et qu'elle a une valeur de <code>0</code>.</li>
<li>Notre point d'arrÃªt a interrompu notre programme aprÃ¨s la ligne 5, juste avant la ligne 7, car c'est la premiÃ¨re ligne de code qui peut Ãªtre exÃ©cutÃ©e. Pour continuer, nous avons quelques commandes dans le panneau du dÃ©bogueur. Le triangle bleu continuera notre programme jusqu'Ã  ce que nous atteignions un autre point d'arrÃªt ou la fin de notre programme. La flÃ¨che courbe Ã  sa droite va Â« passer outre Â» la ligne, l'exÃ©cuter et interrompre notre programme juste aprÃ¨s.</li>
<li>Nous utiliserons donc la flÃ¨che courbe pour exÃ©cuter la ligne suivante et voir ce qui change aprÃ¨s. Nous sommes Ã  la ligne <code>printf</code>, et en appuyant Ã  nouveau sur la flÃ¨che courbe, nous voyons un seul <code>#</code> imprimÃ© dans notre fenÃªtre de terminal. Avec un autre clic sur la flÃ¨che, nous voyons la valeur de <code>i</code> sur la droite changer Ã  <code>1</code>. Et nous pouvons continuer Ã  cliquer sur la flÃ¨che pour regarder notre programme s'exÃ©cuter, une ligne Ã  la fois.</li>
<li>Pour quitter le dÃ©bogueur, on peut appuyer sur <code>ctrl + C</code> pour arrÃªter le programme.</li>
<li>Nous pouvons gagner beaucoup de temps Ã  l'avenir en investissant un peu maintenant pour apprendre Ã  utiliser <code>debug50</code>Â !</li>
</ul>
<h2>check50 et style50</h2>
<ul>
<li>Nous pouvons exÃ©cuter une commande comme <code>check50 cs50/problems/hello</code>, oÃ¹ <code>check50</code> est un programme qui suivra les instructions identifiÃ©es par l'argument <code>cs50/problems/hello</code> pour tÃ©lÃ©charger, exÃ©cuter et tester notre programme sur les serveurs de CS50. Cela vÃ©rifiera l'exactitude de notre programme.<ul>
<li>Lors de l'Ã©criture de logiciels dans le monde rÃ©el, les dÃ©veloppeurs Ã©crivent gÃ©nÃ©ralement leurs propres tests pour s'assurer que leur code fonctionne comme prÃ©vu, d'autant plus que des fonctionnalitÃ©s sont ajoutÃ©es au mÃªme code.</li>
</ul>
</li>
<li><code>style50</code> est un autre programme qui vÃ©rifiera notre code pour des problÃ¨mes esthÃ©tiques, comme les espaces, de sorte que notre code soit plus lisible et maintenable. Par exemple, il se peut que notre indentation soit manquante. Et le <a href="https://cs50.readthedocs.io/style/c/">guide de style</a> inclura davantage d'explications sur ce que nous attendons.</li>
<li>Nous pouvons mÃªme utiliser le dÃ©bogage du canard en caoutchouc, une mÃ©thode oÃ¹ nous expliquons ce que nous essayons de faire Ã  un canard en caoutchouc, de sorte que nous rÃ©alisions ce que nous essayons de faire et ce que nous devons corriger.</li>
<li>Nous voulons Ã©galement Ã©crire notre code avec une bonne conception, oÃ¹ nous rÃ©solvons non seulement le problÃ¨me correctement, mais aussi bien, oÃ¹ nous faisons des choix raisonnables quant Ã  la faÃ§on dont notre programme s'exÃ©cute et faisons des compromis entre le temps, le coÃ»t de dÃ©veloppement et la mÃ©moire.</li>
</ul>
<h2>Types de donnÃ©es</h2>
<ul>
<li>En C, nous avons diffÃ©rents types de variables que nous pouvons utiliser pour stocker des donnÃ©esÂ :<ul>
<li>bool 1 octet</li>
<li>char 1 octet</li>
<li>int 4 octets</li>
<li>float 4 octets</li>
<li>long 8 octets</li>
<li>double 8 octets</li>
<li>string ? octets</li>
</ul>
</li>
<li>Chacun de ces types occupe un certain nombre d'octets par variable que nous crÃ©ons, et les tailles ci-dessus sont celles que le bac Ã  sable, l'IDE et trÃ¨s probablement votre ordinateur utilisent pour chaque type en C.</li>
</ul>
<h2>MÃ©moire</h2>
<ul>
<li>Ã€ l'intÃ©rieur de nos ordinateurs, nous avons des puces appelÃ©es RAM, mÃ©moire Ã  accÃ¨s alÃ©atoire, qui stockent des donnÃ©es pour une utilisation Ã  court terme. Nous pourrions enregistrer un programme ou un fichier sur notre disque dur (ou notre disque SSD) pour un stockage Ã  long terme, mais lorsque nous l'ouvrons, il est d'abord copiÃ© dans la RAM. Bien que la RAM soit beaucoup plus petite et temporaire (jusqu'Ã  ce que l'alimentation soit coupÃ©e), elle est beaucoup plus rapide.</li>
<li>On peut penser aux octets stockÃ©s dans la RAM comme s'ils Ã©taient dans une grilleÂ :<br />
<img alt="puce d'ordinateur avec grille superposÃ©e" src="https://cs50.harvard.edu/x/2020/notes/2/ram.png" /><ul>
<li>En rÃ©alitÃ©, il y a des millions ou des milliards d'octets par puce.</li>
</ul>
</li>
<li>En C, lorsque nous crÃ©ons une variable de type <code>char</code>, qui sera de taille un octet, elle sera physiquement stockÃ©e dans l'une de ces cases de la RAM. Un entier, avec 4 octets, prendra quatre de ces cases.</li>
<li>Et chacune de ces cases est Ã©tiquetÃ©e avec un numÃ©ro, ou une adresse, de 0 Ã  1, Ã  2, etc.</li>
</ul>
<h2>Tableaux</h2>
<ul>
<li>
<p>Disons que nous voulions stocker trois variablesÂ :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      char c1 = 'H';
      char c2 = 'I';
      char c3 = '!';
      printf("%c %c %c\n", c1, c2, c3);
  }
</code></pre>
<ul>
<li>Notez que nous utilisons des guillemets simples pour indiquer un caractÃ¨re littÃ©ral, et des guillemets doubles pour plusieurs caractÃ¨res ensemble dans une chaÃ®ne.</li>
<li>Nous pouvons compiler et exÃ©cuter ceci, pour voir <code>H I !</code>.</li>
</ul>
</li>
<li>
<p>Et nous savons que les caractÃ¨res ne sont que des nombres, donc si nous changeons le formatage de notre chaÃ®ne pour Ãªtre <code>printf("%i %i %i\n", c1, c2, c3);</code>, nous pouvons voir les valeurs numÃ©riques de chaque caractÃ¨re imprimÃ©Â : <code>72 73 33</code>.</p>
<ul>
<li>Nous pouvons convertir explicitement, ou caster, chaque caractÃ¨re en un int avant de lâ€™utiliser, avec <code>(int) c1</code>, mais notre compilateur peut le faire implicitement pour nous.</li>
</ul>
</li>
<li>Et en mÃ©moire, on peut avoir trois cases, Ã©tiquetÃ©es Â«Â c1Â Â», Â«Â c2Â Â» et Â«Â c3Â Â» dâ€™une certaine maniÃ¨re, chacune reprÃ©sentant un octet binaire avec les valeurs de chaque variable.</li>
<li>
<p>Regardons <code>scores0.c</code>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Scores
      int score1 = 72;
      int score2 = 73;
      int score3 = 33;

      // Print average
      printf("Average: %i\n", (score1 + score2 + score3) / 3);
  }
</code></pre>
<ul>
<li>Nous pouvons imprimer la moyenne de trois nombres, mais maintenant nous devons crÃ©er une variable pour chaque score que nous voulons inclure, et nous ne pouvons pas les utiliser facilement plus tard.</li>
</ul>
</li>
<li>
<p>Il sâ€™avÃ¨re quâ€™en mÃ©moire, nous pouvons stocker des variables les unes aprÃ¨s les autres, dos Ã  dos. Et en C, une liste de variables stockÃ©es, les unes aprÃ¨s les autres dans un bloc contigu de mÃ©moire, est appelÃ©e un <strong>tableau</strong>.</p>
</li>
<li>Par exemple, nous pouvons utiliser <code>int scores[3];</code> pour dÃ©clarer un tableau de 3 entiers.</li>
<li>
<p>Et nous pouvons assigner et utiliser des variables dans un tableau avecÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Scores
      int scores[3];
      scores[0] = 72;
      scores[1] = 73;
      scores[2] = 33;

      // Print average
      printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
  }
</code></pre>
<ul>
<li>Notez que les tableaux sont indexÃ©s Ã  zÃ©ro, ce qui signifie que le premier Ã©lÃ©ment, ou valeur, a lâ€™index 0.</li>
</ul>
</li>
<li>
<p>Et nous avons rÃ©pÃ©tÃ© la valeur 3, reprÃ©sentant la longueur de notre tableau, Ã  deux endroits diffÃ©rents. Nous pouvons donc utiliser une constante, ou une valeur fixe, pour indiquer quâ€™elle doit toujours Ãªtre la mÃªme aux deux endroitsÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  const int N = 3;

  int main(void)
  {
      // Scores
      int scores[N];
      scores[0] = 72;
      scores[1] = 73;
      scores[2] = 33;

      // Print average
      printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / N);
  }
</code></pre>
<ul>
<li>Nous pouvons utiliser le mot-clÃ© <code>const</code> pour dire au compilateur que la valeur de <code>N</code> ne doit jamais Ãªtre modifiÃ©e par notre programme. Et par convention, nous placerons notre dÃ©claration de variable en dehors de la fonction <code>main</code> et mettrons son nom en majuscule, ce qui nâ€™est pas nÃ©cessaire pour le compilateur, mais qui montre aux autres humains que cette variable est une constante et la rend facile Ã  voir depuis le dÃ©but.</li>
</ul>
</li>
<li>
<p>Avec un tableau, nous pouvons collecter nos scores dans une boucle, et y accÃ©der plus tard dans une boucle Ã©galementÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  float average(int length, int array[]);

  int main(void)
  {
      // Get number of scores
      int n = get_int("Scores:  ");

      // Get scores
      int scores[n];
      for (int i = 0; i &lt; n; i++)
      {
          scores[i] = get_int("Score %i: ", i + 1);
      }

      // Print average
      printf("Average: %.1f\n", average(n, scores));
  }

  float average(int length, int array[])
  {
      int sum = 0;
      for (int i = 0; i &lt; length; i++)
      {
          sum += array[i];
      }
      return (float) sum / (float) length;
  }
</code></pre>
<ul>
<li>Tout dâ€™abord, nous demandons Ã  lâ€™utilisateur le nombre de scores quâ€™il a, crÃ©ons un tableau avec suffisamment dâ€™entiers pour le nombre de scores quâ€™il a, et utilisons une boucle pour collecter tous les scores.</li>
<li>Ensuite, nous Ã©crivons une fonction dâ€™assistance, <code>average</code>, pour renvoyer un <code>float</code> ou une valeur dÃ©cimale. Nous passerons la longueur et un tableau de <code>int</code> (qui peut Ãªtre de nâ€™importe quelle taille), et utiliserons une autre boucle dans notre fonction dâ€™assistance pour additionner les valeurs dans une somme. Nous utilisons <code>(float)</code> pour caster Ã  la fois <code>sum</code> et <code>length</code> en floats, donc le rÃ©sultat que nous obtenons en divisant les deux est aussi un float.</li>
<li>Enfin, lorsque nous imprimons le rÃ©sultat obtenu, nous utilisons <code>%.1f</code> pour nâ€™afficher quâ€™une dÃ©cimale.</li>
</ul>
</li>
<li>
<p>En mÃ©moire, notre tableau est maintenant stockÃ© comme ceci, oÃ¹ chaque valeur occupe non pas un mais quatre octetsÂ :
  <img alt="grille avec 72 Ã©tiquetÃ© score1, 73 Ã©tiquetÃ© score2, 33 Ã©tiquetÃ© score3, chacun occupant quatre cases, et de nombreuses cases vides suivent" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_array.png" /></p>
</li>
</ul>
<h2>Strings</h2>
<ul>
<li>Les strings sont en fait simplement des tableaux de caractÃ¨res. Si nous avons une string <code>s</code>, chaque caractÃ¨re peut Ãªtre accÃ©dÃ© avec <code>s[0]</code>, <code>s[1]</code>, et ainsi de suite.
-Â Et il s'avÃ¨re qu'une string se termine par un caractÃ¨re spÃ©cial, â€˜\0â€™, ou un octet avec tous les bits Ã  0. Ce caractÃ¨re est appelÃ© caractÃ¨re nul, ou caractÃ¨re terminateur nul. Nous avons donc en rÃ©alitÃ© besoin de quatre octets pour stocker notre string "HI!" :<br />
<img alt=" Grille avec H Ã©tiquetÃ© s[0], I Ã©tiquetÃ© s[1], ! Ã©tiquetÃ© s[2], \0 Ã©tiquetÃ© s[3], chacun prenant une case et de nombreuses autres cases vides sont Ã  la suite" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_string.png" /></li>
<li>
<p>Voyons maintenant Ã  quoi peuvent ressembler quatre strings dans un tableauÂ :</p>
<pre><code>  string noms[4]Â ;
  noms[0] = "EMMA"Â ;
  noms[1] = "RODRIGO"Â ;
  noms[2] = "BRIAN"Â ;
  noms[3] = "DAVID"Â ;

  printf("%s\n", noms[0])Â ;
  printf("%c%c%c%c\n", noms[0][0], noms[0][1], noms[0][2], noms[0][3])Â ;
</code></pre>
<ul>
<li>Nous pouvons imprimer la premiÃ¨re valeur de <code>noms</code> sous forme de string ou rÃ©cupÃ©rer la premiÃ¨re string et obtenir chaque caractÃ¨re individuel dans cette string en utilisant <code>[]</code> Ã  nouveau. (Nous pouvons considÃ©rer cela comme <code>(noms[0])[0]</code>, bien que nous nâ€™en ayons pas besoin les parenthÃ¨ses.)</li>
<li>Et bien que nous sachions que le prÃ©nom avait quatre caractÃ¨res, <code>printf</code> a probablement utilisÃ© une boucle pour regarder chaque caractÃ¨re de la string, les imprimant un Ã  la fois jusqu'Ã  atteindre le caractÃ¨re nul qui marque la fin de la string. Et en fait, nous pouvons imprimer <code>noms[0][4]</code> sous forme dâ€™<code>int</code> avec <code>%i</code>, et voir un <code>0</code> sâ€™afficher.</li>
</ul>
</li>
<li>
<p>Nous pouvons visualiser chaque caractÃ¨re avec sa propre Ã©tiquette en mÃ©moireÂ :<br />
<img alt=" Grille avec E Ã©tiquetÃ© noms[0][0], M Ã©tiquetÃ© noms[0][1], etc. jusqu'Ã  noms[3][5] avec un \0, chacun prenant une case et des cases vides suivent" src="https://cs50.harvard.edu/x/2020/notes/2/memory_with_string_array.png" /></p>
</li>
<li>
<p>Nous pouvons essayer d'expÃ©rimenter avec <code>string0.c</code>Â :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("EntrÃ©eÂ : ");
      printf("SortieÂ : ");
      for (int i = 0; i &lt; strlen(s); i++)
      {
          printf("%c", s[i]);
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Nous pouvons utiliser la condition <code>s[i] != '\0'</code>, oÃ¹ nous pouvons vÃ©rifier le caractÃ¨re actuel et lâ€™imprimer uniquement sâ€™il ne sâ€™agit pas du caractÃ¨re nul.</li>
<li>Nous pouvons Ã©galement utiliser la longueur de la string, mais nous avons dâ€™abord besoin dâ€™une nouvelle bibliothÃ¨que, <code>string.h</code>, pour <code>strlen</code>, qui nous indique la longueur dâ€™une string.</li>
</ul>
</li>
<li>
<p>Nous pouvons amÃ©liorer la conception de notre programme. <code>string0</code> Ã©tait un peu inefficace, car nous vÃ©rifions la longueur de la string, aprÃ¨s que chaque caractÃ¨re est imprimÃ©, dans notre condition. Mais comme la longueur de la string ne change pas, nous pouvons vÃ©rifier la longueur de la string une foisÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("EntrÃ©eÂ : ");
      printf("SortieÂ :\n");
      for (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          printf("%c\n", s[i]);
      }
  }
</code></pre>
<ul>
<li>Maintenant, au dÃ©but de notre boucle, nous initialisons une variable <code>i</code> et <code>n</code>, et mÃ©morisons la longueur de notre string dans <code>n</code>. Ensuite, nous pouvons vÃ©rifier les valeurs Ã  chaque fois, sans avoir Ã  calculer rÃ©ellement la longueur de la string.
-Â Et nous avons effectivement eu besoin dâ€™un peu plus de mÃ©moire pour <code>n</code>, mais cela nous fait gagner du temps en nâ€™ayant pas Ã  vÃ©rifier la longueur de la string Ã  chaque fois.</li>
</ul>
</li>
<li>
<p>Nous pouvons maintenant combiner ce que nous avons vu pour Ã©crire un programme capable de mettre en majuscules des lettres :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Avant : ");
      printf("AprÃ¨s :  ");
      for (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z')
          {
              printf("%c", s[i] - 32);
          }
          else
          {
              printf("%c", s[i]);
          }
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Tout d'abord, nous obtenons une chaÃ®ne <code>s</code>. Ensuite, pour chaque caractÃ¨re dans la chaÃ®ne, s'il est en minuscule (sa valeur est entre celle de <code>a</code> et <code>z</code>), nous le convertissons en majuscule. Sinon, nous l'imprimons simplement.</li>
<li>Nous pouvons convertir une lettre minuscule en son Ã©quivalent en majuscule en soustrayant la diffÃ©rence entre leurs valeurs ASCII. (Nous savons que les lettres minuscules ont une valeur ASCII plus Ã©levÃ©e que les lettres majuscules, et la diffÃ©rence est commodÃ©ment la mÃªme entre les mÃªmes lettres, nous pouvons donc soustraire cette diffÃ©rence pour obtenir une lettre majuscule Ã  partir d'une lettre minuscule.)</li>
</ul>
</li>
<li>
<p>Nous pouvons utiliser les <a href="https://man.cs50.io/"><strong>pages de manuel</strong></a>, ou le manuel du programmeur, pour trouver les fonctions de bibliothÃ¨que que nous pouvons utiliser pour accomplir la mÃªme chose :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;ctype.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string s = get_string("Avant : ");
      printf("AprÃ¨s :  ");
      for (int i = 0, n = strlen(s); i &lt; n; i++)
      {
          printf("%c", toupper(s[i]));
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>En recherchant dans les pages du manuel, nous voyons <code>toupper()</code> est une fonction, entre autres, d'une bibliothÃ¨que appelÃ©e <code>ctype</code>, que nous pouvons utiliser.</li>
</ul>
</li>
</ul>
<h2>Arguments de ligne de commande</h2>
<ul>
<li>Nous avons utilisÃ© des programmes tels que <code>make</code> et <code>clang</code>, qui prennent des mots supplÃ©mentaires aprÃ¨s leur nom sur la ligne de commande. Il sâ€™avÃ¨re que nos propres programmes peuvent Ã©galement prendre des <strong>arguments de ligne de commande</strong>.</li>
<li>
<p>Dans <code>argv.c</code>, nous modifions lâ€™apparence de notre fonction <code>main</code>Â :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(int argc, string argv[])
  {
      if (argc == 2)
      {
          printf("bonjour, %s\n", argv[1]);
      }
      else
      {
          printf("bonjour, le monde\n");
      }
  }
</code></pre>
<ul>
<li><code>argc</code> et <code>argv</code> sont deux variables que notre fonction <code>main</code> reÃ§oit dÃ©sormais lorsque notre programme est exÃ©cutÃ© depuis la ligne de commande. <code>argc</code> est le nombre dâ€™arguments ou le nombre dâ€™arguments, et <code>argv</code> est un tableau de chaÃ®nes qui sont les arguments. Et le premier argument, <code>argv [0]</code>, est le nom de notre programme (le premier mot tapÃ©, comme <code>./hello</code>). Dans cet exemple, nous vÃ©rifions si nous avons deux arguments et, le cas Ã©chÃ©ant, nous affichons le second.</li>
<li>Par exemple, si nous exÃ©cutons <code>./argv David</code>, nous obtiendrons <code>bonjour, David</code> imprimÃ©, puisque nous avons tapÃ© <code>David</code> comme deuxiÃ¨me mot dans notre commande.</li>
</ul>
</li>
<li>
<p>Il sâ€™avÃ¨re que nous pouvons indiquer les erreurs dans notre programme en renvoyant une valeur depuis notre fonction <code>main</code> (comme indiquÃ© par lâ€™<code>int</code> avant notre fonction <code>main</code>). Par dÃ©faut, notre fonction <code>main</code> renvoie <code>0</code> pour indiquer que rien ne sâ€™est mal passÃ©, mais nous pouvons Ã©crire un programme pour renvoyer une valeur diffÃ©renteÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(int argc, string argv[])
  {
      if (argc != 2)
      {
          printf("argument de ligne de commande manquant\n");
          return 1;
      }
      printf("bonjour, %s\n", argv[1]);
      return 0;
  }
</code></pre>
<ul>
<li>La valeur de retour de <code>main</code> dans notre programme est appelÃ©e code de sortie.</li>
</ul>
</li>
<li>
<p>Au fur et Ã  mesure que nous Ã©crivons des programmes plus complexes, des codes dâ€™erreur comme celui-ci peuvent nous aider Ã  dÃ©terminer ce qui sâ€™est mal passÃ©, mÃªme si ce nâ€™est pas visible ou significatif pour lâ€™utilisateur.</p>
</li>
</ul>
<h2>LisibilitÃ©</h2>
<ul>
<li>Maintenant que nous savons utiliser des chaÃ®nes de caractÃ¨res dans nos programmes, nous pouvons analyser des paragraphes de texte pour Ã©valuer leur niveau de lisibilitÃ©, sur la base de facteurs tels que la longueur et la complexitÃ© des mots et des phrases.</li>
</ul>
<h2>Cryptage</h2>
<ul>
<li>Si nous voulons envoyer un message Ã  quelqu'un, nous pouvons vouloir le <strong>crypter</strong>, ou le brouiller en quelque sorte, pour qu'il soit difficile Ã  lire pour les autres. Le message original, ou l'entrÃ©e de notre algorithme, est appelÃ© <strong>texte en clair</strong>, et le message cryptÃ©, ou la sortie, est appelÃ© <strong>texte chiffrÃ©</strong>.</li>
<li>Un message comme <code>JE SUIS LA !</code> pourrait Ãªtre converti en ASCII, <code>72 73 33</code>. Mais n'importe qui pourrait le reconvertir en lettres.</li>
<li>Un algorithme de cryptage nÃ©cessite gÃ©nÃ©ralement une autre entrÃ©e, en plus du texte en clair. Une <strong>clÃ©</strong> est nÃ©cessaire, et parfois ce n'est qu'un nombre qui est gardÃ© secret. Avec la clÃ©, le texte en clair peut Ãªtre converti, via un algorithme, en texte chiffrÃ©, et vice versa.</li>
<li>Par exemple, si nous voulions envoyer un message comme <code>JE SUIS LA !</code>, nous pouvons d'abord le convertir en ASCII : <code>72 73 33</code>. Ensuite, nous pouvons le crypter avec une clÃ© de seulement <code>1</code> et un algorithme simple, oÃ¹ nous ajoutons simplement la clÃ© Ã  chaque valeur : <code>74 77 80 87 70 90 80 86</code>. Alors, quelqu'un qui reconvertit cet ASCII en texte verra <code>JF TOV LA !</code>. Pour dÃ©crypter ce message, quelqu'un devra connaÃ®tre la clÃ©.</li>
<li>Nous appliquerons ces concepts dans notre ensemble de problÃ¨mes !</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>