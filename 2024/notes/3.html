<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en FranÃ§ais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en FranÃ§ais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch ğŸ˜º
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        MÃ©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de DonnÃ©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        CybersÃ©curitÃ©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">HonnÃªtetÃ© AcadÃ©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions FrÃ©quemment PosÃ©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Ã‰quipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>LeÃ§on 3</h2>
<ul>
<li><a href="#recherche">Recherche</a></li>
<li><a href="#big-o">Big O</a></li>
<li><a href="#recherche-linÃ©aire">Recherche linÃ©aire</a></li>
<li><a href="#structures">Structures</a></li>
<li><a href="#tri">Tri</a></li>
<li><a href="#tri-par-sÃ©lection">Tri par sÃ©lection</a></li>
<li><a href="#rÃ©cursivitÃ©">RÃ©cursivitÃ©</a></li>
<li><a href="#tri-fusion">Tri fusion</a></li>
</ul>
<h2>Recherche</h2>
<ul>
<li>La derniÃ¨re fois, nous avons parlÃ© de la mÃ©moire d'un ordinateur, ou RAM, et comment nos donnÃ©es peuvent Ãªtre stockÃ©es sous forme de variables individuelles ou sous forme de tableaux de plusieurs Ã©lÃ©ments.</li>
<li>Nous pouvons considÃ©rer un tableau contenant un certain nombre d'Ã©lÃ©ments comme une rangÃ©e de casiers, oÃ¹ un ordinateur ne peut ouvrir qu'un casier Ã  la fois pour examiner un Ã©lÃ©ment.</li>
<li>Par exemple, si nous voulons vÃ©rifier si un nombre se trouve dans un tableau, avec un algorithme qui prend en entrÃ©e un tableau et produit un boolÃ©en en rÃ©sultat, nous pourrionsÂ :
    - regarder dans chaque casier, ou dans chaque Ã©lÃ©ment, un Ã  la fois, du dÃ©but Ã  la fin.
        - Cela s'appelle <strong>recherche linÃ©aire</strong>, oÃ¹ nous nous dÃ©plaÃ§ons en ligne, car notre tableau n'est pas triÃ©.
    - commencer au milieu et se dÃ©placer Ã  gauche ou Ã  droite en fonction de ce que nous recherchons, si notre tableau d'Ã©lÃ©ments est triÃ©.
        - Cela s'appelle <strong>recherche binaire</strong>, car nous pouvons diviser notre problÃ¨me en deux Ã  chaque Ã©tape, comme ce que David a fait avec l'annuaire tÃ©lÃ©phonique Ã  la semaineÂ 0.</li>
<li>
<p>Nous pourrions Ã©crire un pseudo-code pour la recherche linÃ©aire avecÂ :</p>
<pre><code>  Pour i de 0 Ã  n-1
      Si le i-Ã¨me Ã©lÃ©ment est 50
          Retourner vrai
  Retourner faux
</code></pre>
<ul>
<li>Nous pouvons Ã©tiqueter chacun des <code>n</code> casiers de <code>0</code> Ã  <code>n-1</code> et les cocher chacun dans l'ordre.</li>
</ul>
</li>
<li>
<p>Pour la recherche binaire, notre algorithme pourrait ressembler Ã Â :</p>
<pre><code>  Si aucun Ã©lÃ©ment
      Retourner faux
  Si l'Ã©lÃ©ment du milieu est 50
      Retourner vrai
  Sinon si 50 &lt; Ã©lÃ©ment du milieu
      Rechercher dans la moitiÃ© gauche
  Sinon si 50 &gt; Ã©lÃ©ment du milieu
      Rechercher dans la moitiÃ© droite
</code></pre>
<ul>
<li>Ã‰ventuellement, il ne nous restera aucune partie du tableau (si l'Ã©lÃ©ment que nous recherchons n'y Ã©tait pas), nous pouvons donc retourner <code>faux</code>.</li>
<li>Sinon, nous pouvons rechercher dans chaque moitiÃ© en fonction de la valeur de l'Ã©lÃ©ment du milieu.</li>
</ul>
</li>
</ul>
<h2>Notation O (grand O)</h2>
<ul>
<li>Pendant la semaine 0, nous avons vu diffÃ©rents types d'algorithmes et leurs temps d'exÃ©cution : <img alt="graphics with: &quot;size of a problem&quot; as xâ€“axis; &quot;time to solve&quot; as yâ€“axis; red, steep straight line from origin to top of graph labeled &quot;n&quot;; yellow, less steep straight line from origin to top of graph labeled &quot;n/2&quot;; green, curved line that gets less and less steep from origin to right of graph labeled &quot;log_2 n&quot;" src="https://cs50.harvard.edu/x/2020/notes/3/running_time.png" /></li>
<li>Une maniÃ¨re plus formelle de dÃ©crire cela est d'utiliser la notation O, que nous pouvons comprendre comme Â« de l'ordre de Â». Par exemple, si notre algorithme est une recherche linÃ©aire, il prendra environ O(n) mesures, Â« de l'ordre de n Â». En fait, mÃªme un algorithme qui examine deux Ã©lÃ©ments Ã  la fois et prend n/2 mesures a O(n). En effet, Ã  mesure que n devient de plus en plus grand, seul le terme le plus grand, n, a de l'importance.</li>
<li>De mÃªme, un temps d'exÃ©cution logarithmique est O(log n), quelle que soit la base, car il ne s'agit que d'une approximation de ce qui se passe lorsque n est trÃ¨s grand.</li>
<li>Voici quelques temps d'exÃ©cution courants :<ul>
<li>O(nÂ²)</li>
<li>O(n log n)</li>
<li>O(n)<ul>
<li>(recherche linÃ©aire)</li>
</ul>
</li>
<li>O(log n)<ul>
<li>(recherche binaire)</li>
</ul>
</li>
<li>O(1)</li>
</ul>
</li>
<li>Les informaticiens peuvent Ã©galement utiliser la notation OmÃ©ga majuscule, qui reprÃ©sente la borne infÃ©rieure du nombre d'Ã©tapes de notre algorithme. (O majuscule est la borne supÃ©rieure du nombre d'Ã©tapes, ou le pire des cas, et gÃ©nÃ©ralement ce qui nous importe le plus.) Avec la recherche linÃ©aire, par exemple, le pire des cas est de n Ã©tapes, mais le meilleur cas est de 1 Ã©tape puisque notre Ã©lÃ©ment pourrait Ãªtre le premier Ã©lÃ©ment que nous vÃ©rifions. Le meilleur cas pour la recherche binaire est Ã©galement de 1, car notre Ã©lÃ©ment peut se trouver au milieu du tableau.</li>
<li>Et nous avons un ensemble similaire des temps d'exÃ©cution OmÃ©ga majuscule les plus courants :<ul>
<li>Î©(nÂ²)</li>
<li>Î©(n log n)</li>
<li>Î©(n)<ul>
<li>(comptage du nombre d'Ã©lÃ©ments)</li>
</ul>
</li>
<li>Î©(log n)</li>
<li>Î©(1)<ul>
<li>(recherche linÃ©aire, recherche binaire)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Recherche linÃ©aire</h2>
<ul>
<li>
<p>Jetons un coup d'Å“il Ã  <code>numbers.c</code>Â :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Un tableau de nombres
      int numbers[] = {4, 8, 15, 16, 23, 42};

      // Rechercher 50
      for (int i = 0; i &lt; 6; i++)
      {
          if (numbers[i] == 50)
          {
              printf("TrouvÃ©\n");
              return 0;
          }
      }
      printf("Non trouvÃ©\n");
      return 1;
  }
</code></pre>
</li>
<li>
<p>Ici, nous initialisons un tableau avec quelques valeurs, et nous vÃ©rifions les Ã©lÃ©ments du tableau un par un, dans l'ordre.</p>
</li>
<li>
<p>Et dans chaque cas, selon que la valeur a Ã©tÃ© trouvÃ©e ou non, nous pouvons renvoyer un code de sortie de 0 (pour le succÃ¨s) ou de 1 (pour l'Ã©chec).</p>
</li>
<li>
<p>Nous pouvons faire la mÃªme chose pour les nomsÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      // Un tableau de noms
      string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};

      // Rechercher EMMA
      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(names[i], "EMMA") == 0)
          {
              printf("TrouvÃ©\n");
              return 0;
          }
      }
      printf("Non trouvÃ©\n");
      return 1;
  }
</code></pre>
</li>
<li>
<p>Nous ne pouvons pas comparer directement des chaÃ®nes de caractÃ¨res, car ce ne sont pas des types de donnÃ©es simples mais plutÃ´t un tableau de plusieurs caractÃ¨res, et nous devons les comparer diffÃ©remment. Heureusement, la bibliothÃ¨que <code>string</code> a une fonction <code>strcmp</code> qui compare les chaÃ®nes de caractÃ¨res pour nous et renvoie <code>0</code> si elles sont identiques. Nous pouvons donc l'utiliser.</p>
</li>
<li>
<p>Essayons d'implÃ©menter un annuaire tÃ©lÃ©phonique avec les mÃªmes idÃ©esÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
      string numbers[] = {"617â€“555â€“0100", "617â€“555â€“0101", "617â€“555â€“0102", "617â€“555â€“0103"};

      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(names[i], "EMMA") == 0)
          {
              printf("TrouvÃ© %s\n", numbers[i]);
              return 0;
          }
      }
      printf("Non trouvÃ©\n");
      return 1;
  }
</code></pre>
</li>
<li>
<p>Nous utiliserons des chaÃ®nes de caractÃ¨res pour les numÃ©ros de tÃ©lÃ©phone, car ils peuvent inclure un formatage ou Ãªtre trop longs pour un nombre.</p>
</li>
<li>Maintenant, si le nom Ã  un certain index dans le tableau <code>names</code> correspond Ã  celui que nous recherchons, nous renverrons le numÃ©ro de tÃ©lÃ©phone dans le tableau <code>numbers</code>, au mÃªme index. Mais cela signifie que nous devons Ãªtre particuliÃ¨rement attentifs pour nous assurer que chaque numÃ©ro correspond au nom Ã  chaque index, surtout si nous ajoutons ou supprimons des noms et des numÃ©ros.</li>
</ul>
<h2>Structures</h2>
<ul>
<li>
<p>Il s'avÃ¨re que nous pouvons crÃ©er nos propres types de donnÃ©es personnalisÃ©s appelÃ©s <strong>structuresÂ </strong>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  typedef struct
  {
      string name;
      string number;
  }
  person;

  int main(void)
  {
      person people[4];

      people[0].name = "EMMA";
      people[0].number = "617â€“555â€“0100";

      people[1].name = "RODRIGO";
      people[1].number = "617â€“555â€“0101";

      people[2].name = "BRIAN";
      people[2].number = "617â€“555â€“0102";

      people[3].name = "DAVID";
      people[3].number = "617â€“555â€“0103";

      // Recherche EMMA
      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(people[i].name, "EMMA") == 0)
          {
              printf("Found %s\n", people[i].number);
              return 0;
          }
      }
      printf("Not found\n");
      return 1;
  }
</code></pre>
</li>
<li>
<p>Nous pouvons considÃ©rer les structures comme des conteneurs, Ã  l'intÃ©rieur desquels se trouvent plusieurs autres types de donnÃ©es.</p>
</li>
<li>Ici, nous crÃ©ons notre propre type avec une structure appelÃ©e <code>personne</code>, qui aura une <code>chaÃ®ne</code> appelÃ©e <code>nom</code> et une <code>chaÃ®ne</code> appelÃ©e <code>numÃ©ro</code>. Ensuite, nous pouvons crÃ©er un tableau de ces types de structure et initialiser les valeurs Ã  l'intÃ©rieur de chacun d'eux, en utilisant une nouvelle syntaxe, <code>.</code>, pour accÃ©der aux propriÃ©tÃ©s de chaque <code>personne</code>.</li>
<li>Dans notre boucle, nous pouvons maintenant Ãªtre plus certains que le <code>numÃ©ro</code> correspond au <code>nom</code> puisqu'ils proviennent du mÃªme Ã©lÃ©ment <code>personne</code>.</li>
</ul>
<h2>Tri</h2>
<ul>
<li>Si notre entrÃ©e est une liste non triÃ©e de nombres, il existe de nombreux algorithmes que nous pourrions utiliser pour produire une liste triÃ©e en sortie.</li>
<li>Avec huit volontaires sur scÃ¨ne ayant les numÃ©ros suivants, nous pourrions envisager d'Ã©changer les paires de nombres voisins comme premiÃ¨re Ã©tape.</li>
<li>
<p>Nos volontaires commencent dans l'ordre alÃ©atoire suivantÂ :</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>Nous examinons les deux premiers nombres et les Ã©changeons pour qu'ils soient dans l'ordreÂ :</p>
<pre><code>  6 3 8 5 2 7 4 1
  â€“ â€“
  3 6 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>La paire suivante, <code>6</code> et <code>8</code>, est dans l'ordre, nous n'avons donc pas besoin de les Ã©changer.</p>
</li>
<li>
<p>La paire suivante, <code>8</code> et <code>5</code>, doit Ãªtre Ã©changÃ©eÂ :</p>
<pre><code>  3 6 8 5 2 7 4 1
      â€“ â€“
  3 6 5 8 2 7 4 1
</code></pre>
</li>
<li>
<p>Nous continuons jusqu'Ã  ce que nous atteignions la fin de la listeÂ :</p>
<pre><code>  3 6 5 2 8 7 4 1
          â€“ â€“
  3 6 5 2 7 8 4 1
            â€“ â€“
  3 6 5 2 7 4 8 1
              â€“ â€“
  3 6 5 2 7 4 1 8
</code></pre>
</li>
<li>
<p>Notre liste n'est pas encore triÃ©e, mais nous sommes un peu plus prÃ¨s de la solution parce que la plus grande valeur, <code>8</code>, a Ã©tÃ© dÃ©placÃ©e complÃ¨tement vers la droite.</p>
</li>
<li>
<p>Nous rÃ©pÃ©tons ceci avec un autre passage sur la listeÂ :</p>
<pre><code>  3 6 5 2 7 4 1 8
  â€“ â€“
  3 6 5 2 7 4 1 8
    â€“ â€“
  3 5 6 2 7 4 1 8
      â€“ â€“
  3 5 2 6 7 4 1 8
        â€“ â€“
  3 5 2 6 7 4 1 8
          â€“ â€“
  3 5 2 6 4 7 1 8
              â€“ â€“
  3 5 2 6 4 1 7 8
</code></pre>
<ul>
<li>Notez que nous n'avions pas besoin d'Ã©changer le 3 et le 6, ou le 6 et le 7.</li>
</ul>
</li>
<li>
<p>Maintenant, la deuxiÃ¨me plus grande valeur, <code>7</code>, est dÃ©placÃ©e complÃ¨tement vers la droite. Si nous rÃ©pÃ©tons cela, de plus en plus de la liste sera triÃ©e et assez rapidement, nous aurons une liste entiÃ¨rement triÃ©e.</p>
</li>
<li>
<p>Cet algorithme est appelÃ© <strong>tri Ã  bulles</strong>, oÃ¹ les grandes valeurs Â«Â bullentÂ Â» vers la droite. Le pseudo-code pour cela pourrait ressembler Ã Â :</p>
<pre><code>  RÃ©pÃ©ter nâ€“1 fois
      Pour i de 0 Ã  nâ€“2
          Si le iÃ¨me et le i+1Ã¨me Ã©lÃ©ments sont dÃ©sordonnÃ©s
              Les Ã©changer
</code></pre>
<ul>
<li>Puisque nous comparons le iÃ¨me et le i+1Ã¨me Ã©lÃ©ment, nous n'avons besoin d'aller que jusqu'Ã  <em>n</em> â€“ 2 pour <code>i</code>. Ensuite, nous Ã©changeons les deux Ã©lÃ©ments s'ils sont dÃ©sordonnÃ©s.</li>
<li>Et nous pouvons arrÃªter aprÃ¨s avoir fait <em>n</em> â€“ 1 passages, puisque nous savons que les nâ€“1 plus grands Ã©lÃ©ments auront bullÃ© vers la droite.</li>
</ul>
</li>
<li>
<p>Nous avons <em>n</em> â€“ 2 Ã©tapes pour la boucle interne et <em>n</em> â€“ 1 boucles, nous obtenons donc <em>n_2 â€“ 3_n</em> + 2 Ã©tapes au total. Mais le plus grand facteur, ou terme dominant, est <em>n_2, car <code>n</code> devient de plus en plus grand, donc nous pouvons dire que le tri Ã  bulles est _O</em>(_n_2).</p>
</li>
<li>Nous avons vu des temps d'exÃ©cution comme ce qui suit, et donc mÃªme si la recherche binaire est beaucoup plus rapide que la recherche linÃ©aire, cela pourrait ne pas valoir la peine de trier d'abord la liste, Ã  moins que nous ne fassions beaucoup de recherches au fil du tempsÂ :<ul>
<li><em>O</em>(_n_2)<ul>
<li>Tri Ã  bulles</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>Recherche linÃ©aire</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>Recherche binaire</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>Et Î© pour le tri Ã  bulles est toujours <em>n_2, puisque nous vÃ©rifions toujours chaque paire d'Ã©lÃ©ments pour _n</em> â€“ 1 passages.</li>
</ul>
<h2>Tri par sÃ©lection</h2>
<ul>
<li>
<p>Adoptons une autre approche avec le mÃªme ensemble de nombresÂ :</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>D'abord, examinons chaque nombre et mÃ©morisons le plus petit rencontrÃ©. Ensuite, nous pouvons l'Ã©changer avec le premier nombre de notre liste, puisque nous savons que c'est le plus petitÂ :</p>
<pre><code>  6 3 8 5 2 7 4 1
  â€“             â€“
  1 3 8 5 2 7 4 6
</code></pre>
</li>
<li>
<p>Nous savons dÃ©sormais qu'au moins le premier Ã©lÃ©ment de notre liste est Ã  la bonne place. Nous pouvons donc rechercher le plus petit Ã©lÃ©ment parmi le reste et l'Ã©changer avec l'Ã©lÃ©ment non triÃ© suivant (maintenant le deuxiÃ¨me Ã©lÃ©ment)Â :</p>
<pre><code>  1 3 8 5 2 7 4 6
    â€“     â€“
  1 2 8 5 3 7 4 6
</code></pre>
</li>
<li>
<p>Nous pouvons rÃ©pÃ©ter cette opÃ©ration encore et encore, jusqu'Ã  obtenir une liste triÃ©e.</p>
</li>
<li>
<p>Cet algorithme est appelÃ© <strong>tri par sÃ©lection</strong>, et voici le pseudo-code que nous pourrions Ã©crireÂ :</p>
<pre><code>  Pour i de 0 Ã  nâ€“1
      Trouver le plus petit Ã©lÃ©ment entre l'Ã©lÃ©ment iÃ¨me et le dernier Ã©lÃ©ment
      Ã‰changer le plus petit Ã©lÃ©ment avec l'Ã©lÃ©ment iÃ¨me
</code></pre>
</li>
<li>
<p>Avec la notation <em>O</em> grande, nous avons toujours un temps d'exÃ©cution de <em>O</em>(<em>n_2), car nous avons examinÃ© environ tous les _n</em> Ã©lÃ©ments pour trouver le plus petit, et effectuÃ© <em>n</em> passes pour trier tous les Ã©lÃ©ments.</p>
</li>
<li>
<p>Plus formellement, nous pouvons utiliser certaines formules pour montrer que le plus grand facteur est en effet _n_2Â :</p>
<pre><code>  n + (n â€“ 1) + (n â€“ 2) + ... + 1
  n(n + 1)/2
  (n^2 + n)/2
  n^2/2 + n/2
  O(n^2)
</code></pre>
</li>
<li>
<p>Il s'avÃ¨re donc que le tri par sÃ©lection fonctionne fondamentalement de la mÃªme maniÃ¨re que le tri Ã  bulles en termes de temps d'exÃ©cutionÂ :</p>
<ul>
<li><em>O</em>(_n_2)<ul>
<li>tri Ã  bulles, tri par sÃ©lection</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>recherche linÃ©aire</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>recherche binaire</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>Le meilleur cas, Î©, est Ã©galement _n_2.</li>
<li>
<p>Nous pouvons revenir au tri Ã  bulles et modifier son algorithme pour obtenir quelque chose comme ceci, ce qui nous permettra d'arrÃªter tÃ´t si tous les Ã©lÃ©ments sont triÃ©sÂ :</p>
<pre><code>  RÃ©pÃ©ter jusqu'Ã  ce qu'il n'y ait plus d'Ã©changes
      Pour i de 0 Ã  nâ€“2
          Si les iÃ¨me et i+1Ã¨me Ã©lÃ©ments ne sont pas dans l'ordre
              Les Ã©changer
</code></pre>
<ul>
<li>Maintenant, nous n'avons besoin d'examiner chaque Ã©lÃ©ment qu'une seule fois, donc le meilleur cas est maintenant Î©(<em>n</em>)Â :<ul>
<li>Î©(_n_2)<ul>
<li>tri par sÃ©lection</li>
</ul>
</li>
<li>Î©(<em>n</em> log <em>n</em>)</li>
<li>Î©(<em>n</em>)<ul>
<li>tri Ã  bulles</li>
</ul>
</li>
<li>Î©(log <em>n</em>)</li>
<li>Î©(1)<ul>
<li>recherche linÃ©aire, recherche binaire</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Nous examinons une visualisation en ligne <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">comparaison des algorithmes de tri</a> avec des animations montrant comment les Ã©lÃ©ments se dÃ©placent dans les tableaux pour le tri Ã  bulles et le tri par sÃ©lection.</p>
</li>
</ul>
<h2>RÃ©cursivitÃ©</h2>
<ul>
<li>
<p>Rappelons que pour la semaine 0, nous avions un pseudo-code pour trouver un nom dans un annuaire tÃ©lÃ©phonique, oÃ¹ des lignes nous disaient de "revenir en arriÃ¨re" et de rÃ©pÃ©ter certaines Ã©tapesÂ :</p>
<pre><code>  1 Prendre l'annuaire tÃ©lÃ©phonique
  2 Ouvrir l'annuaire tÃ©lÃ©phonique au milieu
  3 Regarder la page
  4 Si Smith est sur la page
  5 Appeler Mike
  6 Sinon si Smith est plus tÃ´t dans l'annuaire
  7 Ouvrir au milieu de la moitiÃ© gauche de l'annuaire
  8 **Revenir Ã  la ligne 3**
  9 Sinon si Smith est plus tard dans l'annuaire
  10 Ouvrir au milieu de la moitiÃ© droite de l'annuaire
  11 **Revenir Ã  la ligne 3**
  12 Sinon
  13 ArrÃªter
</code></pre>
</li>
<li>
<p>Nous pourrions simplement rÃ©pÃ©ter tout notre algorithme sur la moitiÃ© de l'annuaire qu'il nous resteÂ :</p>
<pre><code>  1 Prendre l'annuaire tÃ©lÃ©phonique
  2 Ouvrir l'annuaire tÃ©lÃ©phonique au milieu
  3 Regarder la page
  4 Si Smith est sur la page
  5 Appeler Mike
  6 Sinon si Smith est plus tÃ´t dans l'annuaire
  7 **Chercher dans la moitiÃ© gauche de l'annuaire**
  8
  9 Sinon si Smith est plus tard dans l'annuaire
  10 **Chercher dans la moitiÃ© droite de l'annuaire**
  11
  12 Sinon
  13 ArrÃªter
</code></pre>
<ul>
<li>Cela ressemble Ã  un processus cyclique qui ne finira jamais, mais nous divisons en rÃ©alitÃ© le problÃ¨me par deux Ã  chaque fois, et nous arrÃªtons lorsqu'il n'y a plus d'annuaire.</li>
</ul>
</li>
<li>
<p>La <strong>rÃ©cursivitÃ©</strong> se produit lorsqu'une fonction ou un algorithme fait rÃ©fÃ©rence Ã  lui-mÃªme, comme dans le nouveau pseudo-code ci-dessus.</p>
</li>
<li>
<p>De mÃªme, pour la semaine 1, nous avons implÃ©mentÃ© une "pyramide" de blocs sous la forme suivanteÂ :</p>
<pre><code>  #
  ##
  ###
  ####
</code></pre>
<ul>
<li>
<p>Et nous aurions pu avoir un code itÃ©ratif comme celui-ciÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  void draw(int h);

  int main(void)
  {
      // Obtenir la hauteur de la pyramide
      int height = get_int("Height: ");

      // Dessiner la pyramide
      draw(height);
  }

  void draw(int h)
  {
      // Dessiner une pyramide de hauteur h
      for (int i = 1; i &lt;= h; i++)
      {
          for (int j = 1; j &lt;= i; j++)
          {
              printf("#");
          }
          printf("\n");
      }
  }
</code></pre>
<ul>
<li>Ici, nous utilisons des boucles <code>for</code> pour imprimer chaque bloc de chaque rangÃ©e.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Mais notez qu'une pyramide de hauteur 4 est en rÃ©alitÃ© une pyramide de hauteur 3, avec une rangÃ©e supplÃ©mentaire de 4 blocs ajoutÃ©e. Et une pyramide de hauteur 3 est une pyramide de hauteur 2, avec une rangÃ©e supplÃ©mentaire de 3 blocs. Une pyramide de hauteur 2 est une pyramide de hauteur 1, avec une rangÃ©e supplÃ©mentaire de 2 blocs. Et enfin, une pyramide de hauteur 1 est juste une pyramide de hauteur 0, ou rien, avec une autre rangÃ©e d'un seul bloc ajoutÃ©e.</p>
</li>
<li>
<p>Avec cette idÃ©e en tÃªte, nous pouvons Ã©crireÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  void draw(int h);

  int main(void)
  {
      // Obtenir la hauteur de la pyramide
      int height = get_int("Height: ");

      // Dessiner la pyramide
      draw(height);
  }

  void draw(int h)
  {
      // Si rien Ã  dessiner
      if (h == 0)
      {
          return;
      }

      // Dessiner une pyramide de hauteur h - 1
      draw(h - 1);

      // Dessiner une rangÃ©e supplÃ©mentaire de largeur h
      for (int i = 0; i &lt; h; i++)
      {
          printf("#");
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Maintenant, notre fonction <code>draw</code> appelle d'abord elle-mÃªme <strong>rÃ©cursivement</strong>, dessinant une pyramide de hauteur <code>h - 1</code>. Mais avant mÃªme cela, nous devons nous arrÃªter si <code>h</code> est 0, car il n'y aura plus rien Ã  dessiner.</li>
<li>Ensuite, nous dessinons la rangÃ©e suivante, ou une rangÃ©e de largeur <code>h</code>.</li>
</ul>
</li>
</ul>
<h2>Tri fusion</h2>
<ul>
<li>
<p>On peut appliquer l'idÃ©e de rÃ©cursion au tri, avec un autre algorithme appelÃ© tri fusion. Voici Ã  quoi pourrait ressembler le pseudo-codeÂ :</p>
<pre><code>  Si un seul Ã©lÃ©ment
    Retourner
  Sinon
      Trier la moitiÃ© gauche des Ã©lÃ©ments
      Trier la moitiÃ© droite des Ã©lÃ©ments
      Fusionner les moitiÃ©s triÃ©es
</code></pre>
</li>
<li>
<p>On verra cela plus facilement en pratique avec une liste non triÃ©eÂ :</p>
<pre><code>  7 4 5 2 6 3 8 1
</code></pre>
</li>
<li>
<p>Tout d'abord, on trie la moitiÃ© gauche (les quatre premiers Ã©lÃ©ments)Â :</p>
<pre><code>  7 4 5 2 | 6 3 8 1
  â€“ â€“ â€“ â€“
</code></pre>
</li>
<li>
<p>Bon, pour trier cela, on doit d'abord trier la moitiÃ© gauche de la moitiÃ© gaucheÂ :</p>
<pre><code>  7 4 | 5 2 | 6 3 8 1
  â€“ â€“
</code></pre>
</li>
<li>
<p>Maintenant, on a juste un Ã©lÃ©ment, <code>7</code>, dans la moitiÃ© gauche, et un Ã©lÃ©ment, <code>4</code>, dans la moitiÃ© droite. Donc on fusionnera cela en prenant le plus petit Ã©lÃ©ment de chaque liste en premierÂ :</p>
<pre><code>  â€“ â€“ | 5 2 | 6 3 8 1
  4 7
</code></pre>
</li>
<li>
<p>Et maintenant on revient Ã  la moitiÃ© droite de la moitiÃ© gauche et on la trieÂ :</p>
<pre><code>  â€“ â€“ | â€“ â€“ | 6 3 8 1
  4 7 | 2 5
</code></pre>
</li>
<li>
<p>Maintenant, les deux moitiÃ©s de la moitiÃ© gauche sont triÃ©es, donc on peut fusionner les deux. On regarde le dÃ©but de chaque liste et on prend <code>2</code> puisqu'il est plus petit que <code>4</code>. Ensuite, on prend <code>4</code>, puisque c'est maintenant le plus petit Ã©lÃ©ment au dÃ©but des deux listes. Puis, on prend <code>5</code>, et enfin <code>7</code>, pour obtenirÂ :</p>
<pre><code>  â€“ â€“ â€“ â€“ | 6 3 8 1
  â€“ â€“ â€“ â€“
  2 4 5 7
</code></pre>
</li>
<li>
<p>Maintenant on trie la moitiÃ© droite de la mÃªme maniÃ¨re. D'abord, la moitiÃ© gauche de la moitiÃ© droiteÂ :</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ | 8 1
  â€“ â€“ â€“ â€“ | 3 6 |
  2 4 5 7
</code></pre>
</li>
<li>
<p>Ensuite, la moitiÃ© droite de la moitiÃ© droiteÂ :</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ | â€“ â€“
  â€“ â€“ â€“ â€“ | 3 6 | 1 8
  2 4 5 7
</code></pre>
</li>
<li>
<p>On peut maintenant fusionner la moitiÃ© droiteÂ :</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  2 4 5 7 | 1 3 6 8
</code></pre>
</li>
<li>
<p>Enfin, on peut fusionner les deux moitiÃ©s de la liste entiÃ¨re en suivant les mÃªmes Ã©tapes que prÃ©cÃ©demment. Remarquez que nous n'avons pas besoin de vÃ©rifier tous les Ã©lÃ©ments de chaque moitiÃ© pour trouver le plus petit, puisque nous savons que chaque moitiÃ© est dÃ©jÃ  triÃ©e. Au lieu de cela, il suffit de prendre le plus petit Ã©lÃ©ment sur deux au dÃ©but de chaque moitiÃ© :</p>
<pre><code>  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  2 4 5 7 | â€“ 3 6 8
  1

  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ 4 5 7 | â€“ 3 6 8
  1 2

  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ 4 5 7 | â€“ â€“ 6 8
  1 2 3

  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ 5 7 | â€“ â€“ 6 8
  1 2 3 4

  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ 7 | â€“ â€“ 6 8
  1 2 3 4   5

  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ 7 | â€“ â€“ â€“ 8
  1 2 3 4   5 6

  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ 8
  1 2 3 4   5 6 7

  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  â€“ â€“ â€“ â€“ | â€“ â€“ â€“ â€“
  1 2 3 4   5 6 7 8
</code></pre>
</li>
<li>
<p>Il y a pas mal d'Ã©tapes, mais en rÃ©alitÃ© il en faut moins que pour les autres algorithmes vus jusqu'Ã  prÃ©sent. On divise la liste en deux Ã  chaque fois, jusqu'Ã  "trier" huit listes avec un seul Ã©lÃ©ment chacune :</p>
<pre><code>  7 | 4 | 5 | 2 | 6 | 3 | 8 | 1
  4   7 | 2   5 | 3   6 | 1   8
  2   4   5   7 | 1   3   6   8
  1   2   3   4   5   6   7   8
</code></pre>
</li>
<li>
<p>Comme notre algorithme divise le problÃ¨me en deux Ã  chaque fois, sa durÃ©e d'exÃ©cution est logarithmique, avec O(log n). AprÃ¨s avoir triÃ© chaque moitiÃ© (ou la moitiÃ© d'une moitiÃ©), on assemble tous les Ã©lÃ©ments, en n Ã©tapes, puisque l'on doit regarder chaque Ã©lÃ©ment une fois.</p>
</li>
<li>La durÃ©e d'exÃ©cution totale est donc O(n log n) :<ul>
<li>O(nÂ²)<ul>
<li>tri Ã  bulles, tri par sÃ©lection</li>
</ul>
</li>
<li>O(n log n)<ul>
<li>tri fusion</li>
</ul>
</li>
<li>O(n)<ul>
<li>recherche linÃ©aire</li>
</ul>
</li>
<li>O(log n)<ul>
<li>recherche dichotomique</li>
</ul>
</li>
<li>O(1)</li>
</ul>
</li>
<li>Comme log n est supÃ©rieur Ã  1 mais infÃ©rieur Ã  n, n log n se situe entre n (fois 1) et nÂ².</li>
<li>Le meilleur cas, Î©, reste n log n, puisqu'on continue Ã  trier chaque moitiÃ© d'abord puis Ã  les fusionner :<ul>
<li>Î©(nÂ²)<ul>
<li>tri par sÃ©lection</li>
</ul>
</li>
<li>Î©(n log n)<ul>
<li>tri fusion</li>
</ul>
</li>
<li>Î©(n)<ul>
<li>tri Ã  bulles</li>
</ul>
</li>
<li>Î©(log n)</li>
<li>Î©(1)<ul>
<li>recherche linÃ©aire, recherche dichotomique</li>
</ul>
</li>
</ul>
</li>
<li>Enfin, il y a une autre notation, Î˜, Theta, que l'on utilise pour dÃ©crire les durÃ©es d'exÃ©cution des algorithmes si la borne supÃ©rieure et la borne infÃ©rieure sont identiques. Par exemple, le tri fusion est notÃ© Î˜(n log n) puisque le meilleur et le pire cas nÃ©cessitent le mÃªme nombre d'Ã©tapes. Et le tri par sÃ©lection est Î˜(nÂ²).</li>
<li>On regarde une <a href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc">visualisation finale</a> des algorithmes de tri avec un plus grand nombre d'entrÃ©es, exÃ©cutÃ©s en mÃªme temps.</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>