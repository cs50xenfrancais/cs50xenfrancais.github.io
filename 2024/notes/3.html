<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en Fran√ßais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en Fran√ßais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch üò∫
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        M√©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de Donn√©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        Cybers√©curit√©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">Honn√™tet√© Acad√©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions Fr√©quemment Pos√©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">√âquipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h2>Le√ßon 3</h2>
<ul>
<li><a href="#recherche">Recherche</a></li>
<li><a href="#big-o">Big O</a></li>
<li><a href="#recherche-lin√©aire">Recherche lin√©aire</a></li>
<li><a href="#structures">Structures</a></li>
<li><a href="#tri">Tri</a></li>
<li><a href="#tri-par-s√©lection">Tri par s√©lection</a></li>
<li><a href="#r√©cursivit√©">R√©cursivit√©</a></li>
<li><a href="#tri-fusion">Tri fusion</a></li>
</ul>
<h2>Recherche</h2>
<ul>
<li>La derni√®re fois, nous avons parl√© de la m√©moire d'un ordinateur, ou RAM, et comment nos donn√©es peuvent √™tre stock√©es sous forme de variables individuelles ou sous forme de tableaux de plusieurs √©l√©ments.</li>
<li>Nous pouvons consid√©rer un tableau contenant un certain nombre d'√©l√©ments comme une rang√©e de casiers, o√π un ordinateur ne peut ouvrir qu'un casier √† la fois pour examiner un √©l√©ment.</li>
<li>Par exemple, si nous voulons v√©rifier si un nombre se trouve dans un tableau, avec un algorithme qui prend en entr√©e un tableau et produit un bool√©en en r√©sultat, nous pourrions¬†:
    - regarder dans chaque casier, ou dans chaque √©l√©ment, un √† la fois, du d√©but √† la fin.
        - Cela s'appelle <strong>recherche lin√©aire</strong>, o√π nous nous d√©pla√ßons en ligne, car notre tableau n'est pas tri√©.
    - commencer au milieu et se d√©placer √† gauche ou √† droite en fonction de ce que nous recherchons, si notre tableau d'√©l√©ments est tri√©.
        - Cela s'appelle <strong>recherche binaire</strong>, car nous pouvons diviser notre probl√®me en deux √† chaque √©tape, comme ce que David a fait avec l'annuaire t√©l√©phonique √† la semaine¬†0.</li>
<li>
<p>Nous pourrions √©crire un pseudo-code pour la recherche lin√©aire avec¬†:</p>
<pre><code>  Pour i de 0 √† n-1
      Si le i-√®me √©l√©ment est 50
          Retourner vrai
  Retourner faux
</code></pre>
<ul>
<li>Nous pouvons √©tiqueter chacun des <code>n</code> casiers de <code>0</code> √† <code>n-1</code> et les cocher chacun dans l'ordre.</li>
</ul>
</li>
<li>
<p>Pour la recherche binaire, notre algorithme pourrait ressembler √†¬†:</p>
<pre><code>  Si aucun √©l√©ment
      Retourner faux
  Si l'√©l√©ment du milieu est 50
      Retourner vrai
  Sinon si 50 &lt; √©l√©ment du milieu
      Rechercher dans la moiti√© gauche
  Sinon si 50 &gt; √©l√©ment du milieu
      Rechercher dans la moiti√© droite
</code></pre>
<ul>
<li>√âventuellement, il ne nous restera aucune partie du tableau (si l'√©l√©ment que nous recherchons n'y √©tait pas), nous pouvons donc retourner <code>faux</code>.</li>
<li>Sinon, nous pouvons rechercher dans chaque moiti√© en fonction de la valeur de l'√©l√©ment du milieu.</li>
</ul>
</li>
</ul>
<h2>Notation O (grand O)</h2>
<ul>
<li>Pendant la semaine 0, nous avons vu diff√©rents types d'algorithmes et leurs temps d'ex√©cution : <img alt="graphics with: &quot;size of a problem&quot; as x‚Äìaxis; &quot;time to solve&quot; as y‚Äìaxis; red, steep straight line from origin to top of graph labeled &quot;n&quot;; yellow, less steep straight line from origin to top of graph labeled &quot;n/2&quot;; green, curved line that gets less and less steep from origin to right of graph labeled &quot;log_2 n&quot;" src="https://cs50.harvard.edu/x/2020/notes/3/running_time.png" /></li>
<li>Une mani√®re plus formelle de d√©crire cela est d'utiliser la notation O, que nous pouvons comprendre comme ¬´ de l'ordre de ¬ª. Par exemple, si notre algorithme est une recherche lin√©aire, il prendra environ O(n) mesures, ¬´ de l'ordre de n ¬ª. En fait, m√™me un algorithme qui examine deux √©l√©ments √† la fois et prend n/2 mesures a O(n). En effet, √† mesure que n devient de plus en plus grand, seul le terme le plus grand, n, a de l'importance.</li>
<li>De m√™me, un temps d'ex√©cution logarithmique est O(log n), quelle que soit la base, car il ne s'agit que d'une approximation de ce qui se passe lorsque n est tr√®s grand.</li>
<li>Voici quelques temps d'ex√©cution courants :<ul>
<li>O(n¬≤)</li>
<li>O(n log n)</li>
<li>O(n)<ul>
<li>(recherche lin√©aire)</li>
</ul>
</li>
<li>O(log n)<ul>
<li>(recherche binaire)</li>
</ul>
</li>
<li>O(1)</li>
</ul>
</li>
<li>Les informaticiens peuvent √©galement utiliser la notation Om√©ga majuscule, qui repr√©sente la borne inf√©rieure du nombre d'√©tapes de notre algorithme. (O majuscule est la borne sup√©rieure du nombre d'√©tapes, ou le pire des cas, et g√©n√©ralement ce qui nous importe le plus.) Avec la recherche lin√©aire, par exemple, le pire des cas est de n √©tapes, mais le meilleur cas est de 1 √©tape puisque notre √©l√©ment pourrait √™tre le premier √©l√©ment que nous v√©rifions. Le meilleur cas pour la recherche binaire est √©galement de 1, car notre √©l√©ment peut se trouver au milieu du tableau.</li>
<li>Et nous avons un ensemble similaire des temps d'ex√©cution Om√©ga majuscule les plus courants :<ul>
<li>Œ©(n¬≤)</li>
<li>Œ©(n log n)</li>
<li>Œ©(n)<ul>
<li>(comptage du nombre d'√©l√©ments)</li>
</ul>
</li>
<li>Œ©(log n)</li>
<li>Œ©(1)<ul>
<li>(recherche lin√©aire, recherche binaire)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Recherche lin√©aire</h2>
<ul>
<li>
<p>Jetons un coup d'≈ìil √† <code>numbers.c</code>¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Un tableau de nombres
      int numbers[] = {4, 8, 15, 16, 23, 42};

      // Rechercher 50
      for (int i = 0; i &lt; 6; i++)
      {
          if (numbers[i] == 50)
          {
              printf("Trouv√©\n");
              return 0;
          }
      }
      printf("Non trouv√©\n");
      return 1;
  }
</code></pre>
</li>
<li>
<p>Ici, nous initialisons un tableau avec quelques valeurs, et nous v√©rifions les √©l√©ments du tableau un par un, dans l'ordre.</p>
</li>
<li>
<p>Et dans chaque cas, selon que la valeur a √©t√© trouv√©e ou non, nous pouvons renvoyer un code de sortie de 0 (pour le succ√®s) ou de 1 (pour l'√©chec).</p>
</li>
<li>
<p>Nous pouvons faire la m√™me chose pour les noms¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      // Un tableau de noms
      string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};

      // Rechercher EMMA
      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(names[i], "EMMA") == 0)
          {
              printf("Trouv√©\n");
              return 0;
          }
      }
      printf("Non trouv√©\n");
      return 1;
  }
</code></pre>
</li>
<li>
<p>Nous ne pouvons pas comparer directement des cha√Ænes de caract√®res, car ce ne sont pas des types de donn√©es simples mais plut√¥t un tableau de plusieurs caract√®res, et nous devons les comparer diff√©remment. Heureusement, la biblioth√®que <code>string</code> a une fonction <code>strcmp</code> qui compare les cha√Ænes de caract√®res pour nous et renvoie <code>0</code> si elles sont identiques. Nous pouvons donc l'utiliser.</p>
</li>
<li>
<p>Essayons d'impl√©menter un annuaire t√©l√©phonique avec les m√™mes id√©es¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
      string numbers[] = {"617‚Äì555‚Äì0100", "617‚Äì555‚Äì0101", "617‚Äì555‚Äì0102", "617‚Äì555‚Äì0103"};

      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(names[i], "EMMA") == 0)
          {
              printf("Trouv√© %s\n", numbers[i]);
              return 0;
          }
      }
      printf("Non trouv√©\n");
      return 1;
  }
</code></pre>
</li>
<li>
<p>Nous utiliserons des cha√Ænes de caract√®res pour les num√©ros de t√©l√©phone, car ils peuvent inclure un formatage ou √™tre trop longs pour un nombre.</p>
</li>
<li>Maintenant, si le nom √† un certain index dans le tableau <code>names</code> correspond √† celui que nous recherchons, nous renverrons le num√©ro de t√©l√©phone dans le tableau <code>numbers</code>, au m√™me index. Mais cela signifie que nous devons √™tre particuli√®rement attentifs pour nous assurer que chaque num√©ro correspond au nom √† chaque index, surtout si nous ajoutons ou supprimons des noms et des num√©ros.</li>
</ul>
<h2>Structures</h2>
<ul>
<li>
<p>Il s'av√®re que nous pouvons cr√©er nos propres types de donn√©es personnalis√©s appel√©s <strong>structures¬†</strong>:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  typedef struct
  {
      string name;
      string number;
  }
  person;

  int main(void)
  {
      person people[4];

      people[0].name = "EMMA";
      people[0].number = "617‚Äì555‚Äì0100";

      people[1].name = "RODRIGO";
      people[1].number = "617‚Äì555‚Äì0101";

      people[2].name = "BRIAN";
      people[2].number = "617‚Äì555‚Äì0102";

      people[3].name = "DAVID";
      people[3].number = "617‚Äì555‚Äì0103";

      // Recherche EMMA
      for (int i = 0; i &lt; 4; i++)
      {
          if (strcmp(people[i].name, "EMMA") == 0)
          {
              printf("Found %s\n", people[i].number);
              return 0;
          }
      }
      printf("Not found\n");
      return 1;
  }
</code></pre>
</li>
<li>
<p>Nous pouvons consid√©rer les structures comme des conteneurs, √† l'int√©rieur desquels se trouvent plusieurs autres types de donn√©es.</p>
</li>
<li>Ici, nous cr√©ons notre propre type avec une structure appel√©e <code>personne</code>, qui aura une <code>cha√Æne</code> appel√©e <code>nom</code> et une <code>cha√Æne</code> appel√©e <code>num√©ro</code>. Ensuite, nous pouvons cr√©er un tableau de ces types de structure et initialiser les valeurs √† l'int√©rieur de chacun d'eux, en utilisant une nouvelle syntaxe, <code>.</code>, pour acc√©der aux propri√©t√©s de chaque <code>personne</code>.</li>
<li>Dans notre boucle, nous pouvons maintenant √™tre plus certains que le <code>num√©ro</code> correspond au <code>nom</code> puisqu'ils proviennent du m√™me √©l√©ment <code>personne</code>.</li>
</ul>
<h2>Tri</h2>
<ul>
<li>Si notre entr√©e est une liste non tri√©e de nombres, il existe de nombreux algorithmes que nous pourrions utiliser pour produire une liste tri√©e en sortie.</li>
<li>Avec huit volontaires sur sc√®ne ayant les num√©ros suivants, nous pourrions envisager d'√©changer les paires de nombres voisins comme premi√®re √©tape.</li>
<li>
<p>Nos volontaires commencent dans l'ordre al√©atoire suivant¬†:</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>Nous examinons les deux premiers nombres et les √©changeons pour qu'ils soient dans l'ordre¬†:</p>
<pre><code>  6 3 8 5 2 7 4 1
  ‚Äì ‚Äì
  3 6 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>La paire suivante, <code>6</code> et <code>8</code>, est dans l'ordre, nous n'avons donc pas besoin de les √©changer.</p>
</li>
<li>
<p>La paire suivante, <code>8</code> et <code>5</code>, doit √™tre √©chang√©e¬†:</p>
<pre><code>  3 6 8 5 2 7 4 1
      ‚Äì ‚Äì
  3 6 5 8 2 7 4 1
</code></pre>
</li>
<li>
<p>Nous continuons jusqu'√† ce que nous atteignions la fin de la liste¬†:</p>
<pre><code>  3 6 5 2 8 7 4 1
          ‚Äì ‚Äì
  3 6 5 2 7 8 4 1
            ‚Äì ‚Äì
  3 6 5 2 7 4 8 1
              ‚Äì ‚Äì
  3 6 5 2 7 4 1 8
</code></pre>
</li>
<li>
<p>Notre liste n'est pas encore tri√©e, mais nous sommes un peu plus pr√®s de la solution parce que la plus grande valeur, <code>8</code>, a √©t√© d√©plac√©e compl√®tement vers la droite.</p>
</li>
<li>
<p>Nous r√©p√©tons ceci avec un autre passage sur la liste¬†:</p>
<pre><code>  3 6 5 2 7 4 1 8
  ‚Äì ‚Äì
  3 6 5 2 7 4 1 8
    ‚Äì ‚Äì
  3 5 6 2 7 4 1 8
      ‚Äì ‚Äì
  3 5 2 6 7 4 1 8
        ‚Äì ‚Äì
  3 5 2 6 7 4 1 8
          ‚Äì ‚Äì
  3 5 2 6 4 7 1 8
              ‚Äì ‚Äì
  3 5 2 6 4 1 7 8
</code></pre>
<ul>
<li>Notez que nous n'avions pas besoin d'√©changer le 3 et le 6, ou le 6 et le 7.</li>
</ul>
</li>
<li>
<p>Maintenant, la deuxi√®me plus grande valeur, <code>7</code>, est d√©plac√©e compl√®tement vers la droite. Si nous r√©p√©tons cela, de plus en plus de la liste sera tri√©e et assez rapidement, nous aurons une liste enti√®rement tri√©e.</p>
</li>
<li>
<p>Cet algorithme est appel√© <strong>tri √† bulles</strong>, o√π les grandes valeurs ¬´¬†bullent¬†¬ª vers la droite. Le pseudo-code pour cela pourrait ressembler √†¬†:</p>
<pre><code>  R√©p√©ter n‚Äì1 fois
      Pour i de 0 √† n‚Äì2
          Si le i√®me et le i+1√®me √©l√©ments sont d√©sordonn√©s
              Les √©changer
</code></pre>
<ul>
<li>Puisque nous comparons le i√®me et le i+1√®me √©l√©ment, nous n'avons besoin d'aller que jusqu'√† <em>n</em> ‚Äì 2 pour <code>i</code>. Ensuite, nous √©changeons les deux √©l√©ments s'ils sont d√©sordonn√©s.</li>
<li>Et nous pouvons arr√™ter apr√®s avoir fait <em>n</em> ‚Äì 1 passages, puisque nous savons que les n‚Äì1 plus grands √©l√©ments auront bull√© vers la droite.</li>
</ul>
</li>
<li>
<p>Nous avons <em>n</em> ‚Äì 2 √©tapes pour la boucle interne et <em>n</em> ‚Äì 1 boucles, nous obtenons donc <em>n_2 ‚Äì 3_n</em> + 2 √©tapes au total. Mais le plus grand facteur, ou terme dominant, est <em>n_2, car <code>n</code> devient de plus en plus grand, donc nous pouvons dire que le tri √† bulles est _O</em>(_n_2).</p>
</li>
<li>Nous avons vu des temps d'ex√©cution comme ce qui suit, et donc m√™me si la recherche binaire est beaucoup plus rapide que la recherche lin√©aire, cela pourrait ne pas valoir la peine de trier d'abord la liste, √† moins que nous ne fassions beaucoup de recherches au fil du temps¬†:<ul>
<li><em>O</em>(_n_2)<ul>
<li>Tri √† bulles</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>Recherche lin√©aire</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>Recherche binaire</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>Et Œ© pour le tri √† bulles est toujours <em>n_2, puisque nous v√©rifions toujours chaque paire d'√©l√©ments pour _n</em> ‚Äì 1 passages.</li>
</ul>
<h2>Tri par s√©lection</h2>
<ul>
<li>
<p>Adoptons une autre approche avec le m√™me ensemble de nombres¬†:</p>
<pre><code>  6 3 8 5 2 7 4 1
</code></pre>
</li>
<li>
<p>D'abord, examinons chaque nombre et m√©morisons le plus petit rencontr√©. Ensuite, nous pouvons l'√©changer avec le premier nombre de notre liste, puisque nous savons que c'est le plus petit¬†:</p>
<pre><code>  6 3 8 5 2 7 4 1
  ‚Äì             ‚Äì
  1 3 8 5 2 7 4 6
</code></pre>
</li>
<li>
<p>Nous savons d√©sormais qu'au moins le premier √©l√©ment de notre liste est √† la bonne place. Nous pouvons donc rechercher le plus petit √©l√©ment parmi le reste et l'√©changer avec l'√©l√©ment non tri√© suivant (maintenant le deuxi√®me √©l√©ment)¬†:</p>
<pre><code>  1 3 8 5 2 7 4 6
    ‚Äì     ‚Äì
  1 2 8 5 3 7 4 6
</code></pre>
</li>
<li>
<p>Nous pouvons r√©p√©ter cette op√©ration encore et encore, jusqu'√† obtenir une liste tri√©e.</p>
</li>
<li>
<p>Cet algorithme est appel√© <strong>tri par s√©lection</strong>, et voici le pseudo-code que nous pourrions √©crire¬†:</p>
<pre><code>  Pour i de 0 √† n‚Äì1
      Trouver le plus petit √©l√©ment entre l'√©l√©ment i√®me et le dernier √©l√©ment
      √âchanger le plus petit √©l√©ment avec l'√©l√©ment i√®me
</code></pre>
</li>
<li>
<p>Avec la notation <em>O</em> grande, nous avons toujours un temps d'ex√©cution de <em>O</em>(<em>n_2), car nous avons examin√© environ tous les _n</em> √©l√©ments pour trouver le plus petit, et effectu√© <em>n</em> passes pour trier tous les √©l√©ments.</p>
</li>
<li>
<p>Plus formellement, nous pouvons utiliser certaines formules pour montrer que le plus grand facteur est en effet _n_2¬†:</p>
<pre><code>  n + (n ‚Äì 1) + (n ‚Äì 2) + ... + 1
  n(n + 1)/2
  (n^2 + n)/2
  n^2/2 + n/2
  O(n^2)
</code></pre>
</li>
<li>
<p>Il s'av√®re donc que le tri par s√©lection fonctionne fondamentalement de la m√™me mani√®re que le tri √† bulles en termes de temps d'ex√©cution¬†:</p>
<ul>
<li><em>O</em>(_n_2)<ul>
<li>tri √† bulles, tri par s√©lection</li>
</ul>
</li>
<li><em>O</em>(<em>n</em> log <em>n</em>)</li>
<li><em>O</em>(<em>n</em>)<ul>
<li>recherche lin√©aire</li>
</ul>
</li>
<li><em>O</em>(log <em>n</em>)<ul>
<li>recherche binaire</li>
</ul>
</li>
<li><em>O</em>(1)</li>
</ul>
</li>
<li>Le meilleur cas, Œ©, est √©galement _n_2.</li>
<li>
<p>Nous pouvons revenir au tri √† bulles et modifier son algorithme pour obtenir quelque chose comme ceci, ce qui nous permettra d'arr√™ter t√¥t si tous les √©l√©ments sont tri√©s¬†:</p>
<pre><code>  R√©p√©ter jusqu'√† ce qu'il n'y ait plus d'√©changes
      Pour i de 0 √† n‚Äì2
          Si les i√®me et i+1√®me √©l√©ments ne sont pas dans l'ordre
              Les √©changer
</code></pre>
<ul>
<li>Maintenant, nous n'avons besoin d'examiner chaque √©l√©ment qu'une seule fois, donc le meilleur cas est maintenant Œ©(<em>n</em>)¬†:<ul>
<li>Œ©(_n_2)<ul>
<li>tri par s√©lection</li>
</ul>
</li>
<li>Œ©(<em>n</em> log <em>n</em>)</li>
<li>Œ©(<em>n</em>)<ul>
<li>tri √† bulles</li>
</ul>
</li>
<li>Œ©(log <em>n</em>)</li>
<li>Œ©(1)<ul>
<li>recherche lin√©aire, recherche binaire</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Nous examinons une visualisation en ligne <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">comparaison des algorithmes de tri</a> avec des animations montrant comment les √©l√©ments se d√©placent dans les tableaux pour le tri √† bulles et le tri par s√©lection.</p>
</li>
</ul>
<h2>R√©cursivit√©</h2>
<ul>
<li>
<p>Rappelons que pour la semaine 0, nous avions un pseudo-code pour trouver un nom dans un annuaire t√©l√©phonique, o√π des lignes nous disaient de "revenir en arri√®re" et de r√©p√©ter certaines √©tapes¬†:</p>
<pre><code>  1 Prendre l'annuaire t√©l√©phonique
  2 Ouvrir l'annuaire t√©l√©phonique au milieu
  3 Regarder la page
  4 Si Smith est sur la page
  5 Appeler Mike
  6 Sinon si Smith est plus t√¥t dans l'annuaire
  7 Ouvrir au milieu de la moiti√© gauche de l'annuaire
  8 **Revenir √† la ligne 3**
  9 Sinon si Smith est plus tard dans l'annuaire
  10 Ouvrir au milieu de la moiti√© droite de l'annuaire
  11 **Revenir √† la ligne 3**
  12 Sinon
  13 Arr√™ter
</code></pre>
</li>
<li>
<p>Nous pourrions simplement r√©p√©ter tout notre algorithme sur la moiti√© de l'annuaire qu'il nous reste¬†:</p>
<pre><code>  1 Prendre l'annuaire t√©l√©phonique
  2 Ouvrir l'annuaire t√©l√©phonique au milieu
  3 Regarder la page
  4 Si Smith est sur la page
  5 Appeler Mike
  6 Sinon si Smith est plus t√¥t dans l'annuaire
  7 **Chercher dans la moiti√© gauche de l'annuaire**
  8
  9 Sinon si Smith est plus tard dans l'annuaire
  10 **Chercher dans la moiti√© droite de l'annuaire**
  11
  12 Sinon
  13 Arr√™ter
</code></pre>
<ul>
<li>Cela ressemble √† un processus cyclique qui ne finira jamais, mais nous divisons en r√©alit√© le probl√®me par deux √† chaque fois, et nous arr√™tons lorsqu'il n'y a plus d'annuaire.</li>
</ul>
</li>
<li>
<p>La <strong>r√©cursivit√©</strong> se produit lorsqu'une fonction ou un algorithme fait r√©f√©rence √† lui-m√™me, comme dans le nouveau pseudo-code ci-dessus.</p>
</li>
<li>
<p>De m√™me, pour la semaine 1, nous avons impl√©ment√© une "pyramide" de blocs sous la forme suivante¬†:</p>
<pre><code>  #
  ##
  ###
  ####
</code></pre>
<ul>
<li>
<p>Et nous aurions pu avoir un code it√©ratif comme celui-ci¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  void draw(int h);

  int main(void)
  {
      // Obtenir la hauteur de la pyramide
      int height = get_int("Height: ");

      // Dessiner la pyramide
      draw(height);
  }

  void draw(int h)
  {
      // Dessiner une pyramide de hauteur h
      for (int i = 1; i &lt;= h; i++)
      {
          for (int j = 1; j &lt;= i; j++)
          {
              printf("#");
          }
          printf("\n");
      }
  }
</code></pre>
<ul>
<li>Ici, nous utilisons des boucles <code>for</code> pour imprimer chaque bloc de chaque rang√©e.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Mais notez qu'une pyramide de hauteur 4 est en r√©alit√© une pyramide de hauteur 3, avec une rang√©e suppl√©mentaire de 4 blocs ajout√©e. Et une pyramide de hauteur 3 est une pyramide de hauteur 2, avec une rang√©e suppl√©mentaire de 3 blocs. Une pyramide de hauteur 2 est une pyramide de hauteur 1, avec une rang√©e suppl√©mentaire de 2 blocs. Et enfin, une pyramide de hauteur 1 est juste une pyramide de hauteur 0, ou rien, avec une autre rang√©e d'un seul bloc ajout√©e.</p>
</li>
<li>
<p>Avec cette id√©e en t√™te, nous pouvons √©crire¬†:</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  void draw(int h);

  int main(void)
  {
      // Obtenir la hauteur de la pyramide
      int height = get_int("Height: ");

      // Dessiner la pyramide
      draw(height);
  }

  void draw(int h)
  {
      // Si rien √† dessiner
      if (h == 0)
      {
          return;
      }

      // Dessiner une pyramide de hauteur h - 1
      draw(h - 1);

      // Dessiner une rang√©e suppl√©mentaire de largeur h
      for (int i = 0; i &lt; h; i++)
      {
          printf("#");
      }
      printf("\n");
  }
</code></pre>
<ul>
<li>Maintenant, notre fonction <code>draw</code> appelle d'abord elle-m√™me <strong>r√©cursivement</strong>, dessinant une pyramide de hauteur <code>h - 1</code>. Mais avant m√™me cela, nous devons nous arr√™ter si <code>h</code> est 0, car il n'y aura plus rien √† dessiner.</li>
<li>Ensuite, nous dessinons la rang√©e suivante, ou une rang√©e de largeur <code>h</code>.</li>
</ul>
</li>
</ul>
<h2>Tri fusion</h2>
<ul>
<li>
<p>On peut appliquer l'id√©e de r√©cursion au tri, avec un autre algorithme appel√© tri fusion. Voici √† quoi pourrait ressembler le pseudo-code¬†:</p>
<pre><code>  Si un seul √©l√©ment
    Retourner
  Sinon
      Trier la moiti√© gauche des √©l√©ments
      Trier la moiti√© droite des √©l√©ments
      Fusionner les moiti√©s tri√©es
</code></pre>
</li>
<li>
<p>On verra cela plus facilement en pratique avec une liste non tri√©e¬†:</p>
<pre><code>  7 4 5 2 6 3 8 1
</code></pre>
</li>
<li>
<p>Tout d'abord, on trie la moiti√© gauche (les quatre premiers √©l√©ments)¬†:</p>
<pre><code>  7 4 5 2 | 6 3 8 1
  ‚Äì ‚Äì ‚Äì ‚Äì
</code></pre>
</li>
<li>
<p>Bon, pour trier cela, on doit d'abord trier la moiti√© gauche de la moiti√© gauche¬†:</p>
<pre><code>  7 4 | 5 2 | 6 3 8 1
  ‚Äì ‚Äì
</code></pre>
</li>
<li>
<p>Maintenant, on a juste un √©l√©ment, <code>7</code>, dans la moiti√© gauche, et un √©l√©ment, <code>4</code>, dans la moiti√© droite. Donc on fusionnera cela en prenant le plus petit √©l√©ment de chaque liste en premier¬†:</p>
<pre><code>  ‚Äì ‚Äì | 5 2 | 6 3 8 1
  4 7
</code></pre>
</li>
<li>
<p>Et maintenant on revient √† la moiti√© droite de la moiti√© gauche et on la trie¬†:</p>
<pre><code>  ‚Äì ‚Äì | ‚Äì ‚Äì | 6 3 8 1
  4 7 | 2 5
</code></pre>
</li>
<li>
<p>Maintenant, les deux moiti√©s de la moiti√© gauche sont tri√©es, donc on peut fusionner les deux. On regarde le d√©but de chaque liste et on prend <code>2</code> puisqu'il est plus petit que <code>4</code>. Ensuite, on prend <code>4</code>, puisque c'est maintenant le plus petit √©l√©ment au d√©but des deux listes. Puis, on prend <code>5</code>, et enfin <code>7</code>, pour obtenir¬†:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | 6 3 8 1
  ‚Äì ‚Äì ‚Äì ‚Äì
  2 4 5 7
</code></pre>
</li>
<li>
<p>Maintenant on trie la moiti√© droite de la m√™me mani√®re. D'abord, la moiti√© gauche de la moiti√© droite¬†:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì | 8 1
  ‚Äì ‚Äì ‚Äì ‚Äì | 3 6 |
  2 4 5 7
</code></pre>
</li>
<li>
<p>Ensuite, la moiti√© droite de la moiti√© droite¬†:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì | ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | 3 6 | 1 8
  2 4 5 7
</code></pre>
</li>
<li>
<p>On peut maintenant fusionner la moiti√© droite¬†:</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  2 4 5 7 | 1 3 6 8
</code></pre>
</li>
<li>
<p>Enfin, on peut fusionner les deux moiti√©s de la liste enti√®re en suivant les m√™mes √©tapes que pr√©c√©demment. Remarquez que nous n'avons pas besoin de v√©rifier tous les √©l√©ments de chaque moiti√© pour trouver le plus petit, puisque nous savons que chaque moiti√© est d√©j√† tri√©e. Au lieu de cela, il suffit de prendre le plus petit √©l√©ment sur deux au d√©but de chaque moiti√© :</p>
<pre><code>  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  2 4 5 7 | ‚Äì 3 6 8
  1

  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì 4 5 7 | ‚Äì 3 6 8
  1 2

  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì 4 5 7 | ‚Äì ‚Äì 6 8
  1 2 3

  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì 5 7 | ‚Äì ‚Äì 6 8
  1 2 3 4

  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì 7 | ‚Äì ‚Äì 6 8
  1 2 3 4   5

  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì 7 | ‚Äì ‚Äì ‚Äì 8
  1 2 3 4   5 6

  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì 8
  1 2 3 4   5 6 7

  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  ‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
  1 2 3 4   5 6 7 8
</code></pre>
</li>
<li>
<p>Il y a pas mal d'√©tapes, mais en r√©alit√© il en faut moins que pour les autres algorithmes vus jusqu'√† pr√©sent. On divise la liste en deux √† chaque fois, jusqu'√† "trier" huit listes avec un seul √©l√©ment chacune :</p>
<pre><code>  7 | 4 | 5 | 2 | 6 | 3 | 8 | 1
  4   7 | 2   5 | 3   6 | 1   8
  2   4   5   7 | 1   3   6   8
  1   2   3   4   5   6   7   8
</code></pre>
</li>
<li>
<p>Comme notre algorithme divise le probl√®me en deux √† chaque fois, sa dur√©e d'ex√©cution est logarithmique, avec O(log n). Apr√®s avoir tri√© chaque moiti√© (ou la moiti√© d'une moiti√©), on assemble tous les √©l√©ments, en n √©tapes, puisque l'on doit regarder chaque √©l√©ment une fois.</p>
</li>
<li>La dur√©e d'ex√©cution totale est donc O(n log n) :<ul>
<li>O(n¬≤)<ul>
<li>tri √† bulles, tri par s√©lection</li>
</ul>
</li>
<li>O(n log n)<ul>
<li>tri fusion</li>
</ul>
</li>
<li>O(n)<ul>
<li>recherche lin√©aire</li>
</ul>
</li>
<li>O(log n)<ul>
<li>recherche dichotomique</li>
</ul>
</li>
<li>O(1)</li>
</ul>
</li>
<li>Comme log n est sup√©rieur √† 1 mais inf√©rieur √† n, n log n se situe entre n (fois 1) et n¬≤.</li>
<li>Le meilleur cas, Œ©, reste n log n, puisqu'on continue √† trier chaque moiti√© d'abord puis √† les fusionner :<ul>
<li>Œ©(n¬≤)<ul>
<li>tri par s√©lection</li>
</ul>
</li>
<li>Œ©(n log n)<ul>
<li>tri fusion</li>
</ul>
</li>
<li>Œ©(n)<ul>
<li>tri √† bulles</li>
</ul>
</li>
<li>Œ©(log n)</li>
<li>Œ©(1)<ul>
<li>recherche lin√©aire, recherche dichotomique</li>
</ul>
</li>
</ul>
</li>
<li>Enfin, il y a une autre notation, Œò, Theta, que l'on utilise pour d√©crire les dur√©es d'ex√©cution des algorithmes si la borne sup√©rieure et la borne inf√©rieure sont identiques. Par exemple, le tri fusion est not√© Œò(n log n) puisque le meilleur et le pire cas n√©cessitent le m√™me nombre d'√©tapes. Et le tri par s√©lection est Œò(n¬≤).</li>
<li>On regarde une <a href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc">visualisation finale</a> des algorithmes de tri avec un plus grand nombre d'entr√©es, ex√©cut√©s en m√™me temps.</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>