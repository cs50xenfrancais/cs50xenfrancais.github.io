<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS50x en FranÃ§ais</title>

    <!-- http://getbootstrap.com/docs/4.5/getting-started/introduction/ -->
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/popper.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>

    <!-- https://momentjs.com/, https://momentjs.com/timezone/ -->
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/moment-timezone-with-data.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>

    <!-- https://www.algolia.com/doc/guides/building-search-ui/installation/js/ -->
    <script src="/static/js/algoliasearchLite.min.js"></script>
    <script src="/static/js/instantsearch.production.min.js"></script>
    <script src="/static/js/jekyll-theme-cs50.js"></script>

    <script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/static/highlight/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/static/highlight/styles/vs.min.css"/>
    <link rel="stylesheet" href="/static/css/page.css">

    <style>
      code {
        color: black;
        border: 1px solid #dee2e6;
      }

      pre > code {
        padding: 0 !important;
      }

      pre {
        border: 1px solid #dee2e6;
      }

      .mermaid {
        background-color: white !important;
        border: none !important;
      }
    </style>
  </head>

  <body>
    <!-- Markdown Flux Diagrams -->
    <script type="module">
      mermaid.initialize({startOnLoad: true});
    </script>
    <div class="container-fluid">
      <div class="row">
        <aside class="col-md" style="background-color: darkblue">
  <header>
    <h1>
      <a href="">CS50x en FranÃ§ais</a>
    </h1>

    <p>
      <a target="_blank" href=""></a>
      <br/>
      2024
    </p>
  </header>

  <button class="btn btn-sm collapsed d-md-none" aria-controls="nav" aria-expanded="false" data-target="aside &gt; nav" data-toggle="collapse">
    Menu
  </button>

  <nav class="collapse d-md-block" id="nav">
    <hr/>

    <ul>
      <li>
        <a href="/2024/semaines/0.html">Semaine
          0</a>
        Scratch ğŸ˜º
      </li>
      <li>
        <a href="/2024/semaines/1.html">Semaine
          1</a>
        C
      </li>
      <li>
        <a href="/2024/semaines/2.html">Semaine
          2</a>
        Tableaux
      </li>
      <li>
        <a href="/2024/semaines/3.html">Semaine
          3</a>
        Algorithmes
      </li>
      <li>
        <a href="/2024/semaines/4.html">Semaine
          4</a>
        MÃ©moire
      </li>
      <li>
        <a href="/2024/semaines/5.html">Semaine
          5</a>
        Structures de DonnÃ©es
      </li>
      <li>
        <a href="/2024/semaines/6.html">Semaine
          6</a>
        Python
      </li>
      <li>
        <a href="/2024/semaines/7.html">Semaine
          7</a>
        SQL
      </li>
      <li>
        <a href="/2024/semaines/8.html">Semaine
          8</a>
        HTML, CSS, JavaScript
      </li>
      <li>
        <a href="/2024/semaines/9.html">Semaine
          9</a>
        Flask
      </li>
      <li>
        <a href="/2024/semaines/10.html">Semaine
          10</a>
        CybersÃ©curitÃ©
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/projet.html">Projet Final</a>
      </li>
    </ul>

    <hr/>

    <ul>
      <li>
        <a href="/2024/honn%C3%AAtet%C3%A9.html">HonnÃªtetÃ© AcadÃ©mique</a>
      </li>
      <li>
        <a href="/2024/certificat.html">Certificat CS50</a>
      </li>
      <li>
        <a href="/2024/questions-frequemment-posees.html">Questions FrÃ©quemment PosÃ©es</a>
      </li>
      <li>
        <a href="https://cs50.me/cs50x">Carnet de Notes</a>
      </li>
      <li>
        <a href="/2024/equipe.html">Ã‰quipe</a>
      </li>
      <li>
        <a href="/2024/plan-de-cours.html">Plan de Cours</a>
      </li>
    </ul>
    <hr/>

    <ul>
      <li>
        <a href="/manual/index.html">Pages du Manuel</a>
      </li>
      <li>
        <a href="/2024/style.html">Guide de Style</a>
      </li>
    </ul>
  </nav>
</aside>
        <main class="col-md markdown-body">
          

  <h1>LeÃ§on 4</h1>
<ul>
<li><a href="#hexadecimal">Hexadecimal</a></li>
<li><a href="#pointeurs">Pointers</a></li>
<li><a href="#chaÃ®nes-de-caractÃ¨res">ChaÃ®nes de caractÃ¨res</a></li>
<li><a href="#comparaisons-et-copies">Comparaisons et copies</a></li>
<li><a href="#valgrind">Valgrind</a></li>
<li><a href="#Ã©changes">Ã‰changes</a></li>
<li><a href="#disposition-en-mÃ©moire">Disposition en mÃ©moire</a></li>
<li><a href="#get_int">get_int</a></li>
<li><a href="#fichiers">Fichiers</a></li>
<li><a href="#jpeg">JPEG</a></li>
</ul>
<h2>Hexadecimal</h2>
<ul>
<li>Durant la semaine 0, nous avons appris le systÃ¨me binaire, un systÃ¨me de comptage avec des 0 et des 1.</li>
<li>Durant la semaine 2, nous avons parlÃ© de la mÃ©moire et de la faÃ§on dont chaque octet possÃ¨de une adresse, ou identifiant, pour que nous puissions rÃ©fÃ©rencer lâ€™endroit oÃ¹ nos variables sont rÃ©ellement stockÃ©es.</li>
<li>Il sâ€™avÃ¨re que, par convention, les adresses pour la mÃ©moire utilisent le systÃ¨me de comptage <strong>hexadÃ©cimal</strong>, dans lequel il y a 16 chiffres : 0-9 et A-F.</li>
<li>
<p>Rappelons que, en binaire, chaque chiffre correspondait Ã  une puissance de 2 :</p>
<pre><code>  128 64 32 16  8  4  2  1
    1  1  1  1  1  1  1  1
</code></pre>
<ul>
<li>Avec 8 bits, nous pouvons compter jusquâ€™Ã  255.</li>
</ul>
</li>
<li>
<p>Il sâ€™avÃ¨re quâ€™en hexadÃ©cimal, nous pouvons parfaitement compter jusquâ€™Ã  8 bits binaires avec seulement 2 chiffres :</p>
<pre><code>  16^1 16^0
     F    F
</code></pre>
<ul>
<li>Ici, Â« F Â» est une valeur de 15 en dÃ©cimal, et chaque place est une puissance de 16. Donc le premier Â« F Â» est 16^1 _ 15 = 240, plus le deuxiÃ¨me Â« F Â» avec une valeur de 16^0 _ 15 = 15, pour un total de 255.</li>
</ul>
</li>
<li>
<p>Et Â« 0A Â» est la mÃªme chose que 10 en dÃ©cimal, et Â« 0F Â» la mÃªme chose que 15. Â« 10 Â» en hexadÃ©cimal serait 16, et nous le prononcerions Â« un zÃ©ro en hexadÃ©cimal Â» plutÃ´t que Â« dix Â», pour Ã©viter toute confusion.</p>
</li>
<li>Le systÃ¨me de couleurs RVB utilise Ã©galement traditionnellement lâ€™hexadÃ©cimal pour dÃ©crire la quantitÃ© de chaque couleur. Par exemple, Â« 000000 Â» en hexadÃ©cimal signifie 0 pour chaque couleur rouge, verte et bleue, pour une couleur noire. Et Â« FF0000 Â» serait 255, ou la quantitÃ© la plus Ã©levÃ©e possible, de rouge. Avec des valeurs diffÃ©rentes pour chaque couleur, nous pouvons reprÃ©senter des millions de couleurs diffÃ©rentes.</li>
<li>Ã€ lâ€™Ã©crit, nous pouvons aussi indiquer quâ€™une valeur est en hexadÃ©cimal en la faisant prÃ©cÃ©der de Â« 0x Â», comme dans Â« 0x10 Â», oÃ¹ la valeur est Ã©gale Ã  16 en dÃ©cimal, par opposition Ã  10.</li>
</ul>
<h2>Pointeurs</h2>
<ul>
<li>
<p>Nous pouvons crÃ©er une valeur <code>n</code> et l'imprimer&nbsp;:</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      int n = 50;
      printf("%i\n", n);
  }
</code></pre>
</li>
<li>
<p>Dans la mÃ©moire de notre ordinateur, il y a maintenant 4 octets quelque part qui ont la valeur binaire 50, Ã©tiquetÃ©s <code>n</code>&nbsp;:
  <img alt="grille reprÃ©sentant des octets, avec quatre boÃ®tes ensemble contenant 50 avec un petit n en dessous" src="https://cs50.harvard.edu/x/2020/notes/4/n.png" /></p>
</li>
<li>Il s'avÃ¨re qu'avec les milliards d'octets en mÃ©moire, ces octets pour la variable <code>n</code> commencent Ã  une adresse unique qui pourrait ressembler Ã  <code>0x12345678</code>.</li>
<li>
<p>En C, nous pouvons rÃ©ellement voir l'adresse avec l'opÃ©rateur <code>&amp;</code>, qui signifie Â«Â obtenir l'adresse de cette variableÂ Â»Â :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      int n = 50;
      printf("%p\n", &amp;n);
  }
</code></pre>
<ul>
<li>Et dans l'IDE CS50, nous pourrions voir une adresse comme <code>0x7ffe00b3adbc</code>, oÃ¹ il s'agit d'un emplacement spÃ©cifique dans la mÃ©moire du serveur.</li>
</ul>
</li>
<li>
<p>L'adresse d'une variable est appelÃ©e un <strong>pointeur</strong>, que nous pouvons considÃ©rer comme une valeur qui Â«Â pointeÂ Â» vers un emplacement en mÃ©moire. L'opÃ©rateur <code>*</code> nous permet Â«Â d'allerÂ Â» Ã  l'emplacement vers lequel pointe un pointeur.</p>
</li>
<li>
<p>Par exemple, nous pouvons imprimer <code>*&amp;n</code>, oÃ¹ nous Â«Â allonsÂ Â» Ã  l'adresse de <code>n</code>, et cela imprimera la valeur de <code>n</code>, <code>50</code>, puisque c'est la valeur Ã  l'adresse de <code>n</code>Â :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      int n = 50;
      printf("%i\n", *&amp;n);
  }
</code></pre>
</li>
<li>
<p>Nous devons Ã©galement utiliser l'opÃ©rateur <code>*</code> (d'une maniÃ¨re malheureusement dÃ©routante) pour dÃ©clarer une variable que nous voulons Ãªtre un pointeurÂ :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
     int n = 50;
     int *p = &amp;n;
     printf("%p\n", p);
  }
</code></pre>
<ul>
<li>Ici, nous utilisons <code>int *p</code> pour dÃ©clarer une variable, <code>p</code>, qui a le type de <code>*</code>, un pointeur, vers une valeur de type <code>int</code>, un entier. Ensuite, nous pouvons imprimer sa valeur (quelque chose comme <code>0x12345678</code>), ou imprimer la valeur Ã  son emplacement avec <code>printf("%i\n", *p);</code>.</li>
</ul>
</li>
<li>
<p>Dans la mÃ©moire de notre ordinateur, les variables pourraient ressembler Ã  ceciÂ :
  <img alt="grille reprÃ©sentant des octets, avec quatre boÃ®tes ensemble contenant 50 avec un petit 0x12345678 en dessous, et huit boÃ®tes ensemble contenant 0x12345678 avec un petit p en dessous" src="https://cs50.harvard.edu/x/2020/notes/4/p.png" /></p>
<ul>
<li>Nous avons un pointeur, <code>p</code>, avec l'adresse d'une variable.</li>
</ul>
</li>
<li>Nous pouvons maintenant faire abstraction de la valeur rÃ©elle des adresses, car elles seront diffÃ©rentes lorsque nous dÃ©clarerons des variables dans nos programmes, et simplement penser Ã  <code>p</code> comme Â«Â pointant versÂ Â» une valeurÂ :
  <img alt="une boÃ®te contenant p pointant vers une boÃ®te plus petite contenant 50" src="https://cs50.harvard.edu/x/2020/notes/4/pointing.png" /></li>
<li>Supposons que nous ayons une boÃ®te aux lettres Ã©tiquetÃ©e Â«Â 123Â Â», avec le numÃ©ro Â«Â 50Â Â» Ã  l'intÃ©rieur. La boÃ®te aux lettres serait <code>int n</code>, car elle stocke un entier. Nous pourrions avoir une autre boÃ®te aux lettres avec l'adresse Â«Â 456Â Â», Ã  l'intÃ©rieur de laquelle se trouve la valeur Â«Â 123Â Â», qui est l'adresse de notre autre boÃ®te aux lettres. Ce serait <code>int *p</code>, puisqu'il s'agit d'un pointeur vers un entier.</li>
<li>GrÃ¢ce Ã  la possibilitÃ© d'utiliser des pointeurs, nous pouvons crÃ©er diffÃ©rentes structures de donnÃ©es, ou diffÃ©rentes maniÃ¨res d'organiser les donnÃ©es en mÃ©moire que nous verrons la semaine prochaine.</li>
<li>De nombreux systÃ¨mes informatiques modernes sont Â«Â 64 bitsÂ Â», ce qui signifie qu'ils utilisent 64 bits pour adresser la mÃ©moire. Un pointeur fera donc 8 octets, soit deux fois plus qu'un entier de 4 octets.</li>
</ul>
<h2>string</h2>
<ul>
<li>On pourrait avoir une variable <code>string s</code> pour un nom tel que <code>EMMA</code> et pouvoir accÃ©der Ã  chaque caractÃ¨re avec <code>s[0]</code> et ainsi de suiteÂ :<br />
<img alt="cases cÃ´te Ã  cÃ´te, contenantÂ : E Ã©tiquetÃ© s[0], M Ã©tiquetÃ© s[1], M Ã©tiquetÃ© s[2], A Ã©tiquetÃ© s[3], \0 Ã©tiquetÃ© s[4]" src="https://cs50.harvard.edu/x/2020/notes/4/s_array.png" /></li>
<li>Mais il sâ€™avÃ¨re que chaque caractÃ¨re est stockÃ© en mÃ©moire dans un octet avec une adresse donnÃ©e, et <code>s</code> est en fait juste un pointeur avec lâ€™adresse du premier caractÃ¨reÂ :<br />
<img alt="case contenant 0x123 Ã©tiquetÃ© s, cases cÃ´te Ã  cÃ´te contenant E Ã©tiquetÃ© 0x123, M Ã©tiquetÃ© 0x124, M Ã©tiquetÃ© 0x125, A Ã©tiquetÃ© 0x126, \0 Ã©tiquetÃ© 0x127" src="https://cs50.harvard.edu/x/2020/notes/4/s_pointer.png" /></li>
<li>Et puisque <code>s</code> est juste un pointeur vers le dÃ©but, seul le <code>\0</code> indique la fin de la chaÃ®ne.</li>
<li>En fait, la CS50 Library dÃ©finit une <code>string</code> avec <code>typedef char *string</code>, qui dit juste que nous voulons nommer un nouveau type, <code>string</code>, comme un <code>char *</code>, ou un pointeur vers un caractÃ¨re.</li>
<li>
<p>Imprimons une chaÃ®neÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string s = "EMMA";
      printf("%s\n", s);
  }
</code></pre>
</li>
<li>
<p>Câ€™est familier, mais nous pouvons simplement direÂ :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(void)
  {
      char *s = "EMMA";
      printf("%s\n", s);
  }
</code></pre>
<ul>
<li>Cela imprimera Ã©galement <code>EMMA</code>.</li>
</ul>
</li>
<li>
<p>Avec <code>printf("%p\n", s);</code>, nous pouvons imprimer <code>s</code> comme sa valeur en tant que pointeur, comme <code>0x42ab52</code>. (<code>printf</code> sait aller Ã  lâ€™adresse et imprimer la chaÃ®ne entiÃ¨re lorsque nous utilisons <code>%s</code> et transmettons <code>s</code>, mÃªme si <code>s</code> pointe uniquement vers le premier caractÃ¨re.)</p>
</li>
<li>Nous pouvons Ã©galement essayer <code>printf("%p\n", &amp;s[0]);</code>, qui est lâ€™adresse du premier caractÃ¨re de <code>s</code>, et câ€™est exactement la mÃªme chose que dâ€™imprimer <code>s</code>. Et l'impression de <code>&amp;s[1]</code>, <code>&amp;s[2]</code> et <code>&amp;s[3]</code> nous donne les adresses qui sont les caractÃ¨res suivants en mÃ©moire aprÃ¨s <code>&amp;s[0]</code>, comme <code>0x42ab53</code>, <code>0x42ab54</code> et <code>0x42ab55</code>, exactement un octet aprÃ¨s l'autre.</li>
<li>Et enfin, si on essaie de <code>printf("%c\n", *s);</code>, on obtient un seul caractÃ¨re <code>E</code>, puisqu'on va Ã  l'adresse contenue dans <code>s</code>, qui contient le premier caractÃ¨re de la chaÃ®ne.</li>
<li>En fait, <code>s[0]</code>, <code>s[1]</code> et <code>s[2]</code> sont rÃ©ellement mappÃ©s directement sur <code>*s</code>, <code>*(s+1)</code> et <code>*(s+2)</code>, puisque chacun des caractÃ¨res suivants se trouve juste Ã  l'adresse de l'octet suivant.</li>
</ul>
<h2>Comparer et copier</h2>
<ul>
<li>
<p>Examinons <code>compare0</code>Â :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Obtenir deux entiers
      int i = get_int("iÂ : ");
      int j = get_int("jÂ : ");

      // Comparer les entiers
      if (i == j)
      {
          printf("Identique\n");
      }
      else
      {
          printf("DiffÃ©rent\n");
      }
  }
</code></pre>
<ul>
<li>Nous pouvons compiler et exÃ©cuter ce code, et notre programme fonctionne comme prÃ©vuÂ : si les deux entiers sont identiques, le rÃ©sultat est Â«Â IdentiqueÂ Â», et s'ils sont diffÃ©rents, le rÃ©sultat est Â«Â DiffÃ©rentÂ Â».</li>
</ul>
</li>
<li>
<p>Dans <code>compare1</code>, nous constatons que des valeurs de chaÃ®ne identiques font que notre programme affiche Â«Â DiffÃ©rentÂ Â»Â :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      // Obtenir deux chaÃ®nes
      string s = get_string("sÂ : ");
      string t = get_string("tÂ : ");

      // Comparer les adresses des chaÃ®nes
      if (s == t)
      {
          printf("Identique\n");
      }
      else
      {
          printf("DiffÃ©rent\n");
      }
  }
</code></pre>
<ul>
<li>Compte tenu de ce que nous savons Ã  prÃ©sent sur les chaÃ®nes, cela est logique parce que chaque variable de Â«Â chaÃ®neÂ Â» pointe vers un emplacement diffÃ©rent en mÃ©moire, oÃ¹ est stockÃ© le premier caractÃ¨re de chaque chaÃ®ne. Ainsi, mÃªme si les valeurs des chaÃ®nes sont identiques, l'affichage sera toujours Â«Â DiffÃ©rentÂ Â».</li>
<li>Par exemple, notre premiÃ¨re chaÃ®ne peut Ãªtre Ã  l'adresse 0x123, notre seconde Ã  l'adresse 0x456, et <code>s</code> sera <code>0x123</code> et <code>t</code> sera <code>0x456</code>, donc ces valeurs seront diffÃ©rentes.</li>
<li>Et <code>get_string</code>, pendant tout ce temps, n'a renvoyÃ© qu'un <code>char *</code>, ou un pointeur vers le premier caractÃ¨re d'une chaÃ®ne provenant de l'utilisateur.</li>
</ul>
</li>
<li>
<p>Essayons Ã  prÃ©sent de copier une chaÃ®neÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;ctype.h&gt;
  #include &lt;stdio.h&gt;

  int main(void)
  {
      string s = get_string("sÂ : ");

      string t = s;

      t[0] = toupper(t[0]);

      // Afficher la chaÃ®ne deux fois
      printf("sÂ : %s\n", s);
      printf("tÂ : %s\n", t);
  }
</code></pre>
<ul>
<li>Nous obtenons une chaÃ®ne <code>s</code>, et copions la valeur de <code>s</code> dans <code>t</code>. Ensuite, nous mettons en majuscule la premiÃ¨re lettre dans <code>t</code>.</li>
<li>Mais lorsque nous exÃ©cutons notre programme, nous constatons que <code>s</code> et <code>t</code> sont Ã  prÃ©sent tous les deux en majuscules.</li>
<li>Dans la mesure oÃ¹ nous dÃ©finissons <code>s</code> et <code>t</code> avec les mÃªmes valeurs, ils sont en rÃ©alitÃ© des pointeurs vers le mÃªme caractÃ¨re, et nous venons donc de mettre en majuscule le mÃªme caractÃ¨reÂ !</li>
</ul>
</li>
<li>
<p>Pour effectuer une vÃ©ritable copie d'une chaÃ®ne, nous devons fournir un effort un peu plus importantÂ :</p>
<pre><code>  #include &lt;cs50.h&gt;
  #include &lt;ctype.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  int main(void)
  {
      char *s = get_string("sÂ : ");

      char *t = malloc(strlen(s) + 1);

      for (int i = 0, n = strlen(s); i &lt; n + 1; i++)
      {
          t[i] = s[i];
      }

      t[0] = toupper(t[0]);

      printf("sÂ : %s\n", s);
      printf("tÂ : %s\n", t);
  }
</code></pre>
<ul>
<li>Nous crÃ©ons une nouvelle variable, <code>t</code>, de type <code>char *</code>, avec <code>char *t</code>. Ã€ prÃ©sent, nous souhaitons la faire pointer vers un nouveau bloc de mÃ©moire suffisamment volumineux pour stocker la copie de la chaÃ®ne. Avec <code>malloc</code>, nous pouvons allouer un certain nombre d'octets en mÃ©moire (qui ne sont pas dÃ©jÃ  utilisÃ©s pour stocker d'autres valeurs), et nous faisons passer le nombre d'octets que nous souhaiterions. Nous connaissons dÃ©jÃ  la longueur de <code>s</code>, nous ajoutons donc 1 pour le caractÃ¨re null de terminaison. Ainsi, notre derniÃ¨re ligne de code est <code>char *t = malloc(strlen(s) + 1);</code>.</li>
<li>Ensuite, nous copions chaque caractÃ¨re, un Ã  la fois, et Ã  prÃ©sent, nous pouvons mettre en majuscule uniquement la premiÃ¨re lettre de <code>t</code>. Et nous utilisons <code>i &lt; n + 1</code>, car nous souhaitons en rÃ©alitÃ© atteindre <code>n</code>, afin de garantir de copier le caractÃ¨re de terminaison dans la chaÃ®ne.</li>
<li>Nous pouvons Ã©galement utiliser la fonction de bibliothÃ¨que <code>strcpy</code> avec <code>strcpy(t, s)</code> Ã  la place de notre boucle pour copier la chaÃ®ne <code>s</code> dans <code>t</code>. Pour Ãªtre clair, le concept d'une Â«Â chaÃ®neÂ Â» vient du langage C et est bien pris en chargeÂ ; les seules roulettes d'entraÃ®nement de CS50 sont le type <code>string</code> Ã  la place de <code>char *</code> et la fonction <code>get_string</code>.</li>
</ul>
</li>
<li>
<p>Si nous ne copions pas le caractÃ¨re null de terminaison, <code>\0</code>, et essayons d'imprimer notre chaÃ®ne <code>t</code>, <code>printf</code> continuera et imprimera les valeurs inconnues, ou indÃ©sirables, que nous avons en mÃ©moire, jusqu'Ã  atteindre un <code>\0</code>, ou s'arrÃªtera complÃ¨tement, dans la mesure oÃ¹ notre programme pourrait se mettre Ã  essayer de lire de la mÃ©moire qui ne lui appartient pasÂ !</p>
</li>
</ul>
<h2>valgrind</h2>
<ul>
<li>Il s'avÃ¨re qu'aprÃ¨s avoir terminÃ© avec la mÃ©moire que nous avons allouÃ©e avec <code>malloc</code>, nous devrions appeler <code>free</code> (comme dans <code>free(t)</code>), ce qui indique Ã  notre ordinateur que ces octets ne sont plus utiles Ã  notre programme, permettant ainsi Ã  ces octets en mÃ©moire d'Ãªtre rÃ©utilisÃ©s.</li>
<li>Si nous continuions Ã  exÃ©cuter notre programme et Ã  allouer de la mÃ©moire avec <code>malloc</code>, mais que nous ne libÃ©rions jamais la mÃ©moire aprÃ¨s l'avoir utilisÃ©e, nous aurions une <strong>fuite de mÃ©moire</strong>, ce qui ralentirait notre ordinateur et utiliserait de plus en plus de mÃ©moire jusqu'Ã  ce que notre ordinateur manque de mÃ©moire.</li>
<li><code>valgrind</code> est un outil en ligne de commande que nous pouvons utiliser pour exÃ©cuter notre programme et vÃ©rifier s'il prÃ©sente des fuites de mÃ©moire. Nous pouvons exÃ©cuter valgrind sur notre programme ci-dessus avec <code>help50 valgrind ./copy</code> et constater, Ã  partir du message d'erreur, que la ligne 10 montre que nous avons allouÃ© de la mÃ©moire que nous n'avons jamais libÃ©rÃ©e (ou "perdue").</li>
<li>Ainsi, Ã  la fin, nous pouvons ajouter une ligne <code>free(t)</code>, ce qui ne changera pas le fonctionnement de notre programme, mais ne gÃ©nÃ©rera plus d'erreurs avec valgrind.</li>
<li>
<p>Regardons le fichier <code>memory.c</code> :</p>
<pre><code>  // http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare

  #include &lt;stdlib.h&gt;

  void f(void)
  {
      int *x = malloc(10 * sizeof(int));
      x[10] = 0;
  }

  int main(void)
  {
      f();
      return 0;
  }
</code></pre>
<ul>
<li>Il s'agit d'un exemple provenant de la documentation de valgrind (valgrind est un vÃ©ritable outil, tandis que help50 a Ã©tÃ© spÃ©cialement Ã©crit pour nous aider dans ce cours).</li>
<li>La fonction <code>f</code> alloue suffisamment de mÃ©moire pour 10 entiers et stocke l'adresse dans un pointeur appelÃ© <code>x</code>. Ensuite, nous essayons de dÃ©finir la 11Ã¨me valeur de <code>x</code> avec <code>x[10]</code> Ã  <code>0</code>, ce qui dÃ©passe le tableau de mÃ©moire que nous avons allouÃ© pour notre programme. Cela s'appelle un <strong>dÃ©passement de tampon</strong>, oÃ¹ nous dÃ©passons les limites de notre tampon, ou tableau, et accÃ©dons Ã  une mÃ©moire inconnue.</li>
</ul>
</li>
<li>
<p>valgrind nous indiquera Ã©galement qu'il y a une "Ã‰criture invalide de taille 4" pour la ligne 8, oÃ¹ nous essayons en effet de modifier la valeur d'un entier (de taille 4 octets).</p>
</li>
<li>Et pendant tout ce temps, la bibliothÃ¨que CS50 a libÃ©rÃ© la mÃ©moire qu'elle a allouÃ©e dans <code>get_string</code>, lorsque notre programme se termine !</li>
</ul>
<h2>Inversion</h2>
<ul>
<li>Nous avons deux boissons colorÃ©es, violette et verte, chacune dans une tasse. Nous voulons intervertir les boissons entre les deux tasses, mais nous ne pouvons pas le faire sans une troisiÃ¨me tasse dans laquelle verser d'abord une des boissons.</li>
<li>
<p>Maintenant, disons que nous voulons intervertir les valeurs de deux entiers.</p>
<pre><code>  void swap(int a, int b)
  {
      int tmp = a;
      a = b;
      b = tmp;
  }
</code></pre>
</li>
<li>
<p>Avec une troisiÃ¨me variable Ã  utiliser comme espace de stockage temporaire, nous pouvons le faire assez facilement, en mettant <code>a</code> dans <code>tmp</code>, puis <code>b</code> dans <code>a</code>, et enfin la valeur d'origine de <code>a</code>, maintenant dans <code>tmp</code>, dans <code>b</code>.</p>
</li>
<li>
<p>Mais, si nous essayions d'utiliser cette fonction dans un programme, nous ne verrions aucun changement :</p>
<pre><code>  #include &lt;stdio.h&gt;

  void swap(int a, int b);

  int main(void)
  {
      int x = 1;
      int y = 2;

      printf("x est %i, y est %i\n", x, y);
      swap(x, y);
      printf("x est %i, y est %i\n", x, y);
  }

  void swap(int a, int b)
  {
      int tmp = a;
      a = b;
      b = tmp;
  }
</code></pre>
</li>
<li>
<p>Il s'avÃ¨re que la fonction <code>swap</code> obtient ses propres variables, <code>a</code> et <code>b</code> lorsqu'elles sont passÃ©es, qui sont des copies de <code>x</code> et <code>y</code>, et donc changer ces valeurs ne change pas <code>x</code> et <code>y</code> dans la fonction <code>main</code>.</p>
</li>
</ul>
<h2>Disposition en mÃ©moire</h2>
<ul>
<li>Dans la mÃ©moire de notre ordinateur, les diffÃ©rents types de donnÃ©es qui doivent Ãªtre stockÃ©s pour notre programme sont organisÃ©s dans diffÃ©rentes sectionsÂ :
  <img alt="Grille avec sections, du haut vers le basÂ : code machine, globales, tas (avec flÃ¨che pointant vers le bas), pile (avec flÃ¨che pointant vers le haut)" src="https://cs50.harvard.edu/x/2020/notes/4/memory_layout.png" /><ul>
<li>La section de <em>code machine</em> est le code binaire de notre programme compilÃ©. Lorsque nous exÃ©cutons notre programme, ce code est chargÃ© dans la Â«Â partie supÃ©rieureÂ Â» de la mÃ©moire.</li>
<li>Les <em>globales</em> sont des variables globales que nous dÃ©clarons dans notre programme ou dâ€™autres variables partagÃ©es auxquelles tout notre programme peut accÃ©der.</li>
<li>La section <em>heap</em> est une zone vide dans laquelle <code>malloc</code> peut obtenir de la mÃ©moire libre, pour que notre programme puisse lâ€™utiliser.</li>
<li>La section <em>stack</em> est utilisÃ©e par des fonctions de notre programme lorsquâ€™elles sont appelÃ©es. Par exemple, notre fonction <code>main</code> est tout en bas de la pile et possÃ¨de les variables locales <code>x</code> et <code>y</code>. Lorsque la fonction <code>swap</code> est appelÃ©e, elle possÃ¨de son propre cadre ou tranche de mÃ©moire qui se trouve au-dessus de la mÃ©moire de <code>main</code>, avec les variables locales <code>a</code>, <code>b</code> et <code>tmp</code>Â :
  <img alt="Section de pile avec (a, b, tmp) au-dessus de (x, y)" src="https://cs50.harvard.edu/x/2020/notes/4/stack.png" /><ul>
<li>Une fois que la fonction <code>swap</code> renvoie, la mÃ©moire quâ€™elle utilisait est libÃ©rÃ©e pour lâ€™appel de fonction suivant, et nous perdons tout ce que nous avons fait, mis Ã  part les valeurs renvoyÃ©es, et notre programme revient Ã  la fonction qui a appelÃ© <code>swap</code>.</li>
<li>Par consÃ©quent, en transmettant les adresses de <code>x</code> et <code>y</code> de <code>main</code> Ã  <code>swap</code>, nous pouvons rÃ©ellement modifier les valeurs de <code>x</code> et <code>y</code>Â : <img alt="Section de pile avec (a, b, tmp) au-dessus de (x, y), et a pointant vers x et b pointant vers y" src="https://cs50.harvard.edu/x/2020/notes/4/pointers.png" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p>En transmettant lâ€™adresse de <code>x</code> et de <code>y</code>, notre fonction <code>swap</code> peut rÃ©ellement fonctionnerÂ :</p>
<pre><code>  #include &lt;stdio.h&gt;

  void swap(int *a, int *b)Â ;

  int main(void)
  {
      int x = 1Â ;
      int y = 2Â ;

      printf("x est %i, y est %i\n", x, y)Â ;
      swap(&amp;x, &amp;y)Â ;
      printf("x est %i, y est %i\n", x, y)Â ;
  }

  void swap(int *a, int *b)
  {
      int tmp = *aÂ ;
      *a = *bÂ ;
      *b = tmpÂ ;
  }
</code></pre>
<ul>
<li>Les adresses de <code>x</code> et de <code>y</code> sont transmises dans <code>main</code> Ã  <code>swap</code>, et nous utilisons la syntaxe <code>int *a</code> pour dÃ©clarer que notre fonction <code>swap</code> prend des pointeurs. Nous enregistrons la valeur de <code>x</code> dans <code>tmp</code> en suivant le pointeur <code>a</code>, puis nous prenons la valeur de <code>y</code> en suivant le pointeur <code>b</code> et nous la stockons dans lâ€™emplacement vers lequel <code>a</code> pointe (<code>x</code>). Enfin, nous stockons la valeur de <code>tmp</code> dans lâ€™emplacement pointÃ© par <code>b</code> (<code>y</code>), et nous avons terminÃ©.</li>
</ul>
</li>
<li>
<p>Si nous appelons <code>malloc</code> trop souvent, nous aurons un <strong>dÃ©passement de segment</strong>, oÃ¹ nous finissons par dÃ©passer notre segment. Ou bien, si nous avons trop de fonctions appelÃ©es, nous aurons un <strong>dÃ©passement de pile</strong>, oÃ¹ notre pile a Ã©galement trop de cadres de mÃ©moire allouÃ©e. Et ces deux types de dÃ©passement sont gÃ©nÃ©ralement appelÃ©s dÃ©passements de tampon, aprÃ¨s quoi notre programme (ou ordinateur entier) peut planter.</p>
</li>
</ul>
<h2>get_int</h2>
<ul>
<li>Nous pouvons implÃ©menter <code>get_int</code> nous-mÃªmes avec une fonction de la bibliothÃ¨que C, <code>scanf</code> :</li>
</ul>
<p>```</p>
<h1>include <stdio.h></h1>
<p>int main(void)
{
    int x;
    printf("x : ");
    scanf("%i", &amp;x);
    printf("x : %i\n", x);
}
```</p>
<ul>
<li>
<p><code>scanf</code> prend un format, <code>%i</code>, donc l'entrÃ©e est Â« scannÃ©e Â» pour ce format, ainsi que l'adresse en mÃ©moire oÃ¹ nous voulons que cette entrÃ©e aille. Mais <code>scanf</code> ne vÃ©rifie pas beaucoup les erreurs, donc nous n'obtiendrons peut-Ãªtre pas un entier.</p>
</li>
<li>
<p>Nous pouvons essayer d'obtenir une chaÃ®ne de la mÃªme maniÃ¨re :</p>
</li>
</ul>
<p>```</p>
<h1>include <stdio.h></h1>
<p>int main(void)
{
    char *s = NULL;
    printf("s : ");
    scanf("%s", s);
    printf("s : %s\n", s);
}
```</p>
<ul>
<li>Mais nous n'avons en fait allouÃ© aucune mÃ©moire pour <code>s</code> (<code>s</code> est <code>NULL</code>, ou ne pointe vers rien), donc nous pourrions vouloir appeler <code>char s[5]</code> pour allouer un tableau de 5 caractÃ¨res pour notre chaÃ®ne. Ensuite, <code>s</code> sera traitÃ© comme un pointeur dans <code>scanf</code> et <code>printf</code>.</li>
<li>Maintenant, si l'utilisateur tape une chaÃ®ne d'une longueur de 4 ou moins, notre programme fonctionnera en toute sÃ©curitÃ©. Mais si l'utilisateur tape une chaÃ®ne plus longue, <code>scanf</code> pourrait essayer d'Ã©crire au-delÃ  de la fin de notre tableau dans une mÃ©moire inconnue, provoquant la soudaine perte de contrÃ´le de notre programme.</li>
</ul>
<h2>Fichiers</h2>
<ul>
<li>Avec la possibilitÃ© d'utiliser des pointeurs, nous pouvons Ã©galement ouvrir des fichiersÂ :</li>
</ul>
<p>```</p>
<h1>include <cs50.h></h1>
<h1>include <stdio.h></h1>
<h1>include <string.h></h1>
<p>int main(void)
{
    // Ouvrir le fichier
    FILE *file = fopen("phonebook.csv", "a");</p>
<pre><code>  // Obtenir des chaÃ®nes de l'utilisateur
  char *name = get_string("NomÂ : ");
  char *number = get_string("NumÃ©roÂ : ");

  // Imprimer (Ã©crire) des chaÃ®nes dans le fichier
  fprintf(file, "%s,%s\n", name, number);

  // Fermer le fichier
  fclose(file);
</code></pre>
<p>}
```</p>
<ul>
<li><code>fopen</code> est une nouvelle fonction que nous pouvons utiliser pour ouvrir un fichier. Elle retournera un pointeur vers un nouveau type, <code>FILE</code>, Ã  partir duquel nous pouvons lire et Ã©crire. Le premier argument est le nom du fichier et le second argument est le mode dans lequel nous souhaitons ouvrir le fichier (<code>r</code> pour lecture, <code>w</code> pour Ã©criture et <code>a</code> pour ajout).</li>
<li>AprÃ¨s avoir obtenu des chaÃ®nes, nous pouvons utiliser <code>fprintf</code> pour imprimer dans un fichier.</li>
<li>
<p>Finalement, nous fermons le fichier avec <code>fclose</code>.</p>
</li>
<li>
<p>Nous pouvons dÃ©sormais crÃ©er nos propres fichiers CSV (valeurs sÃ©parÃ©es par des virgules), comme de mini-tableurs, par programmation.</p>
</li>
</ul>
<h1>JPEG</h1>
<ul>
<li>
<p>Nous pouvons aussi Ã©crire un programme qui ouvre un fichier et qui nous dit si c'est un fichier JPEG (une image) :</p>
<pre><code>  #include &lt;stdio.h&gt;

  int main(int argc, char *argv[])
  {
      // VÃ©rifie l'utilisation
      if (argc != 2)
      {
          return 1;
      }

      // Ouvre le fichier
      FILE *file = fopen(argv[1], "r");
      if (!file)
      {
          return 1;
      }

      // Lit les trois premiers octets
      unsigned char bytes[3];
      fread(bytes, 3, 1, file);

      // VÃ©rifie les trois premiers octets
      if (bytes[0] == 0xff &amp;&amp; bytes[1] == 0xd8 &amp;&amp; bytes[2] == 0xff)
      {
          printf("Peut-Ãªtre\n");
      }
      else
      {
          printf("Non\n");
      }

      // Ferme le fichier
      fclose(file);
  }
</code></pre>
</li>
<li>
<p>Maintenant, si on exÃ©cute ce programme avec <code>./jpeg brian.jpg</code>, notre programme va essayer d'ouvrir le fichier que nous spÃ©cifions (en vÃ©rifiant qu'on obtient un fichier non-NULL), et lit les trois premiers octets du fichier avec <code>fread</code>.</p>
</li>
<li>
<p>On peut comparer les trois premiers octets (en hexadÃ©cimal) aux trois octets requis pour commencer un fichier JPEG. S'ils sont identiques, alors notre fichier est probablement un fichier JPEG (bien que d'autres types de fichiers peuvent aussi commencer par ces octets). Mais si les octets ne sont pas les mÃªmes, alors on sait que ce n'est dÃ©finitivement pas un fichier JPEG.</p>
</li>
<li>
<p>On peut utiliser ces capacitÃ©s pour lire et Ã©crire des fichiers, en particulier des images, et de les modifier en changeant les octets qu'ils contiennent, dans le problÃ¨me de cette semaine !</p>
</li>
</ul>


        </main>
      </div>
    </div>
  </body>

</html>